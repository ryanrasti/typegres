/// <reference types="./object-utils.d.ts" />
function isUndefined(obj) {
    return typeof obj === 'undefined' || obj === undefined;
}
function isString(obj) {
    return typeof obj === 'string';
}
function isNumber(obj) {
    return typeof obj === 'number';
}
function isBoolean(obj) {
    return typeof obj === 'boolean';
}
function isNull(obj) {
    return obj === null;
}
function isDate(obj) {
    return obj instanceof Date;
}
function isBigInt(obj) {
    return typeof obj === 'bigint';
}
function isFunction(obj) {
    return typeof obj === 'function';
}
function isObject(obj) {
    return typeof obj === 'object' && obj !== null;
}
function freeze(obj) {
    return Object.freeze(obj);
}
function asArray(arg) {
    if (isReadonlyArray(arg)) {
        return arg;
    }
    else {
        return [arg];
    }
}
function isReadonlyArray(arg) {
    return Array.isArray(arg);
}
function noop(obj) {
    return obj;
}

/// <reference types="./alter-table-node.d.ts" />
/**
 * @internal
 */
const AlterTableNode = freeze({
    is(node) {
        return node.kind === 'AlterTableNode';
    },
    create(table) {
        return freeze({
            kind: 'AlterTableNode',
            table,
        });
    },
    cloneWithTableProps(node, props) {
        return freeze({
            ...node,
            ...props,
        });
    },
    cloneWithColumnAlteration(node, columnAlteration) {
        return freeze({
            ...node,
            columnAlterations: node.columnAlterations
                ? [...node.columnAlterations, columnAlteration]
                : [columnAlteration],
        });
    },
});

/// <reference types="./identifier-node.d.ts" />
/**
 * @internal
 */
const IdentifierNode = freeze({
    is(node) {
        return node.kind === 'IdentifierNode';
    },
    create(name) {
        return freeze({
            kind: 'IdentifierNode',
            name,
        });
    },
});

/// <reference types="./create-index-node.d.ts" />
/**
 * @internal
 */
const CreateIndexNode = freeze({
    is(node) {
        return node.kind === 'CreateIndexNode';
    },
    create(name) {
        return freeze({
            kind: 'CreateIndexNode',
            name: IdentifierNode.create(name),
        });
    },
    cloneWith(node, props) {
        return freeze({
            ...node,
            ...props,
        });
    },
    cloneWithColumns(node, columns) {
        return freeze({
            ...node,
            columns: [...(node.columns || []), ...columns],
        });
    },
});

/// <reference types="./create-schema-node.d.ts" />
/**
 * @internal
 */
const CreateSchemaNode = freeze({
    is(node) {
        return node.kind === 'CreateSchemaNode';
    },
    create(schema, params) {
        return freeze({
            kind: 'CreateSchemaNode',
            schema: IdentifierNode.create(schema),
            ...params,
        });
    },
    cloneWith(createSchema, params) {
        return freeze({
            ...createSchema,
            ...params,
        });
    },
});

/// <reference types="./create-table-node.d.ts" />
const ON_COMMIT_ACTIONS = ['preserve rows', 'delete rows', 'drop'];
/**
 * @internal
 */
const CreateTableNode = freeze({
    is(node) {
        return node.kind === 'CreateTableNode';
    },
    create(table) {
        return freeze({
            kind: 'CreateTableNode',
            table,
            columns: freeze([]),
        });
    },
    cloneWithColumn(createTable, column) {
        return freeze({
            ...createTable,
            columns: freeze([...createTable.columns, column]),
        });
    },
    cloneWithConstraint(createTable, constraint) {
        return freeze({
            ...createTable,
            constraints: createTable.constraints
                ? freeze([...createTable.constraints, constraint])
                : freeze([constraint]),
        });
    },
    cloneWithFrontModifier(createTable, modifier) {
        return freeze({
            ...createTable,
            frontModifiers: createTable.frontModifiers
                ? freeze([...createTable.frontModifiers, modifier])
                : freeze([modifier]),
        });
    },
    cloneWithEndModifier(createTable, modifier) {
        return freeze({
            ...createTable,
            endModifiers: createTable.endModifiers
                ? freeze([...createTable.endModifiers, modifier])
                : freeze([modifier]),
        });
    },
    cloneWith(createTable, params) {
        return freeze({
            ...createTable,
            ...params,
        });
    },
});

/// <reference types="./schemable-identifier-node.d.ts" />
/**
 * @internal
 */
const SchemableIdentifierNode = freeze({
    is(node) {
        return node.kind === 'SchemableIdentifierNode';
    },
    create(identifier) {
        return freeze({
            kind: 'SchemableIdentifierNode',
            identifier: IdentifierNode.create(identifier),
        });
    },
    createWithSchema(schema, identifier) {
        return freeze({
            kind: 'SchemableIdentifierNode',
            schema: IdentifierNode.create(schema),
            identifier: IdentifierNode.create(identifier),
        });
    },
});

/// <reference types="./drop-index-node.d.ts" />
/**
 * @internal
 */
const DropIndexNode = freeze({
    is(node) {
        return node.kind === 'DropIndexNode';
    },
    create(name, params) {
        return freeze({
            kind: 'DropIndexNode',
            name: SchemableIdentifierNode.create(name),
            ...params,
        });
    },
    cloneWith(dropIndex, props) {
        return freeze({
            ...dropIndex,
            ...props,
        });
    },
});

/// <reference types="./drop-schema-node.d.ts" />
/**
 * @internal
 */
const DropSchemaNode = freeze({
    is(node) {
        return node.kind === 'DropSchemaNode';
    },
    create(schema, params) {
        return freeze({
            kind: 'DropSchemaNode',
            schema: IdentifierNode.create(schema),
            ...params,
        });
    },
    cloneWith(dropSchema, params) {
        return freeze({
            ...dropSchema,
            ...params,
        });
    },
});

/// <reference types="./drop-table-node.d.ts" />
/**
 * @internal
 */
const DropTableNode = freeze({
    is(node) {
        return node.kind === 'DropTableNode';
    },
    create(table, params) {
        return freeze({
            kind: 'DropTableNode',
            table,
            ...params,
        });
    },
    cloneWith(dropIndex, params) {
        return freeze({
            ...dropIndex,
            ...params,
        });
    },
});

/// <reference types="./alias-node.d.ts" />
/**
 * @internal
 */
const AliasNode = freeze({
    is(node) {
        return node.kind === 'AliasNode';
    },
    create(node, alias) {
        return freeze({
            kind: 'AliasNode',
            node,
            alias,
        });
    },
});

/// <reference types="./table-node.d.ts" />
/**
 * @internal
 */
const TableNode = freeze({
    is(node) {
        return node.kind === 'TableNode';
    },
    create(table) {
        return freeze({
            kind: 'TableNode',
            table: SchemableIdentifierNode.create(table),
        });
    },
    createWithSchema(schema, table) {
        return freeze({
            kind: 'TableNode',
            table: SchemableIdentifierNode.createWithSchema(schema, table),
        });
    },
});

/// <reference types="./operation-node-source.d.ts" />
function isOperationNodeSource(obj) {
    return isObject(obj) && isFunction(obj.toOperationNode);
}

/// <reference types="./expression.d.ts" />
function isExpression(obj) {
    return isObject(obj) && 'expressionType' in obj && isOperationNodeSource(obj);
}
function isAliasedExpression(obj) {
    return (isObject(obj) &&
        'expression' in obj &&
        isString(obj.alias) &&
        isOperationNodeSource(obj));
}

/// <reference types="./select-modifier-node.d.ts" />
/**
 * @internal
 */
const SelectModifierNode = freeze({
    is(node) {
        return node.kind === 'SelectModifierNode';
    },
    create(modifier, of) {
        return freeze({
            kind: 'SelectModifierNode',
            modifier,
            of,
        });
    },
    createWithExpression(modifier) {
        return freeze({
            kind: 'SelectModifierNode',
            rawModifier: modifier,
        });
    },
});

/// <reference types="./and-node.d.ts" />
/**
 * @internal
 */
const AndNode = freeze({
    is(node) {
        return node.kind === 'AndNode';
    },
    create(left, right) {
        return freeze({
            kind: 'AndNode',
            left,
            right,
        });
    },
});

/// <reference types="./or-node.d.ts" />
/**
 * @internal
 */
const OrNode = freeze({
    is(node) {
        return node.kind === 'OrNode';
    },
    create(left, right) {
        return freeze({
            kind: 'OrNode',
            left,
            right,
        });
    },
});

/// <reference types="./on-node.d.ts" />
/**
 * @internal
 */
const OnNode = freeze({
    is(node) {
        return node.kind === 'OnNode';
    },
    create(filter) {
        return freeze({
            kind: 'OnNode',
            on: filter,
        });
    },
    cloneWithOperation(onNode, operator, operation) {
        return freeze({
            ...onNode,
            on: operator === 'And'
                ? AndNode.create(onNode.on, operation)
                : OrNode.create(onNode.on, operation),
        });
    },
});

/// <reference types="./join-node.d.ts" />
/**
 * @internal
 */
const JoinNode = freeze({
    is(node) {
        return node.kind === 'JoinNode';
    },
    create(joinType, table) {
        return freeze({
            kind: 'JoinNode',
            joinType,
            table,
            on: undefined,
        });
    },
    createWithOn(joinType, table, on) {
        return freeze({
            kind: 'JoinNode',
            joinType,
            table,
            on: OnNode.create(on),
        });
    },
    cloneWithOn(joinNode, operation) {
        return freeze({
            ...joinNode,
            on: joinNode.on
                ? OnNode.cloneWithOperation(joinNode.on, 'And', operation)
                : OnNode.create(operation),
        });
    },
});

/// <reference types="./binary-operation-node.d.ts" />
/**
 * @internal
 */
const BinaryOperationNode = freeze({
    is(node) {
        return node.kind === 'BinaryOperationNode';
    },
    create(leftOperand, operator, rightOperand) {
        return freeze({
            kind: 'BinaryOperationNode',
            leftOperand,
            operator,
            rightOperand,
        });
    },
});

/// <reference types="./operator-node.d.ts" />
const COMPARISON_OPERATORS = [
    '=',
    '==',
    '!=',
    '<>',
    '>',
    '>=',
    '<',
    '<=',
    'in',
    'not in',
    'is',
    'is not',
    'like',
    'not like',
    'match',
    'ilike',
    'not ilike',
    '@>',
    '<@',
    '^@',
    '&&',
    '?',
    '?&',
    '?|',
    '!<',
    '!>',
    '<=>',
    '!~',
    '~',
    '~*',
    '!~*',
    '@@',
    '@@@',
    '!!',
    '<->',
    'regexp',
    'is distinct from',
    'is not distinct from',
];
const ARITHMETIC_OPERATORS = [
    '+',
    '-',
    '*',
    '/',
    '%',
    '^',
    '&',
    '|',
    '#',
    '<<',
    '>>',
];
const JSON_OPERATORS = ['->', '->>'];
const BINARY_OPERATORS = [
    ...COMPARISON_OPERATORS,
    ...ARITHMETIC_OPERATORS,
    '&&',
    '||',
];
const UNARY_FILTER_OPERATORS = ['exists', 'not exists'];
const UNARY_OPERATORS = ['not', '-', ...UNARY_FILTER_OPERATORS];
const OPERATORS = [
    ...BINARY_OPERATORS,
    ...JSON_OPERATORS,
    ...UNARY_OPERATORS,
    'between',
    'between symmetric',
];
/**
 * @internal
 */
const OperatorNode = freeze({
    is(node) {
        return node.kind === 'OperatorNode';
    },
    create(operator) {
        return freeze({
            kind: 'OperatorNode',
            operator,
        });
    },
});
function isJSONOperator(op) {
    return isString(op) && JSON_OPERATORS.includes(op);
}

/// <reference types="./column-node.d.ts" />
/**
 * @internal
 */
const ColumnNode = freeze({
    is(node) {
        return node.kind === 'ColumnNode';
    },
    create(column) {
        return freeze({
            kind: 'ColumnNode',
            column: IdentifierNode.create(column),
        });
    },
});

/// <reference types="./select-all-node.d.ts" />
/**
 * @internal
 */
const SelectAllNode = freeze({
    is(node) {
        return node.kind === 'SelectAllNode';
    },
    create() {
        return freeze({
            kind: 'SelectAllNode',
        });
    },
});

/// <reference types="./reference-node.d.ts" />
/**
 * @internal
 */
const ReferenceNode = freeze({
    is(node) {
        return node.kind === 'ReferenceNode';
    },
    create(column, table) {
        return freeze({
            kind: 'ReferenceNode',
            table,
            column,
        });
    },
    createSelectAll(table) {
        return freeze({
            kind: 'ReferenceNode',
            table,
            column: SelectAllNode.create(),
        });
    },
});

/// <reference types="./dynamic-reference-builder.d.ts" />
class DynamicReferenceBuilder {
    #dynamicReference;
    get dynamicReference() {
        return this.#dynamicReference;
    }
    /**
     * @private
     *
     * This needs to be here just so that the typings work. Without this
     * the generated .d.ts file contains no reference to the type param R
     * which causes this type to be equal to DynamicReferenceBuilder with
     * any R.
     */
    get refType() {
        return undefined;
    }
    constructor(reference) {
        this.#dynamicReference = reference;
    }
    toOperationNode() {
        return parseSimpleReferenceExpression(this.#dynamicReference);
    }
}
function isDynamicReferenceBuilder(obj) {
    return (isObject(obj) &&
        isOperationNodeSource(obj) &&
        isString(obj.dynamicReference));
}

/// <reference types="./order-by-item-node.d.ts" />
/**
 * @internal
 */
const OrderByItemNode = freeze({
    is(node) {
        return node.kind === 'OrderByItemNode';
    },
    create(orderBy, direction) {
        return freeze({
            kind: 'OrderByItemNode',
            orderBy,
            direction,
        });
    },
});

/// <reference types="./raw-node.d.ts" />
/**
 * @internal
 */
const RawNode = freeze({
    is(node) {
        return node.kind === 'RawNode';
    },
    create(sqlFragments, parameters) {
        return freeze({
            kind: 'RawNode',
            sqlFragments: freeze(sqlFragments),
            parameters: freeze(parameters),
        });
    },
    createWithSql(sql) {
        return RawNode.create([sql], []);
    },
    createWithChild(child) {
        return RawNode.create(['', ''], [child]);
    },
    createWithChildren(children) {
        return RawNode.create(new Array(children.length + 1).fill(''), children);
    },
});

/// <reference types="./order-by-parser.d.ts" />
function isOrderByDirection(thing) {
    return thing === 'asc' || thing === 'desc';
}
function parseOrderBy(args) {
    if (args.length === 2) {
        return [parseOrderByItem(args[0], args[1])];
    }
    if (args.length === 1) {
        const [orderBy] = args;
        if (Array.isArray(orderBy)) {
            return orderBy.map((item) => parseOrderByItem(item));
        }
        return [parseOrderByItem(orderBy)];
    }
    throw new Error(`Invalid number of arguments at order by! expected 1-2, received ${args.length}`);
}
function parseOrderByItem(ref, direction) {
    const parsedRef = parseOrderByExpression(ref);
    if (OrderByItemNode.is(parsedRef)) {
        if (direction) {
            throw new Error('Cannot specify direction twice!');
        }
        return parsedRef;
    }
    return OrderByItemNode.create(parsedRef, parseOrderByDirectionExpression(direction));
}
function parseOrderByExpression(expr) {
    if (isExpressionOrFactory(expr)) {
        return parseExpression(expr);
    }
    if (isDynamicReferenceBuilder(expr)) {
        return expr.toOperationNode();
    }
    const [ref, direction] = expr.split(' ');
    if (direction) {
        if (!isOrderByDirection(direction)) {
            throw new Error(`Invalid order by direction: ${direction}`);
        }
        return OrderByItemNode.create(parseStringReference(ref), parseOrderByDirectionExpression(direction));
    }
    return parseStringReference(expr);
}
function parseOrderByDirectionExpression(expr) {
    if (!expr) {
        return undefined;
    }
    if (expr === 'asc' || expr === 'desc') {
        return RawNode.createWithSql(expr);
    }
    return expr.toOperationNode();
}

/// <reference types="./json-reference-node.d.ts" />
/**
 * @internal
 */
const JSONReferenceNode = freeze({
    is(node) {
        return node.kind === 'JSONReferenceNode';
    },
    create(reference, traversal) {
        return freeze({
            kind: 'JSONReferenceNode',
            reference,
            traversal,
        });
    },
    cloneWithTraversal(node, traversal) {
        return freeze({
            ...node,
            traversal,
        });
    },
});

/// <reference types="./json-operator-chain-node.d.ts" />
/**
 * @internal
 */
const JSONOperatorChainNode = freeze({
    is(node) {
        return node.kind === 'JSONOperatorChainNode';
    },
    create(operator) {
        return freeze({
            kind: 'JSONOperatorChainNode',
            operator,
            values: freeze([]),
        });
    },
    cloneWithValue(node, value) {
        return freeze({
            ...node,
            values: freeze([...node.values, value]),
        });
    },
});

/// <reference types="./json-path-node.d.ts" />
/**
 * @internal
 */
const JSONPathNode = freeze({
    is(node) {
        return node.kind === 'JSONPathNode';
    },
    create(inOperator) {
        return freeze({
            kind: 'JSONPathNode',
            inOperator,
            pathLegs: freeze([]),
        });
    },
    cloneWithLeg(jsonPathNode, pathLeg) {
        return freeze({
            ...jsonPathNode,
            pathLegs: freeze([...jsonPathNode.pathLegs, pathLeg]),
        });
    },
});

/// <reference types="./reference-parser.d.ts" />
function parseSimpleReferenceExpression(exp) {
    if (isString(exp)) {
        return parseStringReference(exp);
    }
    return exp.toOperationNode();
}
function parseReferenceExpressionOrList(arg) {
    if (isReadonlyArray(arg)) {
        return arg.map((it) => parseReferenceExpression(it));
    }
    else {
        return [parseReferenceExpression(arg)];
    }
}
function parseReferenceExpression(exp) {
    if (isExpressionOrFactory(exp)) {
        return parseExpression(exp);
    }
    return parseSimpleReferenceExpression(exp);
}
function parseJSONReference(ref, op) {
    const referenceNode = parseStringReference(ref);
    if (isJSONOperator(op)) {
        return JSONReferenceNode.create(referenceNode, JSONOperatorChainNode.create(OperatorNode.create(op)));
    }
    const opWithoutLastChar = op.slice(0, -1);
    if (isJSONOperator(opWithoutLastChar)) {
        return JSONReferenceNode.create(referenceNode, JSONPathNode.create(OperatorNode.create(opWithoutLastChar)));
    }
    throw new Error(`Invalid JSON operator: ${op}`);
}
function parseStringReference(ref) {
    const COLUMN_SEPARATOR = '.';
    if (!ref.includes(COLUMN_SEPARATOR)) {
        return ReferenceNode.create(ColumnNode.create(ref));
    }
    const parts = ref.split(COLUMN_SEPARATOR).map(trim$2);
    if (parts.length === 3) {
        return parseStringReferenceWithTableAndSchema(parts);
    }
    if (parts.length === 2) {
        return parseStringReferenceWithTable(parts);
    }
    throw new Error(`invalid column reference ${ref}`);
}
function parseAliasedStringReference(ref) {
    const ALIAS_SEPARATOR = ' as ';
    if (ref.includes(ALIAS_SEPARATOR)) {
        const [columnRef, alias] = ref.split(ALIAS_SEPARATOR).map(trim$2);
        return AliasNode.create(parseStringReference(columnRef), IdentifierNode.create(alias));
    }
    else {
        return parseStringReference(ref);
    }
}
function parseColumnName(column) {
    return ColumnNode.create(column);
}
function parseOrderedColumnName(column) {
    const ORDER_SEPARATOR = ' ';
    if (column.includes(ORDER_SEPARATOR)) {
        const [columnName, order] = column.split(ORDER_SEPARATOR).map(trim$2);
        if (!isOrderByDirection(order)) {
            throw new Error(`invalid order direction "${order}" next to "${columnName}"`);
        }
        return parseOrderBy([columnName, order])[0];
    }
    else {
        return parseColumnName(column);
    }
}
function parseStringReferenceWithTableAndSchema(parts) {
    const [schema, table, column] = parts;
    return ReferenceNode.create(ColumnNode.create(column), TableNode.createWithSchema(schema, table));
}
function parseStringReferenceWithTable(parts) {
    const [table, column] = parts;
    return ReferenceNode.create(ColumnNode.create(column), TableNode.create(table));
}
function trim$2(str) {
    return str.trim();
}

/// <reference types="./primitive-value-list-node.d.ts" />
/**
 * @internal
 */
const PrimitiveValueListNode = freeze({
    is(node) {
        return node.kind === 'PrimitiveValueListNode';
    },
    create(values) {
        return freeze({
            kind: 'PrimitiveValueListNode',
            values: freeze([...values]),
        });
    },
});

/// <reference types="./value-list-node.d.ts" />
/**
 * @internal
 */
const ValueListNode = freeze({
    is(node) {
        return node.kind === 'ValueListNode';
    },
    create(values) {
        return freeze({
            kind: 'ValueListNode',
            values: freeze(values),
        });
    },
});

/// <reference types="./value-node.d.ts" />
/**
 * @internal
 */
const ValueNode = freeze({
    is(node) {
        return node.kind === 'ValueNode';
    },
    create(value) {
        return freeze({
            kind: 'ValueNode',
            value,
        });
    },
    createImmediate(value) {
        return freeze({
            kind: 'ValueNode',
            value,
            immediate: true,
        });
    },
});

/// <reference types="./value-parser.d.ts" />
function parseValueExpressionOrList(arg) {
    if (isReadonlyArray(arg)) {
        return parseValueExpressionList(arg);
    }
    return parseValueExpression(arg);
}
function parseValueExpression(exp) {
    if (isExpressionOrFactory(exp)) {
        return parseExpression(exp);
    }
    return ValueNode.create(exp);
}
function isSafeImmediateValue(value) {
    return isNumber(value) || isBoolean(value) || isNull(value);
}
function parseSafeImmediateValue(value) {
    if (!isSafeImmediateValue(value)) {
        throw new Error(`unsafe immediate value ${JSON.stringify(value)}`);
    }
    return ValueNode.createImmediate(value);
}
function parseValueExpressionList(arg) {
    if (arg.some(isExpressionOrFactory)) {
        return ValueListNode.create(arg.map((it) => parseValueExpression(it)));
    }
    return PrimitiveValueListNode.create(arg);
}

/// <reference types="./parens-node.d.ts" />
/**
 * @internal
 */
const ParensNode = freeze({
    is(node) {
        return node.kind === 'ParensNode';
    },
    create(node) {
        return freeze({
            kind: 'ParensNode',
            node,
        });
    },
});

/// <reference types="./binary-operation-parser.d.ts" />
function parseValueBinaryOperationOrExpression(args) {
    if (args.length === 3) {
        return parseValueBinaryOperation(args[0], args[1], args[2]);
    }
    else if (args.length === 1) {
        return parseValueExpression(args[0]);
    }
    throw new Error(`invalid arguments: ${JSON.stringify(args)}`);
}
function parseValueBinaryOperation(left, operator, right) {
    if (isIsOperator(operator) && needsIsOperator(right)) {
        return BinaryOperationNode.create(parseReferenceExpression(left), parseOperator(operator), ValueNode.createImmediate(right));
    }
    return BinaryOperationNode.create(parseReferenceExpression(left), parseOperator(operator), parseValueExpressionOrList(right));
}
function parseReferentialBinaryOperation(left, operator, right) {
    return BinaryOperationNode.create(parseReferenceExpression(left), parseOperator(operator), parseReferenceExpression(right));
}
function parseFilterObject(obj, combinator) {
    return parseFilterList(Object.entries(obj)
        .filter(([, v]) => !isUndefined(v))
        .map(([k, v]) => parseValueBinaryOperation(k, needsIsOperator(v) ? 'is' : '=', v)), combinator);
}
function parseFilterList(list, combinator, withParens = true) {
    const combine = combinator === 'and' ? AndNode.create : OrNode.create;
    if (list.length === 0) {
        return BinaryOperationNode.create(ValueNode.createImmediate(1), OperatorNode.create('='), ValueNode.createImmediate(combinator === 'and' ? 1 : 0));
    }
    let node = toOperationNode(list[0]);
    for (let i = 1; i < list.length; ++i) {
        node = combine(node, toOperationNode(list[i]));
    }
    if (list.length > 1 && withParens) {
        return ParensNode.create(node);
    }
    return node;
}
function isIsOperator(operator) {
    return operator === 'is' || operator === 'is not';
}
function needsIsOperator(value) {
    return isNull(value) || isBoolean(value);
}
function parseOperator(operator) {
    if (isString(operator) && OPERATORS.includes(operator)) {
        return OperatorNode.create(operator);
    }
    if (isOperationNodeSource(operator)) {
        return operator.toOperationNode();
    }
    throw new Error(`invalid operator ${JSON.stringify(operator)}`);
}
function toOperationNode(nodeOrSource) {
    return isOperationNodeSource(nodeOrSource)
        ? nodeOrSource.toOperationNode()
        : nodeOrSource;
}

/// <reference types="./order-by-node.d.ts" />
/**
 * @internal
 */
const OrderByNode = freeze({
    is(node) {
        return node.kind === 'OrderByNode';
    },
    create(items) {
        return freeze({
            kind: 'OrderByNode',
            items: freeze([...items]),
        });
    },
    cloneWithItems(orderBy, items) {
        return freeze({
            ...orderBy,
            items: freeze([...orderBy.items, ...items]),
        });
    },
});

/// <reference types="./partition-by-node.d.ts" />
/**
 * @internal
 */
const PartitionByNode = freeze({
    is(node) {
        return node.kind === 'PartitionByNode';
    },
    create(items) {
        return freeze({
            kind: 'PartitionByNode',
            items: freeze(items),
        });
    },
    cloneWithItems(partitionBy, items) {
        return freeze({
            ...partitionBy,
            items: freeze([...partitionBy.items, ...items]),
        });
    },
});

/// <reference types="./over-node.d.ts" />
/**
 * @internal
 */
const OverNode = freeze({
    is(node) {
        return node.kind === 'OverNode';
    },
    create() {
        return freeze({
            kind: 'OverNode',
        });
    },
    cloneWithOrderByItems(overNode, items) {
        return freeze({
            ...overNode,
            orderBy: overNode.orderBy
                ? OrderByNode.cloneWithItems(overNode.orderBy, items)
                : OrderByNode.create(items),
        });
    },
    cloneWithPartitionByItems(overNode, items) {
        return freeze({
            ...overNode,
            partitionBy: overNode.partitionBy
                ? PartitionByNode.cloneWithItems(overNode.partitionBy, items)
                : PartitionByNode.create(items),
        });
    },
});

/// <reference types="./from-node.d.ts" />
/**
 * @internal
 */
const FromNode = freeze({
    is(node) {
        return node.kind === 'FromNode';
    },
    create(froms) {
        return freeze({
            kind: 'FromNode',
            froms: freeze(froms),
        });
    },
    cloneWithFroms(from, froms) {
        return freeze({
            ...from,
            froms: freeze([...from.froms, ...froms]),
        });
    },
});

/// <reference types="./group-by-node.d.ts" />
/**
 * @internal
 */
const GroupByNode = freeze({
    is(node) {
        return node.kind === 'GroupByNode';
    },
    create(items) {
        return freeze({
            kind: 'GroupByNode',
            items: freeze(items),
        });
    },
    cloneWithItems(groupBy, items) {
        return freeze({
            ...groupBy,
            items: freeze([...groupBy.items, ...items]),
        });
    },
});

/// <reference types="./having-node.d.ts" />
/**
 * @internal
 */
const HavingNode = freeze({
    is(node) {
        return node.kind === 'HavingNode';
    },
    create(filter) {
        return freeze({
            kind: 'HavingNode',
            having: filter,
        });
    },
    cloneWithOperation(havingNode, operator, operation) {
        return freeze({
            ...havingNode,
            having: operator === 'And'
                ? AndNode.create(havingNode.having, operation)
                : OrNode.create(havingNode.having, operation),
        });
    },
});

/// <reference types="./select-query-node.d.ts" />
/**
 * @internal
 */
const SelectQueryNode = freeze({
    is(node) {
        return node.kind === 'SelectQueryNode';
    },
    create(withNode) {
        return freeze({
            kind: 'SelectQueryNode',
            ...(withNode && { with: withNode }),
        });
    },
    createFrom(fromItems, withNode) {
        return freeze({
            kind: 'SelectQueryNode',
            from: FromNode.create(fromItems),
            ...(withNode && { with: withNode }),
        });
    },
    cloneWithSelections(select, selections) {
        return freeze({
            ...select,
            selections: select.selections
                ? freeze([...select.selections, ...selections])
                : freeze(selections),
        });
    },
    cloneWithDistinctOn(select, expressions) {
        return freeze({
            ...select,
            distinctOn: select.distinctOn
                ? freeze([...select.distinctOn, ...expressions])
                : freeze(expressions),
        });
    },
    cloneWithFrontModifier(select, modifier) {
        return freeze({
            ...select,
            frontModifiers: select.frontModifiers
                ? freeze([...select.frontModifiers, modifier])
                : freeze([modifier]),
        });
    },
    cloneWithEndModifier(select, modifier) {
        return freeze({
            ...select,
            endModifiers: select.endModifiers
                ? freeze([...select.endModifiers, modifier])
                : freeze([modifier]),
        });
    },
    cloneWithOrderByItems(selectNode, items) {
        return freeze({
            ...selectNode,
            orderBy: selectNode.orderBy
                ? OrderByNode.cloneWithItems(selectNode.orderBy, items)
                : OrderByNode.create(items),
        });
    },
    cloneWithGroupByItems(selectNode, items) {
        return freeze({
            ...selectNode,
            groupBy: selectNode.groupBy
                ? GroupByNode.cloneWithItems(selectNode.groupBy, items)
                : GroupByNode.create(items),
        });
    },
    cloneWithLimit(selectNode, limit) {
        return freeze({
            ...selectNode,
            limit,
        });
    },
    cloneWithOffset(selectNode, offset) {
        return freeze({
            ...selectNode,
            offset,
        });
    },
    cloneWithFetch(selectNode, fetch) {
        return freeze({
            ...selectNode,
            fetch,
        });
    },
    cloneWithHaving(selectNode, operation) {
        return freeze({
            ...selectNode,
            having: selectNode.having
                ? HavingNode.cloneWithOperation(selectNode.having, 'And', operation)
                : HavingNode.create(operation),
        });
    },
    cloneWithSetOperations(selectNode, setOperations) {
        return freeze({
            ...selectNode,
            setOperations: selectNode.setOperations
                ? freeze([...selectNode.setOperations, ...setOperations])
                : freeze([...setOperations]),
        });
    },
    cloneWithoutSelections(select) {
        return freeze({
            ...select,
            selections: [],
        });
    },
    cloneWithoutLimit(select) {
        return freeze({
            ...select,
            limit: undefined,
        });
    },
    cloneWithoutOffset(select) {
        return freeze({
            ...select,
            offset: undefined,
        });
    },
    cloneWithoutOrderBy(select) {
        return freeze({
            ...select,
            orderBy: undefined,
        });
    },
    cloneWithoutGroupBy(select) {
        return freeze({
            ...select,
            groupBy: undefined,
        });
    },
});

/// <reference types="./prevent-await.d.ts" />
function preventAwait(clazz, message) {
    Object.defineProperties(clazz.prototype, {
        then: {
            enumerable: false,
            value: () => {
                throw new Error(message);
            },
        },
    });
}

/// <reference types="./join-builder.d.ts" />
class JoinBuilder {
    #props;
    constructor(props) {
        this.#props = freeze(props);
    }
    on(...args) {
        return new JoinBuilder({
            ...this.#props,
            joinNode: JoinNode.cloneWithOn(this.#props.joinNode, parseValueBinaryOperationOrExpression(args)),
        });
    }
    /**
     * Just like {@link WhereInterface.whereRef} but adds an item to the join's
     * `on` clause instead.
     *
     * See {@link WhereInterface.whereRef} for documentation and examples.
     */
    onRef(lhs, op, rhs) {
        return new JoinBuilder({
            ...this.#props,
            joinNode: JoinNode.cloneWithOn(this.#props.joinNode, parseReferentialBinaryOperation(lhs, op, rhs)),
        });
    }
    /**
     * Adds `on true`.
     */
    onTrue() {
        return new JoinBuilder({
            ...this.#props,
            joinNode: JoinNode.cloneWithOn(this.#props.joinNode, RawNode.createWithSql('true')),
        });
    }
    /**
     * Simply calls the provided function passing `this` as the only argument. `$call` returns
     * what the provided function returns.
     */
    $call(func) {
        return func(this);
    }
    toOperationNode() {
        return this.#props.joinNode;
    }
}
preventAwait(JoinBuilder, "don't await JoinBuilder instances. They are never executed directly and are always just a part of a query.");

/// <reference types="./partition-by-item-node.d.ts" />
/**
 * @internal
 */
const PartitionByItemNode = freeze({
    is(node) {
        return node.kind === 'PartitionByItemNode';
    },
    create(partitionBy) {
        return freeze({
            kind: 'PartitionByItemNode',
            partitionBy,
        });
    },
});

/// <reference types="./partition-by-parser.d.ts" />
function parsePartitionBy(partitionBy) {
    return parseReferenceExpressionOrList(partitionBy).map(PartitionByItemNode.create);
}

/// <reference types="./over-builder.d.ts" />
class OverBuilder {
    #props;
    constructor(props) {
        this.#props = freeze(props);
    }
    /**
     * Adds an order by clause item inside the over function.
     *
     * ```ts
     * const result = await db
     *   .selectFrom('person')
     *   .select(
     *     (eb) => eb.fn.avg<number>('age').over(
     *       ob => ob.orderBy('first_name', 'asc').orderBy('last_name', 'asc')
     *     ).as('average_age')
     *   )
     *   .execute()
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * select avg("age") over(order by "first_name" asc, "last_name" asc) as "average_age"
     * from "person"
     * ```
     */
    orderBy(orderBy, direction) {
        return new OverBuilder({
            overNode: OverNode.cloneWithOrderByItems(this.#props.overNode, parseOrderBy([orderBy, direction])),
        });
    }
    partitionBy(partitionBy) {
        return new OverBuilder({
            overNode: OverNode.cloneWithPartitionByItems(this.#props.overNode, parsePartitionBy(partitionBy)),
        });
    }
    /**
     * Simply calls the provided function passing `this` as the only argument. `$call` returns
     * what the provided function returns.
     */
    $call(func) {
        return func(this);
    }
    toOperationNode() {
        return this.#props.overNode;
    }
}
preventAwait(OverBuilder, "don't await OverBuilder instances. They are never executed directly and are always just a part of a query.");

/// <reference types="./selection-node.d.ts" />
/**
 * @internal
 */
const SelectionNode = freeze({
    is(node) {
        return node.kind === 'SelectionNode';
    },
    create(selection) {
        return freeze({
            kind: 'SelectionNode',
            selection: selection,
        });
    },
    createSelectAll() {
        return freeze({
            kind: 'SelectionNode',
            selection: SelectAllNode.create(),
        });
    },
    createSelectAllFromTable(table) {
        return freeze({
            kind: 'SelectionNode',
            selection: ReferenceNode.createSelectAll(table),
        });
    },
});

/// <reference types="./select-parser.d.ts" />
function parseSelectArg(selection) {
    if (isFunction(selection)) {
        return parseSelectArg(selection(expressionBuilder()));
    }
    else if (isReadonlyArray(selection)) {
        return selection.map((it) => parseSelectExpression(it));
    }
    else {
        return [parseSelectExpression(selection)];
    }
}
function parseSelectExpression(selection) {
    if (isString(selection)) {
        return SelectionNode.create(parseAliasedStringReference(selection));
    }
    else if (isDynamicReferenceBuilder(selection)) {
        return SelectionNode.create(selection.toOperationNode());
    }
    else {
        return SelectionNode.create(parseAliasedExpression(selection));
    }
}
function parseSelectAll(table) {
    if (!table) {
        return [SelectionNode.createSelectAll()];
    }
    else if (Array.isArray(table)) {
        return table.map(parseSelectAllArg);
    }
    else {
        return [parseSelectAllArg(table)];
    }
}
function parseSelectAllArg(table) {
    if (isString(table)) {
        return SelectionNode.createSelectAllFromTable(parseTable(table));
    }
    throw new Error(`invalid value selectAll expression: ${JSON.stringify(table)}`);
}

/// <reference types="./values-node.d.ts" />
/**
 * @internal
 */
const ValuesNode = freeze({
    is(node) {
        return node.kind === 'ValuesNode';
    },
    create(values) {
        return freeze({
            kind: 'ValuesNode',
            values: freeze(values),
        });
    },
});

/// <reference types="./default-insert-value-node.d.ts" />
/**
 * @internal
 */
const DefaultInsertValueNode = freeze({
    is(node) {
        return node.kind === 'DefaultInsertValueNode';
    },
    create() {
        return freeze({
            kind: 'DefaultInsertValueNode',
        });
    },
});

/// <reference types="./insert-values-parser.d.ts" />
function parseInsertExpression(arg) {
    const objectOrList = isFunction(arg) ? arg(expressionBuilder()) : arg;
    const list = isReadonlyArray(objectOrList)
        ? objectOrList
        : freeze([objectOrList]);
    return parseInsertColumnsAndValues(list);
}
function parseInsertColumnsAndValues(rows) {
    const columns = parseColumnNamesAndIndexes(rows);
    return [
        freeze([...columns.keys()].map(ColumnNode.create)),
        ValuesNode.create(rows.map((row) => parseRowValues(row, columns))),
    ];
}
function parseColumnNamesAndIndexes(rows) {
    const columns = new Map();
    for (const row of rows) {
        const cols = Object.keys(row);
        for (const col of cols) {
            if (!columns.has(col) && row[col] !== undefined) {
                columns.set(col, columns.size);
            }
        }
    }
    return columns;
}
function parseRowValues(row, columns) {
    const rowColumns = Object.keys(row);
    const rowValues = Array.from({
        length: columns.size,
    });
    let hasUndefinedOrComplexColumns = false;
    for (const col of rowColumns) {
        const columnIdx = columns.get(col);
        if (isUndefined(columnIdx)) {
            continue;
        }
        const value = row[col];
        if (isUndefined(value) || isExpressionOrFactory(value)) {
            hasUndefinedOrComplexColumns = true;
        }
        rowValues[columnIdx] = value;
    }
    const hasMissingColumns = rowColumns.length < columns.size;
    if (hasMissingColumns || hasUndefinedOrComplexColumns) {
        const defaultValue = DefaultInsertValueNode.create();
        return ValueListNode.create(rowValues.map((it) => isUndefined(it) ? defaultValue : parseValueExpression(it)));
    }
    return PrimitiveValueListNode.create(rowValues);
}

/// <reference types="./insert-query-node.d.ts" />
/**
 * @internal
 */
const InsertQueryNode = freeze({
    is(node) {
        return node.kind === 'InsertQueryNode';
    },
    create(into, withNode, replace) {
        return freeze({
            kind: 'InsertQueryNode',
            into,
            ...(withNode && { with: withNode }),
            replace,
        });
    },
    createWithoutInto() {
        return freeze({
            kind: 'InsertQueryNode',
        });
    },
    cloneWith(insertQuery, props) {
        return freeze({
            ...insertQuery,
            ...props,
        });
    },
});

/// <reference types="./update-query-node.d.ts" />
/**
 * @internal
 */
const UpdateQueryNode = freeze({
    is(node) {
        return node.kind === 'UpdateQueryNode';
    },
    create(table, withNode) {
        return freeze({
            kind: 'UpdateQueryNode',
            table,
            ...(withNode && { with: withNode }),
        });
    },
    createWithoutTable() {
        return freeze({
            kind: 'UpdateQueryNode',
        });
    },
    cloneWithFromItems(updateQuery, fromItems) {
        return freeze({
            ...updateQuery,
            from: updateQuery.from
                ? FromNode.cloneWithFroms(updateQuery.from, fromItems)
                : FromNode.create(fromItems),
        });
    },
    cloneWithUpdates(updateQuery, updates) {
        return freeze({
            ...updateQuery,
            updates: updateQuery.updates
                ? freeze([...updateQuery.updates, ...updates])
                : updates,
        });
    },
    cloneWithLimit(updateQuery, limit) {
        return freeze({
            ...updateQuery,
            limit,
        });
    },
});

/// <reference types="./using-node.d.ts" />
/**
 * @internal
 */
const UsingNode = freeze({
    is(node) {
        return node.kind === 'UsingNode';
    },
    create(tables) {
        return freeze({
            kind: 'UsingNode',
            tables: freeze(tables),
        });
    },
    cloneWithTables(using, tables) {
        return freeze({
            ...using,
            tables: freeze([...using.tables, ...tables]),
        });
    },
});

/// <reference types="./delete-query-node.d.ts" />
/**
 * @internal
 */
const DeleteQueryNode = freeze({
    is(node) {
        return node.kind === 'DeleteQueryNode';
    },
    create(fromItems, withNode) {
        return freeze({
            kind: 'DeleteQueryNode',
            from: FromNode.create(fromItems),
            ...(withNode && { with: withNode }),
        });
    },
    cloneWithOrderByItems(deleteNode, items) {
        return freeze({
            ...deleteNode,
            orderBy: deleteNode.orderBy
                ? OrderByNode.cloneWithItems(deleteNode.orderBy, items)
                : OrderByNode.create(items),
        });
    },
    cloneWithoutOrderBy(deleteNode) {
        return freeze({
            ...deleteNode,
            orderBy: undefined,
        });
    },
    cloneWithLimit(deleteNode, limit) {
        return freeze({
            ...deleteNode,
            limit,
        });
    },
    cloneWithoutLimit(deleteNode) {
        return freeze({
            ...deleteNode,
            limit: undefined,
        });
    },
    cloneWithUsing(deleteNode, tables) {
        return freeze({
            ...deleteNode,
            using: deleteNode.using !== undefined
                ? UsingNode.cloneWithTables(deleteNode.using, tables)
                : UsingNode.create(tables),
        });
    },
});

/// <reference types="./where-node.d.ts" />
/**
 * @internal
 */
const WhereNode = freeze({
    is(node) {
        return node.kind === 'WhereNode';
    },
    create(filter) {
        return freeze({
            kind: 'WhereNode',
            where: filter,
        });
    },
    cloneWithOperation(whereNode, operator, operation) {
        return freeze({
            ...whereNode,
            where: operator === 'And'
                ? AndNode.create(whereNode.where, operation)
                : OrNode.create(whereNode.where, operation),
        });
    },
});

/// <reference types="./returning-node.d.ts" />
/**
 * @internal
 */
const ReturningNode = freeze({
    is(node) {
        return node.kind === 'ReturningNode';
    },
    create(selections) {
        return freeze({
            kind: 'ReturningNode',
            selections: freeze(selections),
        });
    },
    cloneWithSelections(returning, selections) {
        return freeze({
            ...returning,
            selections: returning.selections
                ? freeze([...returning.selections, ...selections])
                : freeze(selections),
        });
    },
});

/// <reference types="./explain-node.d.ts" />
/**
 * @internal
 */
const ExplainNode = freeze({
    is(node) {
        return node.kind === 'ExplainNode';
    },
    create(format, options) {
        return freeze({
            kind: 'ExplainNode',
            format,
            options,
        });
    },
});

/// <reference types="./when-node.d.ts" />
/**
 * @internal
 */
const WhenNode = freeze({
    is(node) {
        return node.kind === 'WhenNode';
    },
    create(condition) {
        return freeze({
            kind: 'WhenNode',
            condition,
        });
    },
    cloneWithResult(whenNode, result) {
        return freeze({
            ...whenNode,
            result,
        });
    },
});

/// <reference types="./merge-query-node.d.ts" />
/**
 * @internal
 */
const MergeQueryNode = freeze({
    is(node) {
        return node.kind === 'MergeQueryNode';
    },
    create(into, withNode) {
        return freeze({
            kind: 'MergeQueryNode',
            into,
            ...(withNode && { with: withNode }),
        });
    },
    cloneWithUsing(mergeNode, using) {
        return freeze({
            ...mergeNode,
            using,
        });
    },
    cloneWithWhen(mergeNode, when) {
        return freeze({
            ...mergeNode,
            whens: mergeNode.whens
                ? freeze([...mergeNode.whens, when])
                : freeze([when]),
        });
    },
    cloneWithThen(mergeNode, then) {
        return freeze({
            ...mergeNode,
            whens: mergeNode.whens
                ? freeze([
                    ...mergeNode.whens.slice(0, -1),
                    WhenNode.cloneWithResult(mergeNode.whens[mergeNode.whens.length - 1], then),
                ])
                : undefined,
        });
    },
});

/// <reference types="./output-node.d.ts" />
/**
 * @internal
 */
const OutputNode = freeze({
    is(node) {
        return node.kind === 'OutputNode';
    },
    create(selections) {
        return freeze({
            kind: 'OutputNode',
            selections: freeze(selections),
        });
    },
    cloneWithSelections(output, selections) {
        return freeze({
            ...output,
            selections: output.selections
                ? freeze([...output.selections, ...selections])
                : freeze(selections),
        });
    },
});

/// <reference types="./query-node.d.ts" />
/**
 * @internal
 */
const QueryNode = freeze({
    is(node) {
        return (SelectQueryNode.is(node) ||
            InsertQueryNode.is(node) ||
            UpdateQueryNode.is(node) ||
            DeleteQueryNode.is(node) ||
            MergeQueryNode.is(node));
    },
    cloneWithWhere(node, operation) {
        return freeze({
            ...node,
            where: node.where
                ? WhereNode.cloneWithOperation(node.where, 'And', operation)
                : WhereNode.create(operation),
        });
    },
    cloneWithJoin(node, join) {
        return freeze({
            ...node,
            joins: node.joins ? freeze([...node.joins, join]) : freeze([join]),
        });
    },
    cloneWithReturning(node, selections) {
        return freeze({
            ...node,
            returning: node.returning
                ? ReturningNode.cloneWithSelections(node.returning, selections)
                : ReturningNode.create(selections),
        });
    },
    cloneWithoutReturning(node) {
        return freeze({
            ...node,
            returning: undefined,
        });
    },
    cloneWithoutWhere(node) {
        return freeze({
            ...node,
            where: undefined,
        });
    },
    cloneWithExplain(node, format, options) {
        return freeze({
            ...node,
            explain: ExplainNode.create(format, options?.toOperationNode()),
        });
    },
    cloneWithTop(node, top) {
        return freeze({
            ...node,
            top,
        });
    },
    cloneWithOutput(node, selections) {
        return freeze({
            ...node,
            output: node.output
                ? OutputNode.cloneWithSelections(node.output, selections)
                : OutputNode.create(selections),
        });
    },
});

/// <reference types="./column-update-node.d.ts" />
/**
 * @internal
 */
const ColumnUpdateNode = freeze({
    is(node) {
        return node.kind === 'ColumnUpdateNode';
    },
    create(column, value) {
        return freeze({
            kind: 'ColumnUpdateNode',
            column,
            value,
        });
    },
});

/// <reference types="./update-set-parser.d.ts" />
function parseUpdate(...args) {
    if (args.length === 2) {
        return [
            ColumnUpdateNode.create(parseReferenceExpression(args[0]), parseValueExpression(args[1])),
        ];
    }
    return parseUpdateObjectExpression(args[0]);
}
function parseUpdateObjectExpression(update) {
    const updateObj = isFunction(update) ? update(expressionBuilder()) : update;
    return Object.entries(updateObj)
        .filter(([_, value]) => value !== undefined)
        .map(([key, value]) => {
        return ColumnUpdateNode.create(ColumnNode.create(key), parseValueExpression(value));
    });
}

/// <reference types="./on-duplicate-key-node.d.ts" />
/**
 * @internal
 */
const OnDuplicateKeyNode = freeze({
    is(node) {
        return node.kind === 'OnDuplicateKeyNode';
    },
    create(updates) {
        return freeze({
            kind: 'OnDuplicateKeyNode',
            updates,
        });
    },
});

/// <reference types="./insert-result.d.ts" />
/**
 * The result of an insert query.
 *
 * If the table has an auto incrementing primary key {@link insertId} will hold
 * the generated id on dialects that support it. For example PostgreSQL doesn't
 * return the id by default and {@link insertId} is undefined. On PostgreSQL you
 * need to use {@link ReturningInterface.returning} or {@link ReturningInterface.returningAll}
 * to get out the inserted id.
 *
 * {@link numInsertedOrUpdatedRows} holds the number of (actually) inserted rows.
 * On MySQL, updated rows are counted twice when using `on duplicate key update`.
 *
 * ### Examples
 *
 * ```ts
 * const result = await db
 *   .insertInto('person')
 *   .values(person)
 *   .executeTakeFirst()
 *
 * console.log(result.insertId)
 * ```
 */
class InsertResult {
    /**
     * The auto incrementing primary key of the inserted row.
     *
     * This property can be undefined when the query contains an `on conflict`
     * clause that makes the query succeed even when nothing gets inserted.
     *
     * This property is always undefined on dialects like PostgreSQL that
     * don't return the inserted id by default. On those dialects you need
     * to use the {@link ReturningInterface.returning | returning} method.
     */
    insertId;
    /**
     * Affected rows count.
     */
    numInsertedOrUpdatedRows;
    constructor(insertId, numInsertedOrUpdatedRows) {
        this.insertId = insertId;
        this.numInsertedOrUpdatedRows = numInsertedOrUpdatedRows;
    }
}

/// <reference types="./no-result-error.d.ts" />
class NoResultError extends Error {
    /**
     * The operation node tree of the query that was executed.
     */
    node;
    constructor(node) {
        super('no result');
        this.node = node;
    }
}
function isNoResultErrorConstructor(fn) {
    return Object.prototype.hasOwnProperty.call(fn, 'prototype');
}

/// <reference types="./on-conflict-node.d.ts" />
/**
 * @internal
 */
const OnConflictNode = freeze({
    is(node) {
        return node.kind === 'OnConflictNode';
    },
    create() {
        return freeze({
            kind: 'OnConflictNode',
        });
    },
    cloneWith(node, props) {
        return freeze({
            ...node,
            ...props,
        });
    },
    cloneWithIndexWhere(node, operation) {
        return freeze({
            ...node,
            indexWhere: node.indexWhere
                ? WhereNode.cloneWithOperation(node.indexWhere, 'And', operation)
                : WhereNode.create(operation),
        });
    },
    cloneWithIndexOrWhere(node, operation) {
        return freeze({
            ...node,
            indexWhere: node.indexWhere
                ? WhereNode.cloneWithOperation(node.indexWhere, 'Or', operation)
                : WhereNode.create(operation),
        });
    },
    cloneWithUpdateWhere(node, operation) {
        return freeze({
            ...node,
            updateWhere: node.updateWhere
                ? WhereNode.cloneWithOperation(node.updateWhere, 'And', operation)
                : WhereNode.create(operation),
        });
    },
    cloneWithUpdateOrWhere(node, operation) {
        return freeze({
            ...node,
            updateWhere: node.updateWhere
                ? WhereNode.cloneWithOperation(node.updateWhere, 'Or', operation)
                : WhereNode.create(operation),
        });
    },
    cloneWithoutIndexWhere(node) {
        return freeze({
            ...node,
            indexWhere: undefined,
        });
    },
    cloneWithoutUpdateWhere(node) {
        return freeze({
            ...node,
            updateWhere: undefined,
        });
    },
});

/// <reference types="./on-conflict-builder.d.ts" />
class OnConflictBuilder {
    #props;
    constructor(props) {
        this.#props = freeze(props);
    }
    /**
     * Specify a single column as the conflict target.
     *
     * Also see the {@link columns}, {@link constraint} and {@link expression}
     * methods for alternative ways to specify the conflict target.
     */
    column(column) {
        const columnNode = ColumnNode.create(column);
        return new OnConflictBuilder({
            ...this.#props,
            onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {
                columns: this.#props.onConflictNode.columns
                    ? freeze([...this.#props.onConflictNode.columns, columnNode])
                    : freeze([columnNode]),
            }),
        });
    }
    /**
     * Specify a list of columns as the conflict target.
     *
     * Also see the {@link column}, {@link constraint} and {@link expression}
     * methods for alternative ways to specify the conflict target.
     */
    columns(columns) {
        const columnNodes = columns.map(ColumnNode.create);
        return new OnConflictBuilder({
            ...this.#props,
            onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {
                columns: this.#props.onConflictNode.columns
                    ? freeze([...this.#props.onConflictNode.columns, ...columnNodes])
                    : freeze(columnNodes),
            }),
        });
    }
    /**
     * Specify a specific constraint by name as the conflict target.
     *
     * Also see the {@link column}, {@link columns} and {@link expression}
     * methods for alternative ways to specify the conflict target.
     */
    constraint(constraintName) {
        return new OnConflictBuilder({
            ...this.#props,
            onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {
                constraint: IdentifierNode.create(constraintName),
            }),
        });
    }
    /**
     * Specify an expression as the conflict target.
     *
     * This can be used if the unique index is an expression index.
     *
     * Also see the {@link column}, {@link columns} and {@link constraint}
     * methods for alternative ways to specify the conflict target.
     */
    expression(expression) {
        return new OnConflictBuilder({
            ...this.#props,
            onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {
                indexExpression: expression.toOperationNode(),
            }),
        });
    }
    where(...args) {
        return new OnConflictBuilder({
            ...this.#props,
            onConflictNode: OnConflictNode.cloneWithIndexWhere(this.#props.onConflictNode, parseValueBinaryOperationOrExpression(args)),
        });
    }
    whereRef(lhs, op, rhs) {
        return new OnConflictBuilder({
            ...this.#props,
            onConflictNode: OnConflictNode.cloneWithIndexWhere(this.#props.onConflictNode, parseReferentialBinaryOperation(lhs, op, rhs)),
        });
    }
    clearWhere() {
        return new OnConflictBuilder({
            ...this.#props,
            onConflictNode: OnConflictNode.cloneWithoutIndexWhere(this.#props.onConflictNode),
        });
    }
    /**
     * Adds the "do nothing" conflict action.
     *
     * ### Examples
     *
     * ```ts
     * await db
     *   .insertInto('person')
     *   .values({first_name, pic })
     *   .onConflict((oc) => oc
     *     .column('pic')
     *     .doNothing()
     *   )
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * insert into "person" ("first_name", "pic")
     * values ($1, $2)
     * on conflict ("pic") do nothing
     * ```
     */
    doNothing() {
        return new OnConflictDoNothingBuilder({
            ...this.#props,
            onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {
                doNothing: true,
            }),
        });
    }
    /**
     * Adds the "do update set" conflict action.
     *
     * ### Examples
     *
     * ```ts
     * await db
     *   .insertInto('person')
     *   .values({first_name, pic })
     *   .onConflict((oc) => oc
     *     .column('pic')
     *     .doUpdateSet({ first_name })
     *   )
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * insert into "person" ("first_name", "pic")
     * values ($1, $2)
     * on conflict ("pic")
     * do update set "first_name" = $3
     * ```
     *
     * In the next example we use the `ref` method to reference
     * columns of the virtual table `excluded` in a type-safe way
     * to create an upsert operation:
     *
     * ```ts
     * db.insertInto('person')
     *   .values(person)
     *   .onConflict((oc) => oc
     *     .column('id')
     *     .doUpdateSet((eb) => ({
     *       first_name: eb.ref('excluded.first_name'),
     *       last_name: eb.ref('excluded.last_name')
     *     }))
     *   )
     * ```
     */
    doUpdateSet(update) {
        return new OnConflictUpdateBuilder({
            ...this.#props,
            onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {
                updates: parseUpdateObjectExpression(update),
            }),
        });
    }
    /**
     * Simply calls the provided function passing `this` as the only argument. `$call` returns
     * what the provided function returns.
     */
    $call(func) {
        return func(this);
    }
}
preventAwait(OnConflictBuilder, "don't await OnConflictBuilder instances.");
class OnConflictDoNothingBuilder {
    #props;
    constructor(props) {
        this.#props = freeze(props);
    }
    toOperationNode() {
        return this.#props.onConflictNode;
    }
}
preventAwait(OnConflictDoNothingBuilder, "don't await OnConflictDoNothingBuilder instances.");
class OnConflictUpdateBuilder {
    #props;
    constructor(props) {
        this.#props = freeze(props);
    }
    where(...args) {
        return new OnConflictUpdateBuilder({
            ...this.#props,
            onConflictNode: OnConflictNode.cloneWithUpdateWhere(this.#props.onConflictNode, parseValueBinaryOperationOrExpression(args)),
        });
    }
    /**
     * Specify a where condition for the update operation.
     *
     * See {@link WhereInterface.whereRef} for more info.
     */
    whereRef(lhs, op, rhs) {
        return new OnConflictUpdateBuilder({
            ...this.#props,
            onConflictNode: OnConflictNode.cloneWithUpdateWhere(this.#props.onConflictNode, parseReferentialBinaryOperation(lhs, op, rhs)),
        });
    }
    clearWhere() {
        return new OnConflictUpdateBuilder({
            ...this.#props,
            onConflictNode: OnConflictNode.cloneWithoutUpdateWhere(this.#props.onConflictNode),
        });
    }
    /**
     * Simply calls the provided function passing `this` as the only argument. `$call` returns
     * what the provided function returns.
     */
    $call(func) {
        return func(this);
    }
    toOperationNode() {
        return this.#props.onConflictNode;
    }
}
preventAwait(OnConflictUpdateBuilder, "don't await OnConflictUpdateBuilder instances.");

/// <reference types="./top-node.d.ts" />
/**
 * @internal
 */
const TopNode = freeze({
    is(node) {
        return node.kind === 'TopNode';
    },
    create(expression, modifiers) {
        return freeze({
            kind: 'TopNode',
            expression,
            modifiers,
        });
    },
});

/// <reference types="./top-parser.d.ts" />
function parseTop(expression, modifiers) {
    if (!isNumber(expression) && !isBigInt(expression)) {
        throw new Error(`Invalid top expression: ${expression}`);
    }
    if (!isUndefined(modifiers) && !isTopModifiers(modifiers)) {
        throw new Error(`Invalid top modifiers: ${modifiers}`);
    }
    return TopNode.create(expression, modifiers);
}
function isTopModifiers(modifiers) {
    return (modifiers === 'percent' ||
        modifiers === 'with ties' ||
        modifiers === 'percent with ties');
}

/// <reference types="./insert-query-builder.d.ts" />
class InsertQueryBuilder {
    #props;
    constructor(props) {
        this.#props = freeze(props);
    }
    /**
     * Sets the values to insert for an {@link Kysely.insertInto | insert} query.
     *
     * This method takes an object whose keys are column names and values are
     * values to insert. In addition to the column's type, the values can be
     * raw {@link sql} snippets or select queries.
     *
     * You must provide all fields you haven't explicitly marked as nullable
     * or optional using {@link Generated} or {@link ColumnType}.
     *
     * The return value of an `insert` query is an instance of {@link InsertResult}. The
     * {@link InsertResult.insertId | insertId} field holds the auto incremented primary
     * key if the database returned one.
     *
     * On PostgreSQL and some other dialects, you need to call `returning` to get
     * something out of the query.
     *
     * Also see the {@link expression} method for inserting the result of a select
     * query or any other expression.
     *
     * ### Examples
     *
     * <!-- siteExample("insert", "Single row", 10) -->
     *
     * Insert a single row:
     *
     * ```ts
     * const result = await db
     *   .insertInto('person')
     *   .values({
     *     first_name: 'Jennifer',
     *     last_name: 'Aniston',
     *     age: 40
     *   })
     *   .executeTakeFirst()
     *
     * // `insertId` is only available on dialects that
     * // automatically return the id of the inserted row
     * // such as MySQL and SQLite. On PostgreSQL, for example,
     * // you need to add a `returning` clause to the query to
     * // get anything out. See the "returning data" example.
     * console.log(result.insertId)
     * ```
     *
     * The generated SQL (MySQL):
     *
     * ```sql
     * insert into `person` (`first_name`, `last_name`, `age`) values (?, ?, ?)
     * ```
     *
     * <!-- siteExample("insert", "Multiple rows", 20) -->
     *
     * On dialects that support it (for example PostgreSQL) you can insert multiple
     * rows by providing an array. Note that the return value is once again very
     * dialect-specific. Some databases may only return the id of the *last* inserted
     * row and some return nothing at all unless you call `returning`.
     *
     * ```ts
     * await db
     *   .insertInto('person')
     *   .values([{
     *     first_name: 'Jennifer',
     *     last_name: 'Aniston',
     *     age: 40,
     *   }, {
     *     first_name: 'Arnold',
     *     last_name: 'Schwarzenegger',
     *     age: 70,
     *   }])
     *   .execute()
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * insert into "person" ("first_name", "last_name", "age") values (($1, $2, $3), ($4, $5, $6))
     * ```
     *
     * <!-- siteExample("insert", "Returning data", 30) -->
     *
     * On supported dialects like PostgreSQL you need to chain `returning` to the query to get
     * the inserted row's columns (or any other expression) as the return value. `returning`
     * works just like `select`. Refer to `select` method's examples and documentation for
     * more info.
     *
     * ```ts
     * const result = await db
     *   .insertInto('person')
     *   .values({
     *     first_name: 'Jennifer',
     *     last_name: 'Aniston',
     *     age: 40,
     *   })
     *   .returning(['id', 'first_name as name'])
     *   .executeTakeFirstOrThrow()
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * insert into "person" ("first_name", "last_name", "age") values ($1, $2, $3) returning "id", "first_name" as "name"
     * ```
     *
     * <!-- siteExample("insert", "Complex values", 40) -->
     *
     * In addition to primitives, the values can also be arbitrary expressions.
     * You can build the expressions by using a callback and calling the methods
     * on the expression builder passed to it:
     *
     * ```ts
     * import { sql } from 'kysely'
     *
     * const ani = "Ani"
     * const ston = "ston"
     *
     * const result = await db
     *   .insertInto('person')
     *   .values(({ ref, selectFrom, fn }) => ({
     *     first_name: 'Jennifer',
     *     last_name: sql<string>`>concat(${ani}, ${ston})`,
     *     middle_name: ref('first_name'),
     *     age: selectFrom('person')
     *       .select(fn.avg<number>('age').as('avg_age')),
     *   }))
     *   .executeTakeFirst()
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * insert into "person" (
     *   "first_name",
     *   "last_name",
     *   "middle_name",
     *   "age"
     * )
     * values (
     *   $1,
     *   concat($2, $3),
     *   "first_name",
     *   (select avg("age") as "avg_age" from "person")
     * )
     * ```
     *
     * You can also use the callback version of subqueries or raw expressions:
     *
     * ```ts
     * db.with('jennifer', (db) => db
     *   .selectFrom('person')
     *   .where('first_name', '=', 'Jennifer')
     *   .select(['id', 'first_name', 'gender'])
     *   .limit(1)
     * ).insertInto('pet').values((eb) => ({
     *   owner_id: eb.selectFrom('jennifer').select('id'),
     *   name: eb.selectFrom('jennifer').select('first_name'),
     *   species: 'cat',
     * }))
     * ```
     */
    values(insert) {
        const [columns, values] = parseInsertExpression(insert);
        return new InsertQueryBuilder({
            ...this.#props,
            queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
                columns,
                values,
            }),
        });
    }
    /**
     * Sets the columns to insert.
     *
     * The {@link values} method sets both the columns and the values and this method
     * is not needed. But if you are using the {@link expression} method, you can use
     * this method to set the columns to insert.
     *
     * ### Examples
     *
     * ```ts
     * db.insertInto('person')
     *   .columns(['first_name'])
     *   .expression((eb) => eb.selectFrom('pet').select('pet.name'))
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * insert into "person" ("first_name")
     * select "pet"."name" from "pet"
     * ```
     */
    columns(columns) {
        return new InsertQueryBuilder({
            ...this.#props,
            queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
                columns: freeze(columns.map(ColumnNode.create)),
            }),
        });
    }
    /**
     * Insert an arbitrary expression. For example the result of a select query.
     *
     * ### Examples
     *
     * <!-- siteExample("insert", "Insert subquery", 50) -->
     *
     * You can create an `INSERT INTO SELECT FROM` query using the `expression` method.
     * This API doesn't follow our WYSIWYG principles and might be a bit difficult to
     * remember. The reasons for this design stem from implementation difficulties.
     *
     * ```ts
     * const result = await db.insertInto('person')
     *   .columns(['first_name', 'last_name', 'age'])
     *   .expression((eb) => eb
     *     .selectFrom('pet')
     *     .select((eb) => [
     *       'pet.name',
     *       eb.val('Petson').as('last_name'),
     *       eb.lit(7).as('age'),
     *     ])
     *   )
     *   .execute()
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * insert into "person" ("first_name", "last_name", "age")
     * select "pet"."name", $1 as "last_name", 7 as "age from "pet"
     * ```
     */
    expression(expression) {
        return new InsertQueryBuilder({
            ...this.#props,
            queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
                values: parseExpression(expression),
            }),
        });
    }
    /**
     * Creates an `insert into "person" default values` query.
     *
     * ### Examples
     *
     * ```ts
     * await db.insertInto('person')
     *   .defaultValues()
     *   .execute()
     * ```
     */
    defaultValues() {
        return new InsertQueryBuilder({
            ...this.#props,
            queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
                defaultValues: true,
            }),
        });
    }
    /**
     * Changes an `insert into` query to an `insert ignore into` query.
     *
     * If you use the ignore modifier, ignorable errors that occur while executing the
     * insert statement are ignored. For example, without ignore, a row that duplicates
     * an existing unique index or primary key value in the table causes a duplicate-key
     * error and the statement is aborted. With ignore, the row is discarded and no error
     * occurs.
     *
     * This is only supported on some dialects like MySQL. On most dialects you should
     * use the {@link onConflict} method.
     *
     * ### Examples
     *
     * ```ts
     * await db.insertInto('person')
     *   .ignore()
     *   .values(values)
     *   .execute()
     * ```
     */
    ignore() {
        return new InsertQueryBuilder({
            ...this.#props,
            queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
                ignore: true,
            }),
        });
    }
    /**
     * Changes an `insert into` query to an `insert top into` query.
     *
     * `top` clause is only supported by some dialects like MS SQL Server.
     *
     * ### Examples
     *
     * Insert the first 5 rows:
     *
     * ```ts
     * await db.insertInto('person')
     *   .top(5)
     *   .columns(['first_name', 'gender'])
     *   .expression(
     *     (eb) => eb.selectFrom('pet').select(['name', sql.lit('other').as('gender')])
     *   )
     *   .execute()
     * ```
     *
     * The generated SQL (MS SQL Server):
     *
     * ```sql
     * insert top(5) into "person" ("first_name", "gender") select "name", 'other' as "gender" from "pet"
     * ```
     *
     * Insert the first 50 percent of rows:
     *
     * ```ts
     * await db.insertInto('person')
     *   .top(50, 'percent')
     *   .columns(['first_name', 'gender'])
     *   .expression(
     *     (eb) => eb.selectFrom('pet').select(['name', sql.lit('other').as('gender')])
     *   )
     *   .execute()
     * ```
     *
     * The generated SQL (MS SQL Server):
     *
     * ```sql
     * insert top(50) percent into "person" ("first_name", "gender") select "name", 'other' as "gender" from "pet"
     * ```
     */
    top(expression, modifiers) {
        return new InsertQueryBuilder({
            ...this.#props,
            queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers)),
        });
    }
    /**
     * Adds an `on conflict` clause to the query.
     *
     * `on conflict` is only supported by some dialects like PostgreSQL and SQLite. On MySQL
     * you can use {@link ignore} and {@link onDuplicateKeyUpdate} to achieve similar results.
     *
     * ### Examples
     *
     * ```ts
     * await db
     *   .insertInto('pet')
     *   .values({
     *     name: 'Catto',
     *     species: 'cat',
     *   })
     *   .onConflict((oc) => oc
     *     .column('name')
     *     .doUpdateSet({ species: 'hamster' })
     *   )
     *   .execute()
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * insert into "pet" ("name", "species")
     * values ($1, $2)
     * on conflict ("name")
     * do update set "species" = $3
     * ```
     *
     * You can provide the name of the constraint instead of a column name:
     *
     * ```ts
     * await db
     *   .insertInto('pet')
     *   .values({
     *     name: 'Catto',
     *     species: 'cat',
     *   })
     *   .onConflict((oc) => oc
     *     .constraint('pet_name_key')
     *     .doUpdateSet({ species: 'hamster' })
     *   )
     *   .execute()
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * insert into "pet" ("name", "species")
     * values ($1, $2)
     * on conflict on constraint "pet_name_key"
     * do update set "species" = $3
     * ```
     *
     * You can also specify an expression as the conflict target in case
     * the unique index is an expression index:
     *
     * ```ts
     * import { sql } from 'kysely'
     *
     * await db
     *   .insertInto('pet')
     *   .values({
     *     name: 'Catto',
     *     species: 'cat',
     *   })
     *   .onConflict((oc) => oc
     *     .expression(sql<string>`lower(name)`)
     *     .doUpdateSet({ species: 'hamster' })
     *   )
     *   .execute()
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * insert into "pet" ("name", "species")
     * values ($1, $2)
     * on conflict (lower(name))
     * do update set "species" = $3
     * ```
     *
     * You can add a filter for the update statement like this:
     *
     * ```ts
     * await db
     *   .insertInto('pet')
     *   .values({
     *     name: 'Catto',
     *     species: 'cat',
     *   })
     *   .onConflict((oc) => oc
     *     .column('name')
     *     .doUpdateSet({ species: 'hamster' })
     *     .where('excluded.name', '!=', 'Catto'')
     *   )
     *   .execute()
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * insert into "pet" ("name", "species")
     * values ($1, $2)
     * on conflict ("name")
     * do update set "species" = $3
     * where "excluded"."name" != $4
     * ```
     *
     * You can create an `on conflict do nothing` clauses like this:
     *
     * ```ts
     * await db
     *   .insertInto('pet')
     *   .values({
     *     name: 'Catto',
     *     species: 'cat',
     *   })
     *   .onConflict((oc) => oc
     *     .column('name')
     *     .doNothing()
     *   )
     *   .execute()
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * insert into "pet" ("name", "species")
     * values ($1, $2)
     * on conflict ("name") do nothing
     * ```
     *
     * You can refer to the columns of the virtual `excluded` table
     * in a type-safe way using a callback and the `ref` method of
     * `ExpressionBuilder`:
     *
     * ```ts
     * db.insertInto('person')
     *   .values(person)
     *   .onConflict(oc => oc
     *     .column('id')
     *     .doUpdateSet({
     *       first_name: (eb) => eb.ref('excluded.first_name'),
     *       last_name: (eb) => eb.ref('excluded.last_name')
     *     })
     *   )
     * ```
     */
    onConflict(callback) {
        return new InsertQueryBuilder({
            ...this.#props,
            queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
                onConflict: callback(new OnConflictBuilder({
                    onConflictNode: OnConflictNode.create(),
                })).toOperationNode(),
            }),
        });
    }
    /**
     * Adds `on duplicate key update` to the query.
     *
     * If you specify `on duplicate key update`, and a row is inserted that would cause
     * a duplicate value in a unique index or primary key, an update of the old row occurs.
     *
     * This is only implemented by some dialects like MySQL. On most dialects you should
     * use {@link onConflict} instead.
     *
     * ### Examples
     *
     * ```ts
     * await db
     *   .insertInto('person')
     *   .values(values)
     *   .onDuplicateKeyUpdate({ species: 'hamster' })
     * ```
     */
    onDuplicateKeyUpdate(update) {
        return new InsertQueryBuilder({
            ...this.#props,
            queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
                onDuplicateKey: OnDuplicateKeyNode.create(parseUpdateObjectExpression(update)),
            }),
        });
    }
    returning(selection) {
        return new InsertQueryBuilder({
            ...this.#props,
            queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectArg(selection)),
        });
    }
    returningAll() {
        return new InsertQueryBuilder({
            ...this.#props,
            queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectAll()),
        });
    }
    output(args) {
        return new InsertQueryBuilder({
            ...this.#props,
            queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectArg(args)),
        });
    }
    outputAll(table) {
        return new InsertQueryBuilder({
            ...this.#props,
            queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectAll(table)),
        });
    }
    /**
     * Clears all `returning` clauses from the query.
     *
     * ### Examples
     *
     * ```ts
     * db.insertInto('person')
     *   .values({ first_name: 'James', last_name: 'Smith', age: 42 })
     *   .returning(['first_name'])
     *   .clearReturning()
     * ```
     *
     * The generated SQL(PostgreSQL):
     *
     * ```sql
     * insert into "person" ("James", "Smith", 42)
     * ```
     */
    clearReturning() {
        return new InsertQueryBuilder({
            ...this.#props,
            queryNode: QueryNode.cloneWithoutReturning(this.#props.queryNode),
        });
    }
    /**
     * Simply calls the provided function passing `this` as the only argument. `$call` returns
     * what the provided function returns.
     *
     * If you want to conditionally call a method on `this`, see
     * the {@link $if} method.
     *
     * ### Examples
     *
     * The next example uses a helper function `log` to log a query:
     *
     * ```ts
     * function log<T extends Compilable>(qb: T): T {
     *   console.log(qb.compile())
     *   return qb
     * }
     *
     * db.updateTable('person')
     *   .set(values)
     *   .$call(log)
     *   .execute()
     * ```
     */
    $call(func) {
        return func(this);
    }
    /**
     * Call `func(this)` if `condition` is true.
     *
     * This method is especially handy with optional selects. Any `returning` or `returningAll`
     * method calls add columns as optional fields to the output type when called inside
     * the `func` callback. This is because we can't know if those selections were actually
     * made before running the code.
     *
     * You can also call any other methods inside the callback.
     *
     * ### Examples
     *
     * ```ts
     * async function insertPerson(values: InsertablePerson, returnLastName: boolean) {
     *   return await db
     *     .insertInto('person')
     *     .values(values)
     *     .returning(['id', 'first_name'])
     *     .$if(returnLastName, (qb) => qb.returning('last_name'))
     *     .executeTakeFirstOrThrow()
     * }
     * ```
     *
     * Any selections added inside the `if` callback will be added as optional fields to the
     * output type since we can't know if the selections were actually made before running
     * the code. In the example above the return type of the `insertPerson` function is:
     *
     * ```ts
     * {
     *   id: number
     *   first_name: string
     *   last_name?: string
     * }
     * ```
     */
    $if(condition, func) {
        if (condition) {
            return func(this);
        }
        return new InsertQueryBuilder({
            ...this.#props,
        });
    }
    /**
     * Change the output type of the query.
     *
     * This method call doesn't change the SQL in any way. This methods simply
     * returns a copy of this `InsertQueryBuilder` with a new output type.
     */
    $castTo() {
        return new InsertQueryBuilder(this.#props);
    }
    /**
     * Narrows (parts of) the output type of the query.
     *
     * Kysely tries to be as type-safe as possible, but in some cases we have to make
     * compromises for better maintainability and compilation performance. At present,
     * Kysely doesn't narrow the output type of the query based on {@link values} input
     * when using {@link returning} or {@link returningAll}.
     *
     * This utility method is very useful for these situations, as it removes unncessary
     * runtime assertion/guard code. Its input type is limited to the output type
     * of the query, so you can't add a column that doesn't exist, or change a column's
     * type to something that doesn't exist in its union type.
     *
     * ### Examples
     *
     * Turn this code:
     *
     * ```ts
     * const person = await db.insertInto('person')
     *   .values({ ...inputPerson, nullable_column: 'hell yeah!' })
     *   .returningAll()
     *   .executeTakeFirstOrThrow()
     *
     * if (nullable_column) {
     *   functionThatExpectsPersonWithNonNullValue(person)
     * }
     * ```
     *
     * Into this:
     *
     * ```ts
     * const person = await db.insertInto('person')
     *   .values({ ...inputPerson, nullable_column: 'hell yeah!' })
     *   .returningAll()
     *   .$narrowType<{ nullable_column: string }>()
     *   .executeTakeFirstOrThrow()
     *
     * functionThatExpectsPersonWithNonNullValue(person)
     * ```
     */
    $narrowType() {
        return new InsertQueryBuilder(this.#props);
    }
    /**
     * Asserts that query's output row type equals the given type `T`.
     *
     * This method can be used to simplify excessively complex types to make TypeScript happy
     * and much faster.
     *
     * Kysely uses complex type magic to achieve its type safety. This complexity is sometimes too much
     * for TypeScript and you get errors like this:
     *
     * ```
     * error TS2589: Type instantiation is excessively deep and possibly infinite.
     * ```
     *
     * In these case you can often use this method to help TypeScript a little bit. When you use this
     * method to assert the output type of a query, Kysely can drop the complex output type that
     * consists of multiple nested helper types and replace it with the simple asserted type.
     *
     * Using this method doesn't reduce type safety at all. You have to pass in a type that is
     * structurally equal to the current type.
     *
     * ### Examples
     *
     * ```ts
     * const result = await db
     *   .with('new_person', (qb) => qb
     *     .insertInto('person')
     *     .values(person)
     *     .returning('id')
     *     .$assertType<{ id: string }>()
     *   )
     *   .with('new_pet', (qb) => qb
     *     .insertInto('pet')
     *     .values((eb) => ({ owner_id: eb.selectFrom('new_person').select('id'), ...pet }))
     *     .returning(['name as pet_name', 'species'])
     *     .$assertType<{ pet_name: string, species: Species }>()
     *   )
     *   .selectFrom(['new_person', 'new_pet'])
     *   .selectAll()
     *   .executeTakeFirstOrThrow()
     * ```
     */
    $assertType() {
        return new InsertQueryBuilder(this.#props);
    }
    /**
     * Returns a copy of this InsertQueryBuilder instance with the given plugin installed.
     */
    withPlugin(plugin) {
        return new InsertQueryBuilder({
            ...this.#props,
            executor: this.#props.executor.withPlugin(plugin),
        });
    }
    toOperationNode() {
        return this.#props.executor.transformQuery(this.#props.queryNode, this.#props.queryId);
    }
    compile() {
        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
    }
    /**
     * Executes the query and returns an array of rows.
     *
     * Also see the {@link executeTakeFirst} and {@link executeTakeFirstOrThrow} methods.
     */
    async execute() {
        const compiledQuery = this.compile();
        const result = await this.#props.executor.executeQuery(compiledQuery, this.#props.queryId);
        const { adapter } = this.#props.executor;
        const query = compiledQuery.query;
        if ((query.returning && adapter.supportsReturning) ||
            (query.output && adapter.supportsOutput)) {
            return result.rows;
        }
        return [
            new InsertResult(result.insertId, 
            // TODO: remove numUpdatedOrDeletedRows.
            result.numAffectedRows ?? result.numUpdatedOrDeletedRows),
        ];
    }
    /**
     * Executes the query and returns the first result or undefined if
     * the query returned no result.
     */
    async executeTakeFirst() {
        const [result] = await this.execute();
        return result;
    }
    /**
     * Executes the query and returns the first result or throws if
     * the query returned no result.
     *
     * By default an instance of {@link NoResultError} is thrown, but you can
     * provide a custom error class, or callback as the only argument to throw a different
     * error.
     */
    async executeTakeFirstOrThrow(errorConstructor = NoResultError) {
        const result = await this.executeTakeFirst();
        if (result === undefined) {
            const error = isNoResultErrorConstructor(errorConstructor)
                ? new errorConstructor(this.toOperationNode())
                : errorConstructor(this.toOperationNode());
            throw error;
        }
        return result;
    }
    async *stream(chunkSize = 100) {
        const compiledQuery = this.compile();
        const stream = this.#props.executor.stream(compiledQuery, chunkSize, this.#props.queryId);
        for await (const item of stream) {
            yield* item.rows;
        }
    }
    async explain(format, options) {
        const builder = new InsertQueryBuilder({
            ...this.#props,
            queryNode: QueryNode.cloneWithExplain(this.#props.queryNode, format, options),
        });
        return await builder.execute();
    }
}
preventAwait(InsertQueryBuilder, "don't await InsertQueryBuilder instances directly. To execute the query you need to call `execute` or `executeTakeFirst`.");

/// <reference types="./delete-result.d.ts" />
class DeleteResult {
    numDeletedRows;
    constructor(numDeletedRows) {
        this.numDeletedRows = numDeletedRows;
    }
}

/// <reference types="./limit-node.d.ts" />
/**
 * @internal
 */
const LimitNode = freeze({
    is(node) {
        return node.kind === 'LimitNode';
    },
    create(limit) {
        return freeze({
            kind: 'LimitNode',
            limit,
        });
    },
});

/// <reference types="./delete-query-builder.d.ts" />
class DeleteQueryBuilder {
    #props;
    constructor(props) {
        this.#props = freeze(props);
    }
    where(...args) {
        return new DeleteQueryBuilder({
            ...this.#props,
            queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseValueBinaryOperationOrExpression(args)),
        });
    }
    whereRef(lhs, op, rhs) {
        return new DeleteQueryBuilder({
            ...this.#props,
            queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseReferentialBinaryOperation(lhs, op, rhs)),
        });
    }
    clearWhere() {
        return new DeleteQueryBuilder({
            ...this.#props,
            queryNode: QueryNode.cloneWithoutWhere(this.#props.queryNode),
        });
    }
    /**
     * Changes a `delete from` query into a `delete top from` query.
     *
     * `top` clause is only supported by some dialects like MS SQL Server.
     *
     * ### Examples
     *
     * Delete the first 5 rows:
     *
     * ```ts
     * await db
     *   .deleteFrom('person')
     *   .top(5)
     *   .where('age', '>', 18)
     *   .executeTakeFirstOrThrow()
     * ```
     *
     * The generated SQL (MS SQL Server):
     *
     * ```sql
     * delete top(5) from "person" where "age" > @1
     * ```
     *
     * Delete the first 50% of rows:
     *
     * ```ts
     * await db
     *   .deleteFrom('person')
     *   .top(50, 'percent')
     *   .where('age', '>', 18)
     *   .executeTakeFirstOrThrow()
     * ```
     *
     * The generated SQL (MS SQL Server):
     *
     * ```sql
     * delete top(50) percent from "person" where "age" > @1
     * ```
     */
    top(expression, modifiers) {
        return new DeleteQueryBuilder({
            ...this.#props,
            queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers)),
        });
    }
    using(tables) {
        return new DeleteQueryBuilder({
            ...this.#props,
            queryNode: DeleteQueryNode.cloneWithUsing(this.#props.queryNode, parseTableExpressionOrList(tables)),
        });
    }
    innerJoin(...args) {
        return new DeleteQueryBuilder({
            ...this.#props,
            queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin('InnerJoin', args)),
        });
    }
    leftJoin(...args) {
        return new DeleteQueryBuilder({
            ...this.#props,
            queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin('LeftJoin', args)),
        });
    }
    rightJoin(...args) {
        return new DeleteQueryBuilder({
            ...this.#props,
            queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin('RightJoin', args)),
        });
    }
    fullJoin(...args) {
        return new DeleteQueryBuilder({
            ...this.#props,
            queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin('FullJoin', args)),
        });
    }
    returning(selection) {
        return new DeleteQueryBuilder({
            ...this.#props,
            queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectArg(selection)),
        });
    }
    returningAll(table) {
        return new DeleteQueryBuilder({
            ...this.#props,
            queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectAll(table)),
        });
    }
    output(args) {
        return new DeleteQueryBuilder({
            ...this.#props,
            queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectArg(args)),
        });
    }
    outputAll(table) {
        return new DeleteQueryBuilder({
            ...this.#props,
            queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectAll(table)),
        });
    }
    /**
     * Clears all `returning` clauses from the query.
     *
     * ### Examples
     *
     * ```ts
     * db.deleteFrom('pet')
     *   .returningAll()
     *   .where('name', '=', 'Max')
     *   .clearReturning()
     * ```
     *
     * The generated SQL(PostgreSQL):
     *
     * ```sql
     * delete from "pet" where "name" = "Max"
     * ```
     */
    clearReturning() {
        return new DeleteQueryBuilder({
            ...this.#props,
            queryNode: QueryNode.cloneWithoutReturning(this.#props.queryNode),
        });
    }
    /**
     * Clears the `limit` clause from the query.
     *
     * ### Examples
     *
     * ```ts
     * db.deleteFrom('pet')
     *   .returningAll()
     *   .where('name', '=', 'Max')
     *   .limit(5)
     *   .clearLimit()
     * ```
     *
     * The generated SQL(PostgreSQL):
     *
     * ```sql
     * delete from "pet" where "name" = "Max" returning *
     * ```
     */
    clearLimit() {
        return new DeleteQueryBuilder({
            ...this.#props,
            queryNode: DeleteQueryNode.cloneWithoutLimit(this.#props.queryNode),
        });
    }
    /**
     * Clears the `order by` clause from the query.
     *
     * ### Examples
     *
     * ```ts
     * db.deleteFrom('pet')
     *   .returningAll()
     *   .where('name', '=', 'Max')
     *   .orderBy('id')
     *   .clearOrderBy()
     * ```
     *
     * The generated SQL(PostgreSQL):
     *
     * ```sql
     * delete from "pet" where "name" = "Max" returning *
     * ```
     */
    clearOrderBy() {
        return new DeleteQueryBuilder({
            ...this.#props,
            queryNode: DeleteQueryNode.cloneWithoutOrderBy(this.#props.queryNode),
        });
    }
    /**
     * Adds an `order by` clause to the query.
     *
     * `orderBy` calls are additive. To order by multiple columns, call `orderBy`
     * multiple times.
     *
     * The first argument is the expression to order by and the second is the
     * order (`asc` or `desc`).
     *
     * An `order by` clause in a delete query is only supported by some dialects
     * like MySQL.
     *
     * See {@link SelectQueryBuilder.orderBy} for more examples.
     *
     * ### Examples
     *
     * Delete 5 oldest items in a table:
     *
     * ```ts
     * await db
     *   .deleteFrom('pet')
     *   .orderBy('created_at')
     *   .limit(5)
     *   .execute()
     * ```
     *
     * The generated SQL (MySQL):
     *
     * ```sql
     * delete from `pet`
     * order by `created_at`
     * limit ?
     * ```
     */
    orderBy(orderBy, direction) {
        return new DeleteQueryBuilder({
            ...this.#props,
            queryNode: DeleteQueryNode.cloneWithOrderByItems(this.#props.queryNode, parseOrderBy([orderBy, direction])),
        });
    }
    /**
     * Adds a limit clause to the query.
     *
     * A limit clause in a delete query is only supported by some dialects
     * like MySQL.
     *
     * ### Examples
     *
     * Delete 5 oldest items in a table:
     *
     * ```ts
     * await db
     *   .deleteFrom('pet')
     *   .orderBy('created_at')
     *   .limit(5)
     *   .execute()
     * ```
     */
    limit(limit) {
        return new DeleteQueryBuilder({
            ...this.#props,
            queryNode: DeleteQueryNode.cloneWithLimit(this.#props.queryNode, LimitNode.create(parseValueExpression(limit))),
        });
    }
    /**
     * Simply calls the provided function passing `this` as the only argument. `$call` returns
     * what the provided function returns.
     *
     * If you want to conditionally call a method on `this`, see
     * the {@link $if} method.
     *
     * ### Examples
     *
     * The next example uses a helper function `log` to log a query:
     *
     * ```ts
     * function log<T extends Compilable>(qb: T): T {
     *   console.log(qb.compile())
     *   return qb
     * }
     *
     * db.deleteFrom('person')
     *   .$call(log)
     *   .execute()
     * ```
     */
    $call(func) {
        return func(this);
    }
    /**
     * Call `func(this)` if `condition` is true.
     *
     * This method is especially handy with optional selects. Any `returning` or `returningAll`
     * method calls add columns as optional fields to the output type when called inside
     * the `func` callback. This is because we can't know if those selections were actually
     * made before running the code.
     *
     * You can also call any other methods inside the callback.
     *
     * ### Examples
     *
     * ```ts
     * async function deletePerson(id: number, returnLastName: boolean) {
     *   return await db
     *     .deleteFrom('person')
     *     .where('id', '=', id)
     *     .returning(['id', 'first_name'])
     *     .$if(returnLastName, (qb) => qb.returning('last_name'))
     *     .executeTakeFirstOrThrow()
     * }
     * ```
     *
     * Any selections added inside the `if` callback will be added as optional fields to the
     * output type since we can't know if the selections were actually made before running
     * the code. In the example above the return type of the `deletePerson` function is:
     *
     * ```ts
     * {
     *   id: number
     *   first_name: string
     *   last_name?: string
     * }
     * ```
     */
    $if(condition, func) {
        if (condition) {
            return func(this);
        }
        return new DeleteQueryBuilder({
            ...this.#props,
        });
    }
    /**
     * Change the output type of the query.
     *
     * This method call doesn't change the SQL in any way. This methods simply
     * returns a copy of this `DeleteQueryBuilder` with a new output type.
     */
    $castTo() {
        return new DeleteQueryBuilder(this.#props);
    }
    /**
     * Narrows (parts of) the output type of the query.
     *
     * Kysely tries to be as type-safe as possible, but in some cases we have to make
     * compromises for better maintainability and compilation performance. At present,
     * Kysely doesn't narrow the output type of the query when using {@link where} and {@link returning} or {@link returningAll}.
     *
     * This utility method is very useful for these situations, as it removes unncessary
     * runtime assertion/guard code. Its input type is limited to the output type
     * of the query, so you can't add a column that doesn't exist, or change a column's
     * type to something that doesn't exist in its union type.
     *
     * ### Examples
     *
     * Turn this code:
     *
     * ```ts
     * const person = await db.deleteFrom('person')
     *   .where('id', '=', id)
     *   .where('nullable_column', 'is not', null)
     *   .returningAll()
     *   .executeTakeFirstOrThrow()
     *
     * if (person.nullable_column) {
     *   functionThatExpectsPersonWithNonNullValue(person)
     * }
     * ```
     *
     * Into this:
     *
     * ```ts
     * const person = await db.deleteFrom('person')
     *   .where('id', '=', id)
     *   .where('nullable_column', 'is not', null)
     *   .returningAll()
     *   .$narrowType<{ nullable_column: string }>()
     *   .executeTakeFirstOrThrow()
     *
     * functionThatExpectsPersonWithNonNullValue(person)
     * ```
     */
    $narrowType() {
        return new DeleteQueryBuilder(this.#props);
    }
    /**
     * Asserts that query's output row type equals the given type `T`.
     *
     * This method can be used to simplify excessively complex types to make TypeScript happy
     * and much faster.
     *
     * Kysely uses complex type magic to achieve its type safety. This complexity is sometimes too much
     * for TypeScript and you get errors like this:
     *
     * ```
     * error TS2589: Type instantiation is excessively deep and possibly infinite.
     * ```
     *
     * In these case you can often use this method to help TypeScript a little bit. When you use this
     * method to assert the output type of a query, Kysely can drop the complex output type that
     * consists of multiple nested helper types and replace it with the simple asserted type.
     *
     * Using this method doesn't reduce type safety at all. You have to pass in a type that is
     * structurally equal to the current type.
     *
     * ### Examples
     *
     * ```ts
     * const result = await db
     *   .with('deleted_person', (qb) => qb
     *     .deleteFrom('person')
     *     .where('id', '=', person.id)
     *     .returning('first_name')
     *     .$assertType<{ first_name: string }>()
     *   )
     *   .with('deleted_pet', (qb) => qb
     *     .deleteFrom('pet')
     *     .where('owner_id', '=', person.id)
     *     .returning(['name as pet_name', 'species'])
     *     .$assertType<{ pet_name: string, species: Species }>()
     *   )
     *   .selectFrom(['deleted_person', 'deleted_pet'])
     *   .selectAll()
     *   .executeTakeFirstOrThrow()
     * ```
     */
    $assertType() {
        return new DeleteQueryBuilder(this.#props);
    }
    /**
     * Returns a copy of this DeleteQueryBuilder instance with the given plugin installed.
     */
    withPlugin(plugin) {
        return new DeleteQueryBuilder({
            ...this.#props,
            executor: this.#props.executor.withPlugin(plugin),
        });
    }
    toOperationNode() {
        return this.#props.executor.transformQuery(this.#props.queryNode, this.#props.queryId);
    }
    compile() {
        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
    }
    /**
     * Executes the query and returns an array of rows.
     *
     * Also see the {@link executeTakeFirst} and {@link executeTakeFirstOrThrow} methods.
     */
    async execute() {
        const compiledQuery = this.compile();
        const result = await this.#props.executor.executeQuery(compiledQuery, this.#props.queryId);
        const { adapter } = this.#props.executor;
        const query = compiledQuery.query;
        if ((query.returning && adapter.supportsReturning) ||
            (query.output && adapter.supportsOutput)) {
            return result.rows;
        }
        return [
            new DeleteResult(
            // TODO: remove numUpdatedOrDeletedRows.
            result.numAffectedRows ?? result.numUpdatedOrDeletedRows ?? BigInt(0)),
        ];
    }
    /**
     * Executes the query and returns the first result or undefined if
     * the query returned no result.
     */
    async executeTakeFirst() {
        const [result] = await this.execute();
        return result;
    }
    /**
     * Executes the query and returns the first result or throws if
     * the query returned no result.
     *
     * By default an instance of {@link NoResultError} is thrown, but you can
     * provide a custom error class, or callback as the only argument to throw a different
     * error.
     */
    async executeTakeFirstOrThrow(errorConstructor = NoResultError) {
        const result = await this.executeTakeFirst();
        if (result === undefined) {
            const error = isNoResultErrorConstructor(errorConstructor)
                ? new errorConstructor(this.toOperationNode())
                : errorConstructor(this.toOperationNode());
            throw error;
        }
        return result;
    }
    async *stream(chunkSize = 100) {
        const compiledQuery = this.compile();
        const stream = this.#props.executor.stream(compiledQuery, chunkSize, this.#props.queryId);
        for await (const item of stream) {
            yield* item.rows;
        }
    }
    async explain(format, options) {
        const builder = new DeleteQueryBuilder({
            ...this.#props,
            queryNode: QueryNode.cloneWithExplain(this.#props.queryNode, format, options),
        });
        return await builder.execute();
    }
}
preventAwait(DeleteQueryBuilder, "don't await DeleteQueryBuilder instances directly. To execute the query you need to call `execute` or `executeTakeFirst`.");

/// <reference types="./update-result.d.ts" />
class UpdateResult {
    /**
     * The number of rows the update query updated (even if not changed).
    */
    numUpdatedRows;
    /**
     * The number of rows the update query changed.
     *
     * This is **optional** and only supported in dialects such as MySQL.
     * You would probably use {@link numUpdatedRows} in most cases.
    */
    numChangedRows;
    constructor(numUpdatedRows, numChangedRows) {
        this.numUpdatedRows = numUpdatedRows;
        this.numChangedRows = numChangedRows;
    }
}

/// <reference types="./update-query-builder.d.ts" />
class UpdateQueryBuilder {
    #props;
    constructor(props) {
        this.#props = freeze(props);
    }
    where(...args) {
        return new UpdateQueryBuilder({
            ...this.#props,
            queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseValueBinaryOperationOrExpression(args)),
        });
    }
    whereRef(lhs, op, rhs) {
        return new UpdateQueryBuilder({
            ...this.#props,
            queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseReferentialBinaryOperation(lhs, op, rhs)),
        });
    }
    clearWhere() {
        return new UpdateQueryBuilder({
            ...this.#props,
            queryNode: QueryNode.cloneWithoutWhere(this.#props.queryNode),
        });
    }
    /**
     * Changes an `update` query into a `update top` query.
     *
     * `top` clause is only supported by some dialects like MS SQL Server.
     *
     * ### Examples
     *
     * Update the first row:
     *
     * ```ts
     * await db.updateTable('person')
     *   .top(1)
     *   .set({ first_name: 'Foo' })
     *   .where('age', '>', 18)
     *   .executeTakeFirstOrThrow()
     * ```
     *
     * The generated SQL (MS SQL Server):
     *
     * ```sql
     * update top(1) "person" set "first_name" = @1 where "age" > @2
     * ```
     *
     * Update the 50% first rows:
     *
     * ```ts
     * await db.updateTable('person')
     *   .top(50, 'percent')
     *   .set({ first_name: 'Foo' })
     *   .where('age', '>', 18)
     *   .executeTakeFirstOrThrow()
     * ```
     *
     * The generated SQL (MS SQL Server):
     *
     * ```sql
     * update top(50) percent "person" set "first_name" = @1 where "age" > @2
     * ```
     */
    top(expression, modifiers) {
        return new UpdateQueryBuilder({
            ...this.#props,
            queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers)),
        });
    }
    from(from) {
        return new UpdateQueryBuilder({
            ...this.#props,
            queryNode: UpdateQueryNode.cloneWithFromItems(this.#props.queryNode, parseTableExpressionOrList(from)),
        });
    }
    innerJoin(...args) {
        return new UpdateQueryBuilder({
            ...this.#props,
            queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin('InnerJoin', args)),
        });
    }
    leftJoin(...args) {
        return new UpdateQueryBuilder({
            ...this.#props,
            queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin('LeftJoin', args)),
        });
    }
    rightJoin(...args) {
        return new UpdateQueryBuilder({
            ...this.#props,
            queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin('RightJoin', args)),
        });
    }
    fullJoin(...args) {
        return new UpdateQueryBuilder({
            ...this.#props,
            queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin('FullJoin', args)),
        });
    }
    /**
     * Adds a limit clause to the update query for supported databases, such as MySQL.
     *
     * ### Examples
     *
     * Update the first 2 rows in the 'person' table:
     *
     * ```ts
     * return await db
     *   .updateTable('person')
     *   .set({ first_name: 'Foo' })
     *   .limit(2);
     * ```
     *
     * The generated SQL (MySQL):
     * ```sql
     * update `person` set `first_name` = 'Foo' limit 2
     * ```
     */
    limit(limit) {
        return new UpdateQueryBuilder({
            ...this.#props,
            queryNode: UpdateQueryNode.cloneWithLimit(this.#props.queryNode, LimitNode.create(parseValueExpression(limit))),
        });
    }
    set(...args) {
        return new UpdateQueryBuilder({
            ...this.#props,
            queryNode: UpdateQueryNode.cloneWithUpdates(this.#props.queryNode, parseUpdate(...args)),
        });
    }
    returning(selection) {
        return new UpdateQueryBuilder({
            ...this.#props,
            queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectArg(selection)),
        });
    }
    returningAll(table) {
        return new UpdateQueryBuilder({
            ...this.#props,
            queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectAll(table)),
        });
    }
    output(args) {
        return new UpdateQueryBuilder({
            ...this.#props,
            queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectArg(args)),
        });
    }
    outputAll(table) {
        return new UpdateQueryBuilder({
            ...this.#props,
            queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectAll(table)),
        });
    }
    /**
     * Clears all `returning` clauses from the query.
     *
     * ### Examples
     *
     * ```ts
     * db.updateTable('person')
     *   .returningAll()
     *   .set({ age: 39 })
     *   .where('first_name', '=', 'John')
     *   .clearReturning()
     * ```
     *
     * The generated SQL(PostgreSQL):
     *
     * ```sql
     * update "person" set "age" = 39 where "first_name" = "John"
     * ```
     */
    clearReturning() {
        return new UpdateQueryBuilder({
            ...this.#props,
            queryNode: QueryNode.cloneWithoutReturning(this.#props.queryNode),
        });
    }
    /**
     * Simply calls the provided function passing `this` as the only argument. `$call` returns
     * what the provided function returns.
     *
     * If you want to conditionally call a method on `this`, see
     * the {@link $if} method.
     *
     * ### Examples
     *
     * The next example uses a helper function `log` to log a query:
     *
     * ```ts
     * function log<T extends Compilable>(qb: T): T {
     *   console.log(qb.compile())
     *   return qb
     * }
     *
     * db.updateTable('person')
     *   .set(values)
     *   .$call(log)
     *   .execute()
     * ```
     */
    $call(func) {
        return func(this);
    }
    /**
     * Call `func(this)` if `condition` is true.
     *
     * This method is especially handy with optional selects. Any `returning` or `returningAll`
     * method calls add columns as optional fields to the output type when called inside
     * the `func` callback. This is because we can't know if those selections were actually
     * made before running the code.
     *
     * You can also call any other methods inside the callback.
     *
     * ### Examples
     *
     * ```ts
     * async function updatePerson(id: number, updates: UpdateablePerson, returnLastName: boolean) {
     *   return await db
     *     .updateTable('person')
     *     .set(updates)
     *     .where('id', '=', id)
     *     .returning(['id', 'first_name'])
     *     .$if(returnLastName, (qb) => qb.returning('last_name'))
     *     .executeTakeFirstOrThrow()
     * }
     * ```
     *
     * Any selections added inside the `if` callback will be added as optional fields to the
     * output type since we can't know if the selections were actually made before running
     * the code. In the example above the return type of the `updatePerson` function is:
     *
     * ```ts
     * {
     *   id: number
     *   first_name: string
     *   last_name?: string
     * }
     * ```
     */
    $if(condition, func) {
        if (condition) {
            return func(this);
        }
        return new UpdateQueryBuilder({
            ...this.#props,
        });
    }
    /**
     * Change the output type of the query.
     *
     * This method call doesn't change the SQL in any way. This methods simply
     * returns a copy of this `UpdateQueryBuilder` with a new output type.
     */
    $castTo() {
        return new UpdateQueryBuilder(this.#props);
    }
    /**
     * Narrows (parts of) the output type of the query.
     *
     * Kysely tries to be as type-safe as possible, but in some cases we have to make
     * compromises for better maintainability and compilation performance. At present,
     * Kysely doesn't narrow the output type of the query based on {@link set} input
     * when using {@link where} and/or {@link returning} or {@link returningAll}.
     *
     * This utility method is very useful for these situations, as it removes unncessary
     * runtime assertion/guard code. Its input type is limited to the output type
     * of the query, so you can't add a column that doesn't exist, or change a column's
     * type to something that doesn't exist in its union type.
     *
     * ### Examples
     *
     * Turn this code:
     *
     * ```ts
     * const person = await db.updateTable('person')
     *   .set({ deletedAt: now })
     *   .where('id', '=', id)
     *   .where('nullable_column', 'is not', null)
     *   .returningAll()
     *   .executeTakeFirstOrThrow()
     *
     * if (person.nullable_column) {
     *   functionThatExpectsPersonWithNonNullValue(person)
     * }
     * ```
     *
     * Into this:
     *
     * ```ts
     * const person = await db.updateTable('person')
     *   .set({ deletedAt: now })
     *   .where('id', '=', id)
     *   .where('nullable_column', 'is not', null)
     *   .returningAll()
     *   .$narrowType<{ deletedAt: Date; nullable_column: string }>()
     *   .executeTakeFirstOrThrow()
     *
     * functionThatExpectsPersonWithNonNullValue(person)
     * ```
     */
    $narrowType() {
        return new UpdateQueryBuilder(this.#props);
    }
    /**
     * Asserts that query's output row type equals the given type `T`.
     *
     * This method can be used to simplify excessively complex types to make TypeScript happy
     * and much faster.
     *
     * Kysely uses complex type magic to achieve its type safety. This complexity is sometimes too much
     * for TypeScript and you get errors like this:
     *
     * ```
     * error TS2589: Type instantiation is excessively deep and possibly infinite.
     * ```
     *
     * In these case you can often use this method to help TypeScript a little bit. When you use this
     * method to assert the output type of a query, Kysely can drop the complex output type that
     * consists of multiple nested helper types and replace it with the simple asserted type.
     *
     * Using this method doesn't reduce type safety at all. You have to pass in a type that is
     * structurally equal to the current type.
     *
     * ### Examples
     *
     * ```ts
     * const result = await db
     *   .with('updated_person', (qb) => qb
     *     .updateTable('person')
     *     .set(person)
     *     .where('id', '=', person.id)
     *     .returning('first_name')
     *     .$assertType<{ first_name: string }>()
     *   )
     *   .with('updated_pet', (qb) => qb
     *     .updateTable('pet')
     *     .set(pet)
     *     .where('owner_id', '=', person.id)
     *     .returning(['name as pet_name', 'species'])
     *     .$assertType<{ pet_name: string, species: Species }>()
     *   )
     *   .selectFrom(['updated_person', 'updated_pet'])
     *   .selectAll()
     *   .executeTakeFirstOrThrow()
     * ```
     */
    $assertType() {
        return new UpdateQueryBuilder(this.#props);
    }
    /**
     * Returns a copy of this UpdateQueryBuilder instance with the given plugin installed.
     */
    withPlugin(plugin) {
        return new UpdateQueryBuilder({
            ...this.#props,
            executor: this.#props.executor.withPlugin(plugin),
        });
    }
    toOperationNode() {
        return this.#props.executor.transformQuery(this.#props.queryNode, this.#props.queryId);
    }
    compile() {
        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
    }
    /**
     * Executes the query and returns an array of rows.
     *
     * Also see the {@link executeTakeFirst} and {@link executeTakeFirstOrThrow} methods.
     */
    async execute() {
        const compiledQuery = this.compile();
        const result = await this.#props.executor.executeQuery(compiledQuery, this.#props.queryId);
        const { adapter } = this.#props.executor;
        const query = compiledQuery.query;
        if ((query.returning && adapter.supportsReturning) ||
            (query.output && adapter.supportsOutput)) {
            return result.rows;
        }
        return [
            new UpdateResult(
            // TODO: remove numUpdatedOrDeletedRows.
            // TODO: https://github.com/kysely-org/kysely/pull/431#discussion_r1172330899
            result.numAffectedRows ?? result.numUpdatedOrDeletedRows ?? BigInt(0), result.numChangedRows),
        ];
    }
    /**
     * Executes the query and returns the first result or undefined if
     * the query returned no result.
     */
    async executeTakeFirst() {
        const [result] = await this.execute();
        return result;
    }
    /**
     * Executes the query and returns the first result or throws if
     * the query returned no result.
     *
     * By default an instance of {@link NoResultError} is thrown, but you can
     * provide a custom error class, or callback as the only argument to throw a different
     * error.
     */
    async executeTakeFirstOrThrow(errorConstructor = NoResultError) {
        const result = await this.executeTakeFirst();
        if (result === undefined) {
            const error = isNoResultErrorConstructor(errorConstructor)
                ? new errorConstructor(this.toOperationNode())
                : errorConstructor(this.toOperationNode());
            throw error;
        }
        return result;
    }
    async *stream(chunkSize = 100) {
        const compiledQuery = this.compile();
        const stream = this.#props.executor.stream(compiledQuery, chunkSize, this.#props.queryId);
        for await (const item of stream) {
            yield* item.rows;
        }
    }
    async explain(format, options) {
        const builder = new UpdateQueryBuilder({
            ...this.#props,
            queryNode: QueryNode.cloneWithExplain(this.#props.queryNode, format, options),
        });
        return await builder.execute();
    }
}
preventAwait(UpdateQueryBuilder, "don't await UpdateQueryBuilder instances directly. To execute the query you need to call `execute` or `executeTakeFirst`.");

/// <reference types="./common-table-expression-name-node.d.ts" />
/**
 * @internal
 */
const CommonTableExpressionNameNode = freeze({
    is(node) {
        return node.kind === 'CommonTableExpressionNameNode';
    },
    create(tableName, columnNames) {
        return freeze({
            kind: 'CommonTableExpressionNameNode',
            table: TableNode.create(tableName),
            columns: columnNames
                ? freeze(columnNames.map(ColumnNode.create))
                : undefined,
        });
    },
});

/// <reference types="./common-table-expression-node.d.ts" />
/**
 * @internal
 */
const CommonTableExpressionNode = freeze({
    is(node) {
        return node.kind === 'CommonTableExpressionNode';
    },
    create(name, expression) {
        return freeze({
            kind: 'CommonTableExpressionNode',
            name,
            expression,
        });
    },
    cloneWith(node, props) {
        return freeze({
            ...node,
            ...props,
        });
    },
});

/// <reference types="./cte-builder.d.ts" />
class CTEBuilder {
    #props;
    constructor(props) {
        this.#props = freeze(props);
    }
    /**
     * Makes the common table expression materialized.
     */
    materialized() {
        return new CTEBuilder({
            ...this.#props,
            node: CommonTableExpressionNode.cloneWith(this.#props.node, {
                materialized: true,
            }),
        });
    }
    /**
     * Makes the common table expression not materialized.
     */
    notMaterialized() {
        return new CTEBuilder({
            ...this.#props,
            node: CommonTableExpressionNode.cloneWith(this.#props.node, {
                materialized: false,
            }),
        });
    }
    toOperationNode() {
        return this.#props.node;
    }
}
preventAwait(CTEBuilder, "don't await CTEBuilder instances. They are never executed directly and are always just a part of a query.");

/// <reference types="./with-parser.d.ts" />
function parseCommonTableExpression(nameOrBuilderCallback, expression) {
    const expressionNode = expression(createQueryCreator()).toOperationNode();
    if (isFunction(nameOrBuilderCallback)) {
        return nameOrBuilderCallback(cteBuilderFactory(expressionNode)).toOperationNode();
    }
    return CommonTableExpressionNode.create(parseCommonTableExpressionName(nameOrBuilderCallback), expressionNode);
}
function cteBuilderFactory(expressionNode) {
    return (name) => {
        return new CTEBuilder({
            node: CommonTableExpressionNode.create(parseCommonTableExpressionName(name), expressionNode),
        });
    };
}
function parseCommonTableExpressionName(name) {
    if (name.includes('(')) {
        const parts = name.split(/[\(\)]/);
        const table = parts[0];
        const columns = parts[1].split(',').map((it) => it.trim());
        return CommonTableExpressionNameNode.create(table, columns);
    }
    else {
        return CommonTableExpressionNameNode.create(name);
    }
}

/// <reference types="./with-node.d.ts" />
/**
 * @internal
 */
const WithNode = freeze({
    is(node) {
        return node.kind === 'WithNode';
    },
    create(expression, params) {
        return freeze({
            kind: 'WithNode',
            expressions: freeze([expression]),
            ...params,
        });
    },
    cloneWithExpression(withNode, expression) {
        return freeze({
            ...withNode,
            expressions: freeze([...withNode.expressions, expression]),
        });
    },
});

/// <reference types="./random-string.d.ts" />
const CHARS = [
    'A',
    'B',
    'C',
    'D',
    'E',
    'F',
    'G',
    'H',
    'I',
    'J',
    'K',
    'L',
    'M',
    'N',
    'O',
    'P',
    'Q',
    'R',
    'S',
    'T',
    'U',
    'V',
    'W',
    'X',
    'Y',
    'Z',
    'a',
    'b',
    'c',
    'd',
    'e',
    'f',
    'g',
    'h',
    'i',
    'j',
    'k',
    'l',
    'm',
    'n',
    'o',
    'p',
    'q',
    'r',
    's',
    't',
    'u',
    'v',
    'w',
    'x',
    'y',
    'z',
    '0',
    '1',
    '2',
    '3',
    '4',
    '5',
    '6',
    '7',
    '8',
    '9',
];
function randomString(length) {
    let chars = '';
    for (let i = 0; i < length; ++i) {
        chars += randomChar();
    }
    return chars;
}
function randomChar() {
    return CHARS[~~(Math.random() * CHARS.length)];
}

/// <reference types="./query-id.d.ts" />
function createQueryId() {
    return new LazyQueryId();
}
class LazyQueryId {
    #queryId;
    get queryId() {
        if (this.#queryId === undefined) {
            this.#queryId = randomString(8);
        }
        return this.#queryId;
    }
}

/// <reference types="./require-all-props.d.ts" />
/**
 * Helper function to check listed properties according to given type. Check if all properties has been used when object is initialised.
 *
 * Example use:
 *
 * ```ts
 * type SomeType = { propA: string; propB?: number; }
 *
 * // propB has to be mentioned even it is optional. It still should be initialized with undefined.
 * const a: SomeType = requireAllProps<SomeType>({ propA: "value A", propB: undefined });
 *
 * // checked type is implicit for variable.
 * const b = requireAllProps<SomeType>({ propA: "value A", propB: undefined });
 * ```
 *
 * Wrong use of this helper:
 *
 * 1. Omit checked type - all checked properties will be expect as of type never
 *
 * ```ts
 * const z: SomeType = requireAllProps({ propC: "no type will work" });
 * ```
 *
 * 2. Apply to spreaded object - there is no way how to check in compile time if spreaded object contains all properties
 *
 * ```ts
 * const y: SomeType = { propA: "" }; // valid object according to SomeType declaration
 * const x = requireAllProps<SomeType>( { ... y } );
 * ```
 *
 * @param obj object to check if all properties has been used
 * @returns untouched obj parameter is returned
 */
function requireAllProps(obj) {
    return obj;
}

/// <reference types="./operation-node-transformer.d.ts" />
/**
 * Transforms an operation node tree into another one.
 *
 * Kysely queries are expressed internally as a tree of objects (operation nodes).
 * `OperationNodeTransformer` takes such a tree as its input and returns a
 * transformed deep copy of it. By default the `OperationNodeTransformer`
 * does nothing. You need to override one or more methods to make it do
 * something.
 *
 * There's a method for each node type. For example if you'd like to convert
 * each identifier (table name, column name, alias etc.) from camelCase to
 * snake_case, you'd do something like this:
 *
 * ```ts
 * class CamelCaseTransformer extends OperationNodeTransformer {
 *   transformIdentifier(node: IdentifierNode): IdentifierNode {
 *     node = super.transformIdentifier(node),
 *
 *     return {
 *       ...node,
 *       name: snakeCase(node.name),
 *     }
 *   }
 * }
 *
 * const transformer = new CamelCaseTransformer()
 * const tree = transformer.transformNode(tree)
 * ```
 */
class OperationNodeTransformer {
    nodeStack = [];
    #transformers = freeze({
        AliasNode: this.transformAlias.bind(this),
        ColumnNode: this.transformColumn.bind(this),
        IdentifierNode: this.transformIdentifier.bind(this),
        SchemableIdentifierNode: this.transformSchemableIdentifier.bind(this),
        RawNode: this.transformRaw.bind(this),
        ReferenceNode: this.transformReference.bind(this),
        SelectQueryNode: this.transformSelectQuery.bind(this),
        SelectionNode: this.transformSelection.bind(this),
        TableNode: this.transformTable.bind(this),
        FromNode: this.transformFrom.bind(this),
        SelectAllNode: this.transformSelectAll.bind(this),
        AndNode: this.transformAnd.bind(this),
        OrNode: this.transformOr.bind(this),
        ValueNode: this.transformValue.bind(this),
        ValueListNode: this.transformValueList.bind(this),
        PrimitiveValueListNode: this.transformPrimitiveValueList.bind(this),
        ParensNode: this.transformParens.bind(this),
        JoinNode: this.transformJoin.bind(this),
        OperatorNode: this.transformOperator.bind(this),
        WhereNode: this.transformWhere.bind(this),
        InsertQueryNode: this.transformInsertQuery.bind(this),
        DeleteQueryNode: this.transformDeleteQuery.bind(this),
        ReturningNode: this.transformReturning.bind(this),
        CreateTableNode: this.transformCreateTable.bind(this),
        AddColumnNode: this.transformAddColumn.bind(this),
        ColumnDefinitionNode: this.transformColumnDefinition.bind(this),
        DropTableNode: this.transformDropTable.bind(this),
        DataTypeNode: this.transformDataType.bind(this),
        OrderByNode: this.transformOrderBy.bind(this),
        OrderByItemNode: this.transformOrderByItem.bind(this),
        GroupByNode: this.transformGroupBy.bind(this),
        GroupByItemNode: this.transformGroupByItem.bind(this),
        UpdateQueryNode: this.transformUpdateQuery.bind(this),
        ColumnUpdateNode: this.transformColumnUpdate.bind(this),
        LimitNode: this.transformLimit.bind(this),
        OffsetNode: this.transformOffset.bind(this),
        OnConflictNode: this.transformOnConflict.bind(this),
        OnDuplicateKeyNode: this.transformOnDuplicateKey.bind(this),
        CreateIndexNode: this.transformCreateIndex.bind(this),
        DropIndexNode: this.transformDropIndex.bind(this),
        ListNode: this.transformList.bind(this),
        PrimaryKeyConstraintNode: this.transformPrimaryKeyConstraint.bind(this),
        UniqueConstraintNode: this.transformUniqueConstraint.bind(this),
        ReferencesNode: this.transformReferences.bind(this),
        CheckConstraintNode: this.transformCheckConstraint.bind(this),
        WithNode: this.transformWith.bind(this),
        CommonTableExpressionNode: this.transformCommonTableExpression.bind(this),
        CommonTableExpressionNameNode: this.transformCommonTableExpressionName.bind(this),
        HavingNode: this.transformHaving.bind(this),
        CreateSchemaNode: this.transformCreateSchema.bind(this),
        DropSchemaNode: this.transformDropSchema.bind(this),
        AlterTableNode: this.transformAlterTable.bind(this),
        DropColumnNode: this.transformDropColumn.bind(this),
        RenameColumnNode: this.transformRenameColumn.bind(this),
        AlterColumnNode: this.transformAlterColumn.bind(this),
        ModifyColumnNode: this.transformModifyColumn.bind(this),
        AddConstraintNode: this.transformAddConstraint.bind(this),
        DropConstraintNode: this.transformDropConstraint.bind(this),
        ForeignKeyConstraintNode: this.transformForeignKeyConstraint.bind(this),
        CreateViewNode: this.transformCreateView.bind(this),
        DropViewNode: this.transformDropView.bind(this),
        GeneratedNode: this.transformGenerated.bind(this),
        DefaultValueNode: this.transformDefaultValue.bind(this),
        OnNode: this.transformOn.bind(this),
        ValuesNode: this.transformValues.bind(this),
        SelectModifierNode: this.transformSelectModifier.bind(this),
        CreateTypeNode: this.transformCreateType.bind(this),
        DropTypeNode: this.transformDropType.bind(this),
        ExplainNode: this.transformExplain.bind(this),
        DefaultInsertValueNode: this.transformDefaultInsertValue.bind(this),
        AggregateFunctionNode: this.transformAggregateFunction.bind(this),
        OverNode: this.transformOver.bind(this),
        PartitionByNode: this.transformPartitionBy.bind(this),
        PartitionByItemNode: this.transformPartitionByItem.bind(this),
        SetOperationNode: this.transformSetOperation.bind(this),
        BinaryOperationNode: this.transformBinaryOperation.bind(this),
        UnaryOperationNode: this.transformUnaryOperation.bind(this),
        UsingNode: this.transformUsing.bind(this),
        FunctionNode: this.transformFunction.bind(this),
        CaseNode: this.transformCase.bind(this),
        WhenNode: this.transformWhen.bind(this),
        JSONReferenceNode: this.transformJSONReference.bind(this),
        JSONPathNode: this.transformJSONPath.bind(this),
        JSONPathLegNode: this.transformJSONPathLeg.bind(this),
        JSONOperatorChainNode: this.transformJSONOperatorChain.bind(this),
        TupleNode: this.transformTuple.bind(this),
        MergeQueryNode: this.transformMergeQuery.bind(this),
        MatchedNode: this.transformMatched.bind(this),
        AddIndexNode: this.transformAddIndex.bind(this),
        CastNode: this.transformCast.bind(this),
        FetchNode: this.transformFetch.bind(this),
        TopNode: this.transformTop.bind(this),
        OutputNode: this.transformOutput.bind(this),
    });
    transformNode(node) {
        if (!node) {
            return node;
        }
        this.nodeStack.push(node);
        const out = this.transformNodeImpl(node);
        this.nodeStack.pop();
        return freeze(out);
    }
    transformNodeImpl(node) {
        return this.#transformers[node.kind](node);
    }
    transformNodeList(list) {
        if (!list) {
            return list;
        }
        return freeze(list.map((node) => this.transformNode(node)));
    }
    transformSelectQuery(node) {
        return requireAllProps({
            kind: 'SelectQueryNode',
            from: this.transformNode(node.from),
            selections: this.transformNodeList(node.selections),
            distinctOn: this.transformNodeList(node.distinctOn),
            joins: this.transformNodeList(node.joins),
            groupBy: this.transformNode(node.groupBy),
            orderBy: this.transformNode(node.orderBy),
            where: this.transformNode(node.where),
            frontModifiers: this.transformNodeList(node.frontModifiers),
            endModifiers: this.transformNodeList(node.endModifiers),
            limit: this.transformNode(node.limit),
            offset: this.transformNode(node.offset),
            with: this.transformNode(node.with),
            having: this.transformNode(node.having),
            explain: this.transformNode(node.explain),
            setOperations: this.transformNodeList(node.setOperations),
            fetch: this.transformNode(node.fetch),
            top: this.transformNode(node.top),
        });
    }
    transformSelection(node) {
        return requireAllProps({
            kind: 'SelectionNode',
            selection: this.transformNode(node.selection),
        });
    }
    transformColumn(node) {
        return requireAllProps({
            kind: 'ColumnNode',
            column: this.transformNode(node.column),
        });
    }
    transformAlias(node) {
        return requireAllProps({
            kind: 'AliasNode',
            node: this.transformNode(node.node),
            alias: this.transformNode(node.alias),
        });
    }
    transformTable(node) {
        return requireAllProps({
            kind: 'TableNode',
            table: this.transformNode(node.table),
        });
    }
    transformFrom(node) {
        return requireAllProps({
            kind: 'FromNode',
            froms: this.transformNodeList(node.froms),
        });
    }
    transformReference(node) {
        return requireAllProps({
            kind: 'ReferenceNode',
            column: this.transformNode(node.column),
            table: this.transformNode(node.table),
        });
    }
    transformAnd(node) {
        return requireAllProps({
            kind: 'AndNode',
            left: this.transformNode(node.left),
            right: this.transformNode(node.right),
        });
    }
    transformOr(node) {
        return requireAllProps({
            kind: 'OrNode',
            left: this.transformNode(node.left),
            right: this.transformNode(node.right),
        });
    }
    transformValueList(node) {
        return requireAllProps({
            kind: 'ValueListNode',
            values: this.transformNodeList(node.values),
        });
    }
    transformParens(node) {
        return requireAllProps({
            kind: 'ParensNode',
            node: this.transformNode(node.node),
        });
    }
    transformJoin(node) {
        return requireAllProps({
            kind: 'JoinNode',
            joinType: node.joinType,
            table: this.transformNode(node.table),
            on: this.transformNode(node.on),
        });
    }
    transformRaw(node) {
        return requireAllProps({
            kind: 'RawNode',
            sqlFragments: freeze([...node.sqlFragments]),
            parameters: this.transformNodeList(node.parameters),
        });
    }
    transformWhere(node) {
        return requireAllProps({
            kind: 'WhereNode',
            where: this.transformNode(node.where),
        });
    }
    transformInsertQuery(node) {
        return requireAllProps({
            kind: 'InsertQueryNode',
            into: this.transformNode(node.into),
            columns: this.transformNodeList(node.columns),
            values: this.transformNode(node.values),
            returning: this.transformNode(node.returning),
            onConflict: this.transformNode(node.onConflict),
            onDuplicateKey: this.transformNode(node.onDuplicateKey),
            with: this.transformNode(node.with),
            ignore: node.ignore,
            replace: node.replace,
            explain: this.transformNode(node.explain),
            defaultValues: node.defaultValues,
            top: this.transformNode(node.top),
            output: this.transformNode(node.output),
        });
    }
    transformValues(node) {
        return requireAllProps({
            kind: 'ValuesNode',
            values: this.transformNodeList(node.values),
        });
    }
    transformDeleteQuery(node) {
        return requireAllProps({
            kind: 'DeleteQueryNode',
            from: this.transformNode(node.from),
            using: this.transformNode(node.using),
            joins: this.transformNodeList(node.joins),
            where: this.transformNode(node.where),
            returning: this.transformNode(node.returning),
            with: this.transformNode(node.with),
            orderBy: this.transformNode(node.orderBy),
            limit: this.transformNode(node.limit),
            explain: this.transformNode(node.explain),
            top: this.transformNode(node.top),
            output: this.transformNode(node.output),
        });
    }
    transformReturning(node) {
        return requireAllProps({
            kind: 'ReturningNode',
            selections: this.transformNodeList(node.selections),
        });
    }
    transformCreateTable(node) {
        return requireAllProps({
            kind: 'CreateTableNode',
            table: this.transformNode(node.table),
            columns: this.transformNodeList(node.columns),
            constraints: this.transformNodeList(node.constraints),
            temporary: node.temporary,
            ifNotExists: node.ifNotExists,
            onCommit: node.onCommit,
            frontModifiers: this.transformNodeList(node.frontModifiers),
            endModifiers: this.transformNodeList(node.endModifiers),
            selectQuery: this.transformNode(node.selectQuery),
        });
    }
    transformColumnDefinition(node) {
        return requireAllProps({
            kind: 'ColumnDefinitionNode',
            column: this.transformNode(node.column),
            dataType: this.transformNode(node.dataType),
            references: this.transformNode(node.references),
            primaryKey: node.primaryKey,
            autoIncrement: node.autoIncrement,
            unique: node.unique,
            notNull: node.notNull,
            unsigned: node.unsigned,
            defaultTo: this.transformNode(node.defaultTo),
            check: this.transformNode(node.check),
            generated: this.transformNode(node.generated),
            frontModifiers: this.transformNodeList(node.frontModifiers),
            endModifiers: this.transformNodeList(node.endModifiers),
            nullsNotDistinct: node.nullsNotDistinct,
            identity: node.identity,
            ifNotExists: node.ifNotExists,
        });
    }
    transformAddColumn(node) {
        return requireAllProps({
            kind: 'AddColumnNode',
            column: this.transformNode(node.column),
        });
    }
    transformDropTable(node) {
        return requireAllProps({
            kind: 'DropTableNode',
            table: this.transformNode(node.table),
            ifExists: node.ifExists,
            cascade: node.cascade,
        });
    }
    transformOrderBy(node) {
        return requireAllProps({
            kind: 'OrderByNode',
            items: this.transformNodeList(node.items),
        });
    }
    transformOrderByItem(node) {
        return requireAllProps({
            kind: 'OrderByItemNode',
            orderBy: this.transformNode(node.orderBy),
            direction: this.transformNode(node.direction),
        });
    }
    transformGroupBy(node) {
        return requireAllProps({
            kind: 'GroupByNode',
            items: this.transformNodeList(node.items),
        });
    }
    transformGroupByItem(node) {
        return requireAllProps({
            kind: 'GroupByItemNode',
            groupBy: this.transformNode(node.groupBy),
        });
    }
    transformUpdateQuery(node) {
        return requireAllProps({
            kind: 'UpdateQueryNode',
            table: this.transformNode(node.table),
            from: this.transformNode(node.from),
            joins: this.transformNodeList(node.joins),
            where: this.transformNode(node.where),
            updates: this.transformNodeList(node.updates),
            returning: this.transformNode(node.returning),
            with: this.transformNode(node.with),
            explain: this.transformNode(node.explain),
            limit: this.transformNode(node.limit),
            top: this.transformNode(node.top),
            output: this.transformNode(node.output),
        });
    }
    transformColumnUpdate(node) {
        return requireAllProps({
            kind: 'ColumnUpdateNode',
            column: this.transformNode(node.column),
            value: this.transformNode(node.value),
        });
    }
    transformLimit(node) {
        return requireAllProps({
            kind: 'LimitNode',
            limit: this.transformNode(node.limit),
        });
    }
    transformOffset(node) {
        return requireAllProps({
            kind: 'OffsetNode',
            offset: this.transformNode(node.offset),
        });
    }
    transformOnConflict(node) {
        return requireAllProps({
            kind: 'OnConflictNode',
            columns: this.transformNodeList(node.columns),
            constraint: this.transformNode(node.constraint),
            indexExpression: this.transformNode(node.indexExpression),
            indexWhere: this.transformNode(node.indexWhere),
            updates: this.transformNodeList(node.updates),
            updateWhere: this.transformNode(node.updateWhere),
            doNothing: node.doNothing,
        });
    }
    transformOnDuplicateKey(node) {
        return requireAllProps({
            kind: 'OnDuplicateKeyNode',
            updates: this.transformNodeList(node.updates),
        });
    }
    transformCreateIndex(node) {
        return requireAllProps({
            kind: 'CreateIndexNode',
            name: this.transformNode(node.name),
            table: this.transformNode(node.table),
            columns: this.transformNodeList(node.columns),
            unique: node.unique,
            using: this.transformNode(node.using),
            ifNotExists: node.ifNotExists,
            where: this.transformNode(node.where),
            nullsNotDistinct: node.nullsNotDistinct,
        });
    }
    transformList(node) {
        return requireAllProps({
            kind: 'ListNode',
            items: this.transformNodeList(node.items),
        });
    }
    transformDropIndex(node) {
        return requireAllProps({
            kind: 'DropIndexNode',
            name: this.transformNode(node.name),
            table: this.transformNode(node.table),
            ifExists: node.ifExists,
            cascade: node.cascade,
        });
    }
    transformPrimaryKeyConstraint(node) {
        return requireAllProps({
            kind: 'PrimaryKeyConstraintNode',
            columns: this.transformNodeList(node.columns),
            name: this.transformNode(node.name),
        });
    }
    transformUniqueConstraint(node) {
        return requireAllProps({
            kind: 'UniqueConstraintNode',
            columns: this.transformNodeList(node.columns),
            name: this.transformNode(node.name),
            nullsNotDistinct: node.nullsNotDistinct,
        });
    }
    transformForeignKeyConstraint(node) {
        return requireAllProps({
            kind: 'ForeignKeyConstraintNode',
            columns: this.transformNodeList(node.columns),
            references: this.transformNode(node.references),
            name: this.transformNode(node.name),
            onDelete: node.onDelete,
            onUpdate: node.onUpdate,
        });
    }
    transformSetOperation(node) {
        return requireAllProps({
            kind: 'SetOperationNode',
            operator: node.operator,
            expression: this.transformNode(node.expression),
            all: node.all,
        });
    }
    transformReferences(node) {
        return requireAllProps({
            kind: 'ReferencesNode',
            table: this.transformNode(node.table),
            columns: this.transformNodeList(node.columns),
            onDelete: node.onDelete,
            onUpdate: node.onUpdate,
        });
    }
    transformCheckConstraint(node) {
        return requireAllProps({
            kind: 'CheckConstraintNode',
            expression: this.transformNode(node.expression),
            name: this.transformNode(node.name),
        });
    }
    transformWith(node) {
        return requireAllProps({
            kind: 'WithNode',
            expressions: this.transformNodeList(node.expressions),
            recursive: node.recursive,
        });
    }
    transformCommonTableExpression(node) {
        return requireAllProps({
            kind: 'CommonTableExpressionNode',
            name: this.transformNode(node.name),
            materialized: node.materialized,
            expression: this.transformNode(node.expression),
        });
    }
    transformCommonTableExpressionName(node) {
        return requireAllProps({
            kind: 'CommonTableExpressionNameNode',
            table: this.transformNode(node.table),
            columns: this.transformNodeList(node.columns),
        });
    }
    transformHaving(node) {
        return requireAllProps({
            kind: 'HavingNode',
            having: this.transformNode(node.having),
        });
    }
    transformCreateSchema(node) {
        return requireAllProps({
            kind: 'CreateSchemaNode',
            schema: this.transformNode(node.schema),
            ifNotExists: node.ifNotExists,
        });
    }
    transformDropSchema(node) {
        return requireAllProps({
            kind: 'DropSchemaNode',
            schema: this.transformNode(node.schema),
            ifExists: node.ifExists,
            cascade: node.cascade,
        });
    }
    transformAlterTable(node) {
        return requireAllProps({
            kind: 'AlterTableNode',
            table: this.transformNode(node.table),
            renameTo: this.transformNode(node.renameTo),
            setSchema: this.transformNode(node.setSchema),
            columnAlterations: this.transformNodeList(node.columnAlterations),
            addConstraint: this.transformNode(node.addConstraint),
            dropConstraint: this.transformNode(node.dropConstraint),
            addIndex: this.transformNode(node.addIndex),
            dropIndex: this.transformNode(node.dropIndex),
        });
    }
    transformDropColumn(node) {
        return requireAllProps({
            kind: 'DropColumnNode',
            column: this.transformNode(node.column),
        });
    }
    transformRenameColumn(node) {
        return requireAllProps({
            kind: 'RenameColumnNode',
            column: this.transformNode(node.column),
            renameTo: this.transformNode(node.renameTo),
        });
    }
    transformAlterColumn(node) {
        return requireAllProps({
            kind: 'AlterColumnNode',
            column: this.transformNode(node.column),
            dataType: this.transformNode(node.dataType),
            dataTypeExpression: this.transformNode(node.dataTypeExpression),
            setDefault: this.transformNode(node.setDefault),
            dropDefault: node.dropDefault,
            setNotNull: node.setNotNull,
            dropNotNull: node.dropNotNull,
        });
    }
    transformModifyColumn(node) {
        return requireAllProps({
            kind: 'ModifyColumnNode',
            column: this.transformNode(node.column),
        });
    }
    transformAddConstraint(node) {
        return requireAllProps({
            kind: 'AddConstraintNode',
            constraint: this.transformNode(node.constraint),
        });
    }
    transformDropConstraint(node) {
        return requireAllProps({
            kind: 'DropConstraintNode',
            constraintName: this.transformNode(node.constraintName),
            ifExists: node.ifExists,
            modifier: node.modifier,
        });
    }
    transformCreateView(node) {
        return requireAllProps({
            kind: 'CreateViewNode',
            name: this.transformNode(node.name),
            temporary: node.temporary,
            orReplace: node.orReplace,
            ifNotExists: node.ifNotExists,
            materialized: node.materialized,
            columns: this.transformNodeList(node.columns),
            as: this.transformNode(node.as),
        });
    }
    transformDropView(node) {
        return requireAllProps({
            kind: 'DropViewNode',
            name: this.transformNode(node.name),
            ifExists: node.ifExists,
            materialized: node.materialized,
            cascade: node.cascade,
        });
    }
    transformGenerated(node) {
        return requireAllProps({
            kind: 'GeneratedNode',
            byDefault: node.byDefault,
            always: node.always,
            identity: node.identity,
            stored: node.stored,
            expression: this.transformNode(node.expression),
        });
    }
    transformDefaultValue(node) {
        return requireAllProps({
            kind: 'DefaultValueNode',
            defaultValue: this.transformNode(node.defaultValue),
        });
    }
    transformOn(node) {
        return requireAllProps({
            kind: 'OnNode',
            on: this.transformNode(node.on),
        });
    }
    transformSelectModifier(node) {
        return requireAllProps({
            kind: 'SelectModifierNode',
            modifier: node.modifier,
            rawModifier: this.transformNode(node.rawModifier),
            of: this.transformNodeList(node.of),
        });
    }
    transformCreateType(node) {
        return requireAllProps({
            kind: 'CreateTypeNode',
            name: this.transformNode(node.name),
            enum: this.transformNode(node.enum),
        });
    }
    transformDropType(node) {
        return requireAllProps({
            kind: 'DropTypeNode',
            name: this.transformNode(node.name),
            ifExists: node.ifExists,
        });
    }
    transformExplain(node) {
        return requireAllProps({
            kind: 'ExplainNode',
            format: node.format,
            options: this.transformNode(node.options),
        });
    }
    transformSchemableIdentifier(node) {
        return requireAllProps({
            kind: 'SchemableIdentifierNode',
            schema: this.transformNode(node.schema),
            identifier: this.transformNode(node.identifier),
        });
    }
    transformAggregateFunction(node) {
        return requireAllProps({
            kind: 'AggregateFunctionNode',
            aggregated: this.transformNodeList(node.aggregated),
            distinct: node.distinct,
            filter: this.transformNode(node.filter),
            func: node.func,
            over: this.transformNode(node.over),
        });
    }
    transformOver(node) {
        return requireAllProps({
            kind: 'OverNode',
            orderBy: this.transformNode(node.orderBy),
            partitionBy: this.transformNode(node.partitionBy),
        });
    }
    transformPartitionBy(node) {
        return requireAllProps({
            kind: 'PartitionByNode',
            items: this.transformNodeList(node.items),
        });
    }
    transformPartitionByItem(node) {
        return requireAllProps({
            kind: 'PartitionByItemNode',
            partitionBy: this.transformNode(node.partitionBy),
        });
    }
    transformBinaryOperation(node) {
        return requireAllProps({
            kind: 'BinaryOperationNode',
            leftOperand: this.transformNode(node.leftOperand),
            operator: this.transformNode(node.operator),
            rightOperand: this.transformNode(node.rightOperand),
        });
    }
    transformUnaryOperation(node) {
        return requireAllProps({
            kind: 'UnaryOperationNode',
            operator: this.transformNode(node.operator),
            operand: this.transformNode(node.operand),
        });
    }
    transformUsing(node) {
        return requireAllProps({
            kind: 'UsingNode',
            tables: this.transformNodeList(node.tables),
        });
    }
    transformFunction(node) {
        return requireAllProps({
            kind: 'FunctionNode',
            func: node.func,
            arguments: this.transformNodeList(node.arguments),
        });
    }
    transformCase(node) {
        return requireAllProps({
            kind: 'CaseNode',
            value: this.transformNode(node.value),
            when: this.transformNodeList(node.when),
            else: this.transformNode(node.else),
            isStatement: node.isStatement,
        });
    }
    transformWhen(node) {
        return requireAllProps({
            kind: 'WhenNode',
            condition: this.transformNode(node.condition),
            result: this.transformNode(node.result),
        });
    }
    transformJSONReference(node) {
        return requireAllProps({
            kind: 'JSONReferenceNode',
            reference: this.transformNode(node.reference),
            traversal: this.transformNode(node.traversal),
        });
    }
    transformJSONPath(node) {
        return requireAllProps({
            kind: 'JSONPathNode',
            inOperator: this.transformNode(node.inOperator),
            pathLegs: this.transformNodeList(node.pathLegs),
        });
    }
    transformJSONPathLeg(node) {
        return requireAllProps({
            kind: 'JSONPathLegNode',
            type: node.type,
            value: node.value,
        });
    }
    transformJSONOperatorChain(node) {
        return requireAllProps({
            kind: 'JSONOperatorChainNode',
            operator: this.transformNode(node.operator),
            values: this.transformNodeList(node.values),
        });
    }
    transformTuple(node) {
        return requireAllProps({
            kind: 'TupleNode',
            values: this.transformNodeList(node.values),
        });
    }
    transformMergeQuery(node) {
        return requireAllProps({
            kind: 'MergeQueryNode',
            into: this.transformNode(node.into),
            using: this.transformNode(node.using),
            whens: this.transformNodeList(node.whens),
            with: this.transformNode(node.with),
            top: this.transformNode(node.top),
            output: this.transformNode(node.output),
        });
    }
    transformMatched(node) {
        return requireAllProps({
            kind: 'MatchedNode',
            not: node.not,
            bySource: node.bySource,
        });
    }
    transformAddIndex(node) {
        return requireAllProps({
            kind: 'AddIndexNode',
            name: this.transformNode(node.name),
            columns: this.transformNodeList(node.columns),
            unique: node.unique,
            using: this.transformNode(node.using),
            ifNotExists: node.ifNotExists,
        });
    }
    transformCast(node) {
        return requireAllProps({
            kind: 'CastNode',
            expression: this.transformNode(node.expression),
            dataType: this.transformNode(node.dataType),
        });
    }
    transformFetch(node) {
        return requireAllProps({
            kind: 'FetchNode',
            rowCount: this.transformNode(node.rowCount),
            modifier: node.modifier,
        });
    }
    transformTop(node) {
        return requireAllProps({
            kind: 'TopNode',
            expression: node.expression,
            modifiers: node.modifiers,
        });
    }
    transformOutput(node) {
        return requireAllProps({
            kind: 'OutputNode',
            selections: this.transformNodeList(node.selections),
        });
    }
    transformDataType(node) {
        // An Object.freezed leaf node. No need to clone.
        return node;
    }
    transformSelectAll(node) {
        // An Object.freezed leaf node. No need to clone.
        return node;
    }
    transformIdentifier(node) {
        // An Object.freezed leaf node. No need to clone.
        return node;
    }
    transformValue(node) {
        // An Object.freezed leaf node. No need to clone.
        return node;
    }
    transformPrimitiveValueList(node) {
        // An Object.freezed leaf node. No need to clone.
        return node;
    }
    transformOperator(node) {
        // An Object.freezed leaf node. No need to clone.
        return node;
    }
    transformDefaultInsertValue(node) {
        // An Object.freezed leaf node. No need to clone.
        return node;
    }
}

/// <reference types="./with-schema-transformer.d.ts" />
// This object exist only so that we get a type error when a new RootOperationNode
// is added. If you get a type error here, make sure to add the new root node and
// handle it correctly in the transformer.
//
// DO NOT REFACTOR THIS EVEN IF IT SEEMS USELESS TO YOU!
const ROOT_OPERATION_NODES = freeze({
    AlterTableNode: true,
    CreateIndexNode: true,
    CreateSchemaNode: true,
    CreateTableNode: true,
    CreateTypeNode: true,
    CreateViewNode: true,
    DeleteQueryNode: true,
    DropIndexNode: true,
    DropSchemaNode: true,
    DropTableNode: true,
    DropTypeNode: true,
    DropViewNode: true,
    InsertQueryNode: true,
    RawNode: true,
    SelectQueryNode: true,
    UpdateQueryNode: true,
    MergeQueryNode: true,
});
class WithSchemaTransformer extends OperationNodeTransformer {
    #schema;
    #schemableIds = new Set();
    #ctes = new Set();
    constructor(schema) {
        super();
        this.#schema = schema;
    }
    transformNodeImpl(node) {
        if (!this.#isRootOperationNode(node)) {
            return super.transformNodeImpl(node);
        }
        const ctes = this.#collectCTEs(node);
        for (const cte of ctes) {
            this.#ctes.add(cte);
        }
        const tables = this.#collectSchemableIds(node);
        for (const table of tables) {
            this.#schemableIds.add(table);
        }
        const transformed = super.transformNodeImpl(node);
        for (const table of tables) {
            this.#schemableIds.delete(table);
        }
        for (const cte of ctes) {
            this.#ctes.delete(cte);
        }
        return transformed;
    }
    transformSchemableIdentifier(node) {
        const transformed = super.transformSchemableIdentifier(node);
        if (transformed.schema || !this.#schemableIds.has(node.identifier.name)) {
            return transformed;
        }
        return {
            ...transformed,
            schema: IdentifierNode.create(this.#schema),
        };
    }
    transformReferences(node) {
        const transformed = super.transformReferences(node);
        if (transformed.table.table.schema) {
            return transformed;
        }
        return {
            ...transformed,
            table: TableNode.createWithSchema(this.#schema, transformed.table.table.identifier.name),
        };
    }
    #isRootOperationNode(node) {
        return node.kind in ROOT_OPERATION_NODES;
    }
    #collectSchemableIds(node) {
        const schemableIds = new Set();
        if ('name' in node && node.name && SchemableIdentifierNode.is(node.name)) {
            this.#collectSchemableId(node.name, schemableIds);
        }
        if ('from' in node && node.from) {
            for (const from of node.from.froms) {
                this.#collectSchemableIdsFromTableExpr(from, schemableIds);
            }
        }
        if ('into' in node && node.into) {
            this.#collectSchemableIdsFromTableExpr(node.into, schemableIds);
        }
        if ('table' in node && node.table) {
            this.#collectSchemableIdsFromTableExpr(node.table, schemableIds);
        }
        if ('joins' in node && node.joins) {
            for (const join of node.joins) {
                this.#collectSchemableIdsFromTableExpr(join.table, schemableIds);
            }
        }
        if ('using' in node && node.using) {
            this.#collectSchemableIdsFromTableExpr(node.using, schemableIds);
        }
        return schemableIds;
    }
    #collectCTEs(node) {
        const ctes = new Set();
        if ('with' in node && node.with) {
            this.#collectCTEIds(node.with, ctes);
        }
        return ctes;
    }
    #collectSchemableIdsFromTableExpr(node, schemableIds) {
        const table = TableNode.is(node)
            ? node
            : AliasNode.is(node) && TableNode.is(node.node)
                ? node.node
                : null;
        if (table) {
            this.#collectSchemableId(table.table, schemableIds);
        }
    }
    #collectSchemableId(node, schemableIds) {
        const id = node.identifier.name;
        if (!this.#schemableIds.has(id) && !this.#ctes.has(id)) {
            schemableIds.add(id);
        }
    }
    #collectCTEIds(node, ctes) {
        for (const expr of node.expressions) {
            const cteId = expr.name.table.table.identifier.name;
            if (!this.#ctes.has(cteId)) {
                ctes.add(cteId);
            }
        }
    }
}

/// <reference types="./with-schema-plugin.d.ts" />
class WithSchemaPlugin {
    #transformer;
    constructor(schema) {
        this.#transformer = new WithSchemaTransformer(schema);
    }
    transformQuery(args) {
        return this.#transformer.transformNode(args.node);
    }
    async transformResult(args) {
        return args.result;
    }
}

/// <reference types="./matched-node.d.ts" />
/**
 * @internal
 */
const MatchedNode = freeze({
    is(node) {
        return node.kind === 'MatchedNode';
    },
    create(not, bySource = false) {
        return freeze({
            kind: 'MatchedNode',
            not,
            bySource,
        });
    },
});

/// <reference types="./merge-parser.d.ts" />
function parseMergeWhen(type, args, refRight) {
    return WhenNode.create(parseFilterList([
        MatchedNode.create(!type.isMatched, type.bySource),
        ...(args && args.length > 0
            ? [
                args.length === 3 && refRight
                    ? parseReferentialBinaryOperation(args[0], args[1], args[2])
                    : parseValueBinaryOperationOrExpression(args),
            ]
            : []),
    ], 'and', false));
}
function parseMergeThen(result) {
    if (isString(result)) {
        return RawNode.create([result], []);
    }
    if (isOperationNodeSource(result)) {
        return result.toOperationNode();
    }
    return result;
}

/// <reference types="./deferred.d.ts" />
class Deferred {
    #promise;
    #resolve;
    #reject;
    constructor() {
        this.#promise = new Promise((resolve, reject) => {
            this.#reject = reject;
            this.#resolve = resolve;
        });
    }
    get promise() {
        return this.#promise;
    }
    resolve = (value) => {
        if (this.#resolve) {
            this.#resolve(value);
        }
    };
    reject = (reason) => {
        if (this.#reject) {
            this.#reject(reason);
        }
    };
}

/// <reference types="./log-once.d.ts" />
const LOGGED_MESSAGES = new Set();
/**
 * Use for system-level logging, such as deprecation messages.
 * Logs a message and ensures it won't be logged again.
 */
function logOnce(message) {
    if (LOGGED_MESSAGES.has(message)) {
        return;
    }
    LOGGED_MESSAGES.add(message);
    console.log(message);
}

/// <reference types="./query-executor-base.d.ts" />
const NO_PLUGINS = freeze([]);
class QueryExecutorBase {
    #plugins;
    constructor(plugins = NO_PLUGINS) {
        this.#plugins = plugins;
    }
    get plugins() {
        return this.#plugins;
    }
    transformQuery(node, queryId) {
        for (const plugin of this.#plugins) {
            const transformedNode = plugin.transformQuery({ node, queryId });
            // We need to do a runtime check here. There is no good way
            // to write types that enforce this constraint.
            if (transformedNode.kind === node.kind) {
                node = transformedNode;
            }
            else {
                throw new Error([
                    `KyselyPlugin.transformQuery must return a node`,
                    `of the same kind that was given to it.`,
                    `The plugin was given a ${node.kind}`,
                    `but it returned a ${transformedNode.kind}`,
                ].join(' '));
            }
        }
        return node;
    }
    async executeQuery(compiledQuery, queryId) {
        return await this.provideConnection(async (connection) => {
            const result = await connection.executeQuery(compiledQuery);
            const transformedResult = await this.#transformResult(result, queryId);
            // TODO: remove.
            warnOfOutdatedDriverOrPlugins(result, transformedResult);
            return transformedResult;
        });
    }
    async *stream(compiledQuery, chunkSize, queryId) {
        const connectionDefer = new Deferred();
        const connectionReleaseDefer = new Deferred();
        this.provideConnection(async (connection) => {
            connectionDefer.resolve(connection);
            // Lets wait until we don't need connection before returning here (returning releases connection)
            return await connectionReleaseDefer.promise;
        }).catch((ex) => connectionDefer.reject(ex));
        const connection = await connectionDefer.promise;
        try {
            for await (const result of connection.streamQuery(compiledQuery, chunkSize)) {
                yield await this.#transformResult(result, queryId);
            }
        }
        finally {
            connectionReleaseDefer.resolve();
        }
    }
    async #transformResult(result, queryId) {
        for (const plugin of this.#plugins) {
            result = await plugin.transformResult({ result, queryId });
        }
        return result;
    }
}
// TODO: remove.
function warnOfOutdatedDriverOrPlugins(result, transformedResult) {
    const { numAffectedRows } = result;
    if ((numAffectedRows === undefined &&
        result.numUpdatedOrDeletedRows === undefined) ||
        (numAffectedRows !== undefined &&
            transformedResult.numAffectedRows !== undefined)) {
        return;
    }
    logOnce('kysely:warning: outdated driver/plugin detected! QueryResult.numUpdatedOrDeletedRows is deprecated and will be removed in a future release.');
}

/// <reference types="./noop-query-executor.d.ts" />
/**
 * A {@link QueryExecutor} subclass that can be used when you don't
 * have a {@link QueryCompiler}, {@link ConnectionProvider} or any
 * other needed things to actually execute queries.
 */
class NoopQueryExecutor extends QueryExecutorBase {
    get adapter() {
        throw new Error('this query cannot be compiled to SQL');
    }
    compileQuery() {
        throw new Error('this query cannot be compiled to SQL');
    }
    provideConnection() {
        throw new Error('this query cannot be executed');
    }
    withConnectionProvider() {
        throw new Error('this query cannot have a connection provider');
    }
    withPlugin(plugin) {
        return new NoopQueryExecutor([...this.plugins, plugin]);
    }
    withPlugins(plugins) {
        return new NoopQueryExecutor([...this.plugins, ...plugins]);
    }
    withPluginAtFront(plugin) {
        return new NoopQueryExecutor([plugin, ...this.plugins]);
    }
    withoutPlugins() {
        return new NoopQueryExecutor([]);
    }
}
const NOOP_QUERY_EXECUTOR = new NoopQueryExecutor();

/// <reference types="./merge-result.d.ts" />
class MergeResult {
    numChangedRows;
    constructor(numChangedRows) {
        this.numChangedRows = numChangedRows;
    }
}

/// <reference types="./merge-query-builder.d.ts" />
class MergeQueryBuilder {
    #props;
    constructor(props) {
        this.#props = freeze(props);
    }
    /**
     * Changes a `merge into` query to an `merge top into` query.
     *
     * `top` clause is only supported by some dialects like MS SQL Server.
     *
     * ### Examples
     *
     * Affect 5 matched rows at most:
     *
     * ```ts
     * await db.mergeInto('person')
     *   .top(5)
     *   .using('pet', 'person.id', 'pet.owner_id')
     *   .whenMatched()
     *   .thenDelete()
     *   .execute()
     * ```
     *
     * The generated SQL (MS SQL Server):
     *
     * ```sql
     * merge top(5) into "person"
     * using "pet" on "person"."id" = "pet"."owner_id"
     * when matched then
     *   delete
     * ```
     *
     * Affect 50% of matched rows:
     *
     * ```ts
     * await db.mergeInto('person')
     *   .top(50, 'percent')
     *   .using('pet', 'person.id', 'pet.owner_id')
     *   .whenMatched()
     *   .thenDelete()
     *   .execute()
     * ```
     *
     * The generated SQL (MS SQL Server):
     *
     * ```sql
     * merge top(50) percent into "person"
     * using "pet" on "person"."id" = "pet"."owner_id"
     * when matched then
     *   delete
     * ```
     */
    top(expression, modifiers) {
        return new MergeQueryBuilder({
            ...this.#props,
            queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers)),
        });
    }
    using(...args) {
        return new WheneableMergeQueryBuilder({
            ...this.#props,
            queryNode: MergeQueryNode.cloneWithUsing(this.#props.queryNode, parseJoin('Using', args)),
        });
    }
    output(args) {
        return new MergeQueryBuilder({
            ...this.#props,
            queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectArg(args)),
        });
    }
    outputAll(table) {
        return new MergeQueryBuilder({
            ...this.#props,
            queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectAll(table)),
        });
    }
}
preventAwait(MergeQueryBuilder, "don't await MergeQueryBuilder instances directly. To execute the query you need to call `execute` when available.");
class WheneableMergeQueryBuilder {
    #props;
    constructor(props) {
        this.#props = freeze(props);
    }
    /**
     * See {@link MergeQueryBuilder.top}.
     */
    top(expression, modifiers) {
        return new WheneableMergeQueryBuilder({
            ...this.#props,
            queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers)),
        });
    }
    /**
     * Adds a simple `when matched` clause to the query.
     *
     * For a `when matched` clause with an `and` condition, see {@link whenMatchedAnd}.
     *
     * For a simple `when not matched` clause, see {@link whenNotMatched}.
     *
     * For a `when not matched` clause with an `and` condition, see {@link whenNotMatchedAnd}.
     *
     * ### Examples
     *
     * ```ts
     * const result = await db.mergeInto('person')
     *   .using('pet', 'person.id', 'pet.owner_id')
     *   .whenMatched()
     *   .thenDelete()
     *   .execute()
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * merge into "person"
     * using "pet" on "person"."id" = "pet"."owner_id"
     * when matched then
     *   delete
     * ```
     */
    whenMatched() {
        return this.#whenMatched([]);
    }
    whenMatchedAnd(...args) {
        return this.#whenMatched(args);
    }
    /**
     * Adds the `when matched` clause to the query with an `and` condition. But unlike
     * {@link whenMatchedAnd}, this method accepts a column reference as the 3rd argument.
     *
     * This method is similar to {@link SelectQueryBuilder.whereRef}, so see the documentation
     * for that method for more examples.
     */
    whenMatchedAndRef(lhs, op, rhs) {
        return this.#whenMatched([lhs, op, rhs], true);
    }
    #whenMatched(args, refRight) {
        return new MatchedThenableMergeQueryBuilder({
            ...this.#props,
            queryNode: MergeQueryNode.cloneWithWhen(this.#props.queryNode, parseMergeWhen({ isMatched: true }, args, refRight)),
        });
    }
    /**
     * Adds a simple `when not matched` clause to the query.
     *
     * For a `when not matched` clause with an `and` condition, see {@link whenNotMatchedAnd}.
     *
     * For a simple `when matched` clause, see {@link whenMatched}.
     *
     * For a `when matched` clause with an `and` condition, see {@link whenMatchedAnd}.
     *
     * ### Examples
     *
     * ```ts
     * const result = await db.mergeInto('person')
     *   .using('pet', 'person.id', 'pet.owner_id')
     *   .whenNotMatched()
     *   .thenInsertValues({
     *     first_name: 'John',
     *     last_name: 'Doe',
     *   })
     *   .execute()
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * merge into "person"
     * using "pet" on "person"."id" = "pet"."owner_id"
     * when not matched then
     *   insert ("first_name", "last_name") values ($1, $2)
     * ```
     */
    whenNotMatched() {
        return this.#whenNotMatched([]);
    }
    whenNotMatchedAnd(...args) {
        return this.#whenNotMatched(args);
    }
    /**
     * Adds the `when not matched` clause to the query with an `and` condition. But unlike
     * {@link whenNotMatchedAnd}, this method accepts a column reference as the 3rd argument.
     *
     * Unlike {@link whenMatchedAndRef}, you cannot reference columns from the target table.
     *
     * This method is similar to {@link SelectQueryBuilder.whereRef}, so see the documentation
     * for that method for more examples.
     */
    whenNotMatchedAndRef(lhs, op, rhs) {
        return this.#whenNotMatched([lhs, op, rhs], true);
    }
    /**
     * Adds a simple `when not matched by source` clause to the query.
     *
     * Supported in MS SQL Server.
     *
     * Similar to {@link whenNotMatched}, but returns a {@link MatchedThenableMergeQueryBuilder}.
     */
    whenNotMatchedBySource() {
        return this.#whenNotMatched([], false, true);
    }
    whenNotMatchedBySourceAnd(...args) {
        return this.#whenNotMatched(args, false, true);
    }
    /**
     * Adds the `when not matched by source` clause to the query with an `and` condition.
     *
     * Similar to {@link whenNotMatchedAndRef}, but you can reference columns from
     * the target table, and not from source table and returns a {@link MatchedThenableMergeQueryBuilder}.
     */
    whenNotMatchedBySourceAndRef(lhs, op, rhs) {
        return this.#whenNotMatched([lhs, op, rhs], true, true);
    }
    output(args) {
        return new WheneableMergeQueryBuilder({
            ...this.#props,
            queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectArg(args)),
        });
    }
    outputAll(table) {
        return new WheneableMergeQueryBuilder({
            ...this.#props,
            queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectAll(table)),
        });
    }
    #whenNotMatched(args, refRight = false, bySource = false) {
        const props = {
            ...this.#props,
            queryNode: MergeQueryNode.cloneWithWhen(this.#props.queryNode, parseMergeWhen({ isMatched: false, bySource }, args, refRight)),
        };
        const Builder = bySource
            ? MatchedThenableMergeQueryBuilder
            : NotMatchedThenableMergeQueryBuilder;
        return new Builder(props);
    }
    /**
     * Simply calls the provided function passing `this` as the only argument. `$call` returns
     * what the provided function returns.
     *
     * If you want to conditionally call a method on `this`, see
     * the {@link $if} method.
     *
     * ### Examples
     *
     * The next example uses a helper function `log` to log a query:
     *
     * ```ts
     * function log<T extends Compilable>(qb: T): T {
     *   console.log(qb.compile())
     *   return qb
     * }
     *
     * db.updateTable('person')
     *   .set(values)
     *   .$call(log)
     *   .execute()
     * ```
     */
    $call(func) {
        return func(this);
    }
    /**
     * Call `func(this)` if `condition` is true.
     *
     * This method is especially handy with optional selects. Any `returning` or `returningAll`
     * method calls add columns as optional fields to the output type when called inside
     * the `func` callback. This is because we can't know if those selections were actually
     * made before running the code.
     *
     * You can also call any other methods inside the callback.
     *
     * ### Examples
     *
     * ```ts
     * async function updatePerson(id: number, updates: UpdateablePerson, returnLastName: boolean) {
     *   return await db
     *     .updateTable('person')
     *     .set(updates)
     *     .where('id', '=', id)
     *     .returning(['id', 'first_name'])
     *     .$if(returnLastName, (qb) => qb.returning('last_name'))
     *     .executeTakeFirstOrThrow()
     * }
     * ```
     *
     * Any selections added inside the `if` callback will be added as optional fields to the
     * output type since we can't know if the selections were actually made before running
     * the code. In the example above the return type of the `updatePerson` function is:
     *
     * ```ts
     * {
     *   id: number
     *   first_name: string
     *   last_name?: string
     * }
     * ```
     */
    $if(condition, func) {
        if (condition) {
            return func(this);
        }
        return new WheneableMergeQueryBuilder({
            ...this.#props,
        });
    }
    toOperationNode() {
        return this.#props.executor.transformQuery(this.#props.queryNode, this.#props.queryId);
    }
    compile() {
        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
    }
    /**
     * Executes the query and returns an array of rows.
     *
     * Also see the {@link executeTakeFirst} and {@link executeTakeFirstOrThrow} methods.
     */
    async execute() {
        const compiledQuery = this.compile();
        const result = await this.#props.executor.executeQuery(compiledQuery, this.#props.queryId);
        if (compiledQuery.query.output &&
            this.#props.executor.adapter.supportsOutput) {
            return result.rows;
        }
        return [new MergeResult(result.numAffectedRows)];
    }
    /**
     * Executes the query and returns the first result or undefined if
     * the query returned no result.
     */
    async executeTakeFirst() {
        const [result] = await this.execute();
        return result;
    }
    /**
     * Executes the query and returns the first result or throws if
     * the query returned no result.
     *
     * By default an instance of {@link NoResultError} is thrown, but you can
     * provide a custom error class, or callback as the only argument to throw a different
     * error.
     */
    async executeTakeFirstOrThrow(errorConstructor = NoResultError) {
        const result = await this.executeTakeFirst();
        if (result === undefined) {
            const error = isNoResultErrorConstructor(errorConstructor)
                ? new errorConstructor(this.toOperationNode())
                : errorConstructor(this.toOperationNode());
            throw error;
        }
        return result;
    }
}
preventAwait(WheneableMergeQueryBuilder, "don't await WheneableMergeQueryBuilder instances directly. To execute the query you need to call `execute`.");
class MatchedThenableMergeQueryBuilder {
    #props;
    constructor(props) {
        this.#props = freeze(props);
    }
    /**
     * Performs the `delete` action.
     *
     * To perform the `do nothing` action, see {@link thenDoNothing}.
     *
     * To perform the `update` action, see {@link thenUpdate} or {@link thenUpdateSet}.
     *
     * ### Examples
     *
     * ```ts
     * const result = await db.mergeInto('person')
     *   .using('pet', 'person.id', 'pet.owner_id')
     *   .whenMatched()
     *   .thenDelete()
     *   .execute()
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * merge into "person"
     * using "pet" on "person"."id" = "pet"."owner_id"
     * when matched then
     *   delete
     * ```
     */
    thenDelete() {
        return new WheneableMergeQueryBuilder({
            ...this.#props,
            queryNode: MergeQueryNode.cloneWithThen(this.#props.queryNode, parseMergeThen('delete')),
        });
    }
    /**
     * Performs the `do nothing` action.
     *
     * This is supported in PostgreSQL.
     *
     * To perform the `delete` action, see {@link thenDelete}.
     *
     * To perform the `update` action, see {@link thenUpdate} or {@link thenUpdateSet}.
     *
     * ### Examples
     *
     * ```ts
     * const result = await db.mergeInto('person')
     *   .using('pet', 'person.id', 'pet.owner_id')
     *   .whenMatched()
     *   .thenDoNothing()
     *   .execute()
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * merge into "person"
     * using "pet" on "person"."id" = "pet"."owner_id"
     * when matched then
     *   do nothing
     * ```
     */
    thenDoNothing() {
        return new WheneableMergeQueryBuilder({
            ...this.#props,
            queryNode: MergeQueryNode.cloneWithThen(this.#props.queryNode, parseMergeThen('do nothing')),
        });
    }
    /**
     * Perform an `update` operation with a full-fledged {@link UpdateQueryBuilder}.
     * This is handy when multiple `set` invocations are needed.
     *
     * For a shorthand version of this method, see {@link thenUpdateSet}.
     *
     * To perform the `delete` action, see {@link thenDelete}.
     *
     * To perform the `do nothing` action, see {@link thenDoNothing}.
     *
     * ### Examples
     *
     * ```ts
     * import { sql } from 'kysely'
     *
     * const result = await db.mergeInto('person')
     *   .using('pet', 'person.id', 'pet.owner_id')
     *   .whenMatched()
     *   .thenUpdate((ub) => ub
     *     .set(sql`metadata['has_pets']`, 'Y')
     *     .set({
     *       updated_at: Date.now(),
     *     })
     *   )
     *   .execute()
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * merge into "person"
     * using "pet" on "person"."id" = "pet"."owner_id"
     * when matched then
     *   update set metadata['has_pets'] = $1, "updated_at" = $2
     * ```
     */
    thenUpdate(set) {
        return new WheneableMergeQueryBuilder({
            ...this.#props,
            queryNode: MergeQueryNode.cloneWithThen(this.#props.queryNode, parseMergeThen(set(new UpdateQueryBuilder({
                queryId: this.#props.queryId,
                executor: NOOP_QUERY_EXECUTOR,
                queryNode: UpdateQueryNode.createWithoutTable(),
            })))),
        });
    }
    thenUpdateSet(...args) {
        // @ts-ignore not sure how to type this so it won't complain about set(...args).
        return this.thenUpdate((ub) => ub.set(...args));
    }
}
preventAwait(MatchedThenableMergeQueryBuilder, "don't await MatchedThenableMergeQueryBuilder instances directly. To execute the query you need to call `execute` when available.");
class NotMatchedThenableMergeQueryBuilder {
    #props;
    constructor(props) {
        this.#props = freeze(props);
    }
    /**
     * Performs the `do nothing` action.
     *
     * This is supported in PostgreSQL.
     *
     * To perform the `insert` action, see {@link thenInsertValues}.
     *
     * ### Examples
     *
     * ```ts
     * const result = await db.mergeInto('person')
     *   .using('pet', 'person.id', 'pet.owner_id')
     *   .whenNotMatched()
     *   .thenDoNothing()
     *   .execute()
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * merge into "person"
     * using "pet" on "person"."id" = "pet"."owner_id"
     * when not matched then
     *   do nothing
     * ```
     */
    thenDoNothing() {
        return new WheneableMergeQueryBuilder({
            ...this.#props,
            queryNode: MergeQueryNode.cloneWithThen(this.#props.queryNode, parseMergeThen('do nothing')),
        });
    }
    thenInsertValues(insert) {
        const [columns, values] = parseInsertExpression(insert);
        return new WheneableMergeQueryBuilder({
            ...this.#props,
            queryNode: MergeQueryNode.cloneWithThen(this.#props.queryNode, parseMergeThen(InsertQueryNode.cloneWith(InsertQueryNode.createWithoutInto(), {
                columns,
                values,
            }))),
        });
    }
}
preventAwait(NotMatchedThenableMergeQueryBuilder, "don't await NotMatchedThenableMergeQueryBuilder instances directly. To execute the query you need to call `execute` when available.");

/// <reference types="./query-creator.d.ts" />
class QueryCreator {
    #props;
    constructor(props) {
        this.#props = freeze(props);
    }
    selectFrom(from) {
        return createSelectQueryBuilder({
            queryId: createQueryId(),
            executor: this.#props.executor,
            queryNode: SelectQueryNode.createFrom(parseTableExpressionOrList(from), this.#props.withNode),
        });
    }
    selectNoFrom(selection) {
        return createSelectQueryBuilder({
            queryId: createQueryId(),
            executor: this.#props.executor,
            queryNode: SelectQueryNode.cloneWithSelections(SelectQueryNode.create(this.#props.withNode), parseSelectArg(selection)),
        });
    }
    /**
     * Creates an insert query.
     *
     * The return value of this query is an instance of {@link InsertResult}. {@link InsertResult}
     * has the {@link InsertResult.insertId | insertId} field that holds the auto incremented id of
     * the inserted row if the db returned one.
     *
     * See the {@link InsertQueryBuilder.values | values} method for more info and examples. Also see
     * the {@link ReturningInterface.returning | returning} method for a way to return columns
     * on supported databases like PostgreSQL.
     *
     * ### Examples
     *
     * ```ts
     * const result = await db
     *   .insertInto('person')
     *   .values({
     *     first_name: 'Jennifer',
     *     last_name: 'Aniston'
     *   })
     *   .executeTakeFirst()
     *
     * console.log(result.insertId)
     * ```
     *
     * Some databases like PostgreSQL support the `returning` method:
     *
     * ```ts
     * const { id } = await db
     *   .insertInto('person')
     *   .values({
     *     first_name: 'Jennifer',
     *     last_name: 'Aniston'
     *   })
     *   .returning('id')
     *   .executeTakeFirst()
     * ```
     */
    insertInto(table) {
        return new InsertQueryBuilder({
            queryId: createQueryId(),
            executor: this.#props.executor,
            queryNode: InsertQueryNode.create(parseTable(table), this.#props.withNode),
        });
    }
    /**
     * Creates a replace query.
     *
     * A MySQL-only statement similar to {@link InsertQueryBuilder.onDuplicateKeyUpdate}
     * that deletes and inserts values on collision instead of updating existing rows.
     *
     * The return value of this query is an instance of {@link InsertResult}. {@link InsertResult}
     * has the {@link InsertResult.insertId | insertId} field that holds the auto incremented id of
     * the inserted row if the db returned one.
     *
     * See the {@link InsertQueryBuilder.values | values} method for more info and examples.
     *
     * ### Examples
     *
     * ```ts
     * const result = await db
     *   .replaceInto('person')
     *   .values({
     *     first_name: 'Jennifer',
     *     last_name: 'Aniston'
     *   })
     *   .executeTakeFirst()
     *
     * console.log(result.insertId)
     * ```
     */
    replaceInto(table) {
        return new InsertQueryBuilder({
            queryId: createQueryId(),
            executor: this.#props.executor,
            queryNode: InsertQueryNode.create(parseTable(table), this.#props.withNode, true),
        });
    }
    deleteFrom(tables) {
        return new DeleteQueryBuilder({
            queryId: createQueryId(),
            executor: this.#props.executor,
            queryNode: DeleteQueryNode.create(parseTableExpressionOrList(tables), this.#props.withNode),
        });
    }
    updateTable(table) {
        return new UpdateQueryBuilder({
            queryId: createQueryId(),
            executor: this.#props.executor,
            queryNode: UpdateQueryNode.create(parseTableExpression(table), this.#props.withNode),
        });
    }
    mergeInto(targetTable) {
        return new MergeQueryBuilder({
            queryId: createQueryId(),
            executor: this.#props.executor,
            queryNode: MergeQueryNode.create(parseAliasedTable(targetTable), this.#props.withNode),
        });
    }
    /**
     * Creates a `with` query (Common Table Expression).
     *
     * ### Examples
     *
     * <!-- siteExample("cte", "Simple selects", 10) -->
     *
     * Common table expressions (CTE) are a great way to modularize complex queries.
     * Essentially they allow you to run multiple separate queries within a
     * single roundtrip to the DB.
     *
     * Since CTEs are a part of the main query, query optimizers inside DB
     * engines are able to optimize the overall query. For example, postgres
     * is able to inline the CTEs inside the using queries if it decides it's
     * faster.
     *
     * ```ts
     * const result = await db
     *   // Create a CTE called `jennifers` that selects all
     *   // persons named 'Jennifer'.
     *   .with('jennifers', (db) => db
     *     .selectFrom('person')
     *     .where('first_name', '=', 'Jennifer')
     *     .select(['id', 'age'])
     *   )
     *   // Select all rows from the `jennifers` CTE and
     *   // further filter it.
     *   .with('adult_jennifers', (db) => db
     *     .selectFrom('jennifers')
     *     .where('age', '>', 18)
     *     .select(['id', 'age'])
     *   )
     *   // Finally select all adult jennifers that are
     *   // also younger than 60.
     *   .selectFrom('adult_jennifers')
     *   .where('age', '<', 60)
     *   .selectAll()
     *   .execute()
     * ```
     *
     * <!-- siteExample("cte", "Inserts, updates and deletions", 20) -->
     *
     * Some databases like postgres also allow you to run other queries than selects
     * in CTEs. On these databases CTEs are extremely powerful:
     *
     * ```ts
     * const result = await db
     *   .with('new_person', (db) => db
     *     .insertInto('person')
     *     .values({
     *       first_name: 'Jennifer',
     *       age: 35,
     *     })
     *     .returning('id')
     *   )
     *   .with('new_pet', (db) => db
     *     .insertInto('pet')
     *     .values({
     *       name: 'Doggo',
     *       species: 'dog',
     *       is_favorite: true,
     *       // Use the id of the person we just inserted.
     *       owner_id: db
     *         .selectFrom('new_person')
     *         .select('id')
     *     })
     *     .returning('id')
     *   )
     *   .selectFrom(['new_person', 'new_pet'])
     *   .select([
     *     'new_person.id as person_id',
     *     'new_pet.id as pet_id'
     *   ])
     *   .execute()
     * ```
     *
     * The CTE name can optionally specify column names in addition to
     * a name. In that case Kysely requires the expression to retun
     * rows with the same columns.
     *
     * ```ts
     * await db
     *   .with('jennifers(id, age)', (db) => db
     *     .selectFrom('person')
     *     .where('first_name', '=', 'Jennifer')
     *     // This is ok since we return columns with the same
     *     // names as specified by `jennifers(id, age)`.
     *     .select(['id', 'age'])
     *   )
     *   .selectFrom('jennifers')
     *   .selectAll()
     *   .execute()
     * ```
     *
     * The first argument can also be a callback. The callback is passed
     * a `CTEBuilder` instance that can be used to configure the CTE:
     *
     * ```ts
     * await db
     *   .with(
     *     (cte) => cte('jennifers').materialized(),
     *     (db) => db
     *       .selectFrom('person')
     *       .where('first_name', '=', 'Jennifer')
     *       .select(['id', 'age'])
     *   )
     *   .selectFrom('jennifers')
     *   .selectAll()
     *   .execute()
     * ```
     */
    with(nameOrBuilder, expression) {
        const cte = parseCommonTableExpression(nameOrBuilder, expression);
        return new QueryCreator({
            ...this.#props,
            withNode: this.#props.withNode
                ? WithNode.cloneWithExpression(this.#props.withNode, cte)
                : WithNode.create(cte),
        });
    }
    /**
     * Creates a recursive `with` query (Common Table Expression).
     *
     * Note that recursiveness is a property of the whole `with` statement.
     * You cannot have recursive and non-recursive CTEs in a same `with` statement.
     * Therefore the recursiveness is determined by the **first** `with` or
     * `withRecusive` call you make.
     *
     * See the {@link with} method for examples and more documentation.
     */
    withRecursive(nameOrBuilder, expression) {
        const cte = parseCommonTableExpression(nameOrBuilder, expression);
        return new QueryCreator({
            ...this.#props,
            withNode: this.#props.withNode
                ? WithNode.cloneWithExpression(this.#props.withNode, cte)
                : WithNode.create(cte, { recursive: true }),
        });
    }
    /**
     * Returns a copy of this query creator instance with the given plugin installed.
     */
    withPlugin(plugin) {
        return new QueryCreator({
            ...this.#props,
            executor: this.#props.executor.withPlugin(plugin),
        });
    }
    /**
     * Returns a copy of this query creator instance without any plugins.
     */
    withoutPlugins() {
        return new QueryCreator({
            ...this.#props,
            executor: this.#props.executor.withoutPlugins(),
        });
    }
    /**
     * Sets the schema to be used for all table references that don't explicitly
     * specify a schema.
     *
     * This only affects the query created through the builder returned from
     * this method and doesn't modify the `db` instance.
     *
     * See [this recipe](https://github.com/koskimas/kysely/tree/master/site/docs/recipes/schemas.md)
     * for a more detailed explanation.
     *
     * ### Examples
     *
     * ```
     * await db
     *   .withSchema('mammals')
     *   .selectFrom('pet')
     *   .selectAll()
     *   .innerJoin('public.person', 'public.person.id', 'pet.owner_id')
     *   .execute()
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * select * from "mammals"."pet"
     * inner join "public"."person"
     * on "public"."person"."id" = "mammals"."pet"."owner_id"
     * ```
     *
     * `withSchema` is smart enough to not add schema for aliases,
     * common table expressions or other places where the schema
     * doesn't belong to:
     *
     * ```
     * await db
     *   .withSchema('mammals')
     *   .selectFrom('pet as p')
     *   .select('p.name')
     *   .execute()
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * select "p"."name" from "mammals"."pet" as "p"
     * ```
     */
    withSchema(schema) {
        return new QueryCreator({
            ...this.#props,
            executor: this.#props.executor.withPluginAtFront(new WithSchemaPlugin(schema)),
        });
    }
}

/// <reference types="./parse-utils.d.ts" />
function createQueryCreator() {
    return new QueryCreator({
        executor: NOOP_QUERY_EXECUTOR,
    });
}
function createJoinBuilder(joinType, table) {
    return new JoinBuilder({
        joinNode: JoinNode.create(joinType, parseTableExpression(table)),
    });
}
function createOverBuilder() {
    return new OverBuilder({
        overNode: OverNode.create(),
    });
}

/// <reference types="./join-parser.d.ts" />
function parseJoin(joinType, args) {
    if (args.length === 3) {
        return parseSingleOnJoin(joinType, args[0], args[1], args[2]);
    }
    else if (args.length === 2) {
        return parseCallbackJoin(joinType, args[0], args[1]);
    }
    else {
        throw new Error('not implemented');
    }
}
function parseCallbackJoin(joinType, from, callback) {
    return callback(createJoinBuilder(joinType, from)).toOperationNode();
}
function parseSingleOnJoin(joinType, from, lhsColumn, rhsColumn) {
    return JoinNode.createWithOn(joinType, parseTableExpression(from), parseReferentialBinaryOperation(lhsColumn, '=', rhsColumn));
}

/// <reference types="./offset-node.d.ts" />
/**
 * @internal
 */
const OffsetNode = freeze({
    is(node) {
        return node.kind === 'OffsetNode';
    },
    create(offset) {
        return freeze({
            kind: 'OffsetNode',
            offset,
        });
    },
});

/// <reference types="./group-by-item-node.d.ts" />
/**
 * @internal
 */
const GroupByItemNode = freeze({
    is(node) {
        return node.kind === 'GroupByItemNode';
    },
    create(groupBy) {
        return freeze({
            kind: 'GroupByItemNode',
            groupBy,
        });
    },
});

/// <reference types="./group-by-parser.d.ts" />
function parseGroupBy(groupBy) {
    groupBy = isFunction(groupBy) ? groupBy(expressionBuilder()) : groupBy;
    return parseReferenceExpressionOrList(groupBy).map(GroupByItemNode.create);
}

/// <reference types="./set-operation-node.d.ts" />
/**
 * @internal
 */
const SetOperationNode = freeze({
    is(node) {
        return node.kind === 'SetOperationNode';
    },
    create(operator, expression, all) {
        return freeze({
            kind: 'SetOperationNode',
            operator,
            expression,
            all,
        });
    },
});

/// <reference types="./set-operation-parser.d.ts" />
function parseSetOperations(operator, expression, all) {
    if (isFunction(expression)) {
        expression = expression(createExpressionBuilder());
    }
    if (!isReadonlyArray(expression)) {
        expression = [expression];
    }
    return expression.map((expr) => SetOperationNode.create(operator, parseExpression(expr), all));
}

/// <reference types="./expression-wrapper.d.ts" />
class ExpressionWrapper {
    #node;
    constructor(node) {
        this.#node = node;
    }
    /** @private */
    get expressionType() {
        return undefined;
    }
    as(alias) {
        return new AliasedExpressionWrapper(this, alias);
    }
    or(...args) {
        return new OrWrapper(OrNode.create(this.#node, parseValueBinaryOperationOrExpression(args)));
    }
    and(...args) {
        return new AndWrapper(AndNode.create(this.#node, parseValueBinaryOperationOrExpression(args)));
    }
    /**
     * Change the output type of the expression.
     *
     * This method call doesn't change the SQL in any way. This methods simply
     * returns a copy of this `ExpressionWrapper` with a new output type.
     */
    $castTo() {
        return new ExpressionWrapper(this.#node);
    }
    /**
     * Omit null from the expression's type.
     *
     * This function can be useful in cases where you know an expression can't be
     * null, but Kysely is unable to infer it.
     *
     * This method call doesn't change the SQL in any way. This methods simply
     * returns a copy of `this` with a new output type.
     */
    $notNull() {
        return new ExpressionWrapper(this.#node);
    }
    toOperationNode() {
        return this.#node;
    }
}
class AliasedExpressionWrapper {
    #expr;
    #alias;
    constructor(expr, alias) {
        this.#expr = expr;
        this.#alias = alias;
    }
    /** @private */
    get expression() {
        return this.#expr;
    }
    /** @private */
    get alias() {
        return this.#alias;
    }
    toOperationNode() {
        return AliasNode.create(this.#expr.toOperationNode(), isOperationNodeSource(this.#alias)
            ? this.#alias.toOperationNode()
            : IdentifierNode.create(this.#alias));
    }
}
class OrWrapper {
    #node;
    constructor(node) {
        this.#node = node;
    }
    /** @private */
    get expressionType() {
        return undefined;
    }
    as(alias) {
        return new AliasedExpressionWrapper(this, alias);
    }
    or(...args) {
        return new OrWrapper(OrNode.create(this.#node, parseValueBinaryOperationOrExpression(args)));
    }
    /**
     * Change the output type of the expression.
     *
     * This method call doesn't change the SQL in any way. This methods simply
     * returns a copy of this `OrWrapper` with a new output type.
     */
    $castTo() {
        return new OrWrapper(this.#node);
    }
    toOperationNode() {
        return ParensNode.create(this.#node);
    }
}
class AndWrapper {
    #node;
    constructor(node) {
        this.#node = node;
    }
    /** @private */
    get expressionType() {
        return undefined;
    }
    as(alias) {
        return new AliasedExpressionWrapper(this, alias);
    }
    and(...args) {
        return new AndWrapper(AndNode.create(this.#node, parseValueBinaryOperationOrExpression(args)));
    }
    /**
     * Change the output type of the expression.
     *
     * This method call doesn't change the SQL in any way. This methods simply
     * returns a copy of this `AndWrapper` with a new output type.
     */
    $castTo() {
        return new AndWrapper(this.#node);
    }
    toOperationNode() {
        return ParensNode.create(this.#node);
    }
}

/// <reference types="./fetch-node.d.ts" />
/**
 * @internal
 */
const FetchNode = {
    is(node) {
        return node.kind === 'FetchNode';
    },
    create(rowCount, modifier) {
        return {
            kind: 'FetchNode',
            rowCount: ValueNode.create(rowCount),
            modifier,
        };
    },
};

/// <reference types="./fetch-parser.d.ts" />
function parseFetch(rowCount, modifier) {
    if (!isNumber(rowCount) && !isBigInt(rowCount)) {
        throw new Error(`Invalid fetch row count: ${rowCount}`);
    }
    if (!isFetchModifier(modifier)) {
        throw new Error(`Invalid fetch modifier: ${modifier}`);
    }
    return FetchNode.create(rowCount, modifier);
}
function isFetchModifier(value) {
    return value === 'only' || value === 'with ties';
}

/// <reference types="./select-query-builder.d.ts" />
class SelectQueryBuilderImpl {
    #props;
    constructor(props) {
        this.#props = freeze(props);
    }
    get expressionType() {
        return undefined;
    }
    get isSelectQueryBuilder() {
        return true;
    }
    where(...args) {
        return new SelectQueryBuilderImpl({
            ...this.#props,
            queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseValueBinaryOperationOrExpression(args)),
        });
    }
    whereRef(lhs, op, rhs) {
        return new SelectQueryBuilderImpl({
            ...this.#props,
            queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseReferentialBinaryOperation(lhs, op, rhs)),
        });
    }
    having(...args) {
        return new SelectQueryBuilderImpl({
            ...this.#props,
            queryNode: SelectQueryNode.cloneWithHaving(this.#props.queryNode, parseValueBinaryOperationOrExpression(args)),
        });
    }
    havingRef(lhs, op, rhs) {
        return new SelectQueryBuilderImpl({
            ...this.#props,
            queryNode: SelectQueryNode.cloneWithHaving(this.#props.queryNode, parseReferentialBinaryOperation(lhs, op, rhs)),
        });
    }
    select(selection) {
        return new SelectQueryBuilderImpl({
            ...this.#props,
            queryNode: SelectQueryNode.cloneWithSelections(this.#props.queryNode, parseSelectArg(selection)),
        });
    }
    distinctOn(selection) {
        return new SelectQueryBuilderImpl({
            ...this.#props,
            queryNode: SelectQueryNode.cloneWithDistinctOn(this.#props.queryNode, parseReferenceExpressionOrList(selection)),
        });
    }
    modifyFront(modifier) {
        return new SelectQueryBuilderImpl({
            ...this.#props,
            queryNode: SelectQueryNode.cloneWithFrontModifier(this.#props.queryNode, SelectModifierNode.createWithExpression(modifier.toOperationNode())),
        });
    }
    modifyEnd(modifier) {
        return new SelectQueryBuilderImpl({
            ...this.#props,
            queryNode: SelectQueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.createWithExpression(modifier.toOperationNode())),
        });
    }
    distinct() {
        return new SelectQueryBuilderImpl({
            ...this.#props,
            queryNode: SelectQueryNode.cloneWithFrontModifier(this.#props.queryNode, SelectModifierNode.create('Distinct')),
        });
    }
    forUpdate(of) {
        return new SelectQueryBuilderImpl({
            ...this.#props,
            queryNode: SelectQueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create('ForUpdate', of ? asArray(of).map(parseTable) : undefined)),
        });
    }
    forShare(of) {
        return new SelectQueryBuilderImpl({
            ...this.#props,
            queryNode: SelectQueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create('ForShare', of ? asArray(of).map(parseTable) : undefined)),
        });
    }
    forKeyShare(of) {
        return new SelectQueryBuilderImpl({
            ...this.#props,
            queryNode: SelectQueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create('ForKeyShare', of ? asArray(of).map(parseTable) : undefined)),
        });
    }
    forNoKeyUpdate(of) {
        return new SelectQueryBuilderImpl({
            ...this.#props,
            queryNode: SelectQueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create('ForNoKeyUpdate', of ? asArray(of).map(parseTable) : undefined)),
        });
    }
    skipLocked() {
        return new SelectQueryBuilderImpl({
            ...this.#props,
            queryNode: SelectQueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create('SkipLocked')),
        });
    }
    noWait() {
        return new SelectQueryBuilderImpl({
            ...this.#props,
            queryNode: SelectQueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create('NoWait')),
        });
    }
    selectAll(table) {
        return new SelectQueryBuilderImpl({
            ...this.#props,
            queryNode: SelectQueryNode.cloneWithSelections(this.#props.queryNode, parseSelectAll(table)),
        });
    }
    innerJoin(...args) {
        return new SelectQueryBuilderImpl({
            ...this.#props,
            queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin('InnerJoin', args)),
        });
    }
    leftJoin(...args) {
        return new SelectQueryBuilderImpl({
            ...this.#props,
            queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin('LeftJoin', args)),
        });
    }
    rightJoin(...args) {
        return new SelectQueryBuilderImpl({
            ...this.#props,
            queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin('RightJoin', args)),
        });
    }
    fullJoin(...args) {
        return new SelectQueryBuilderImpl({
            ...this.#props,
            queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin('FullJoin', args)),
        });
    }
    innerJoinLateral(...args) {
        return new SelectQueryBuilderImpl({
            ...this.#props,
            queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin('LateralInnerJoin', args)),
        });
    }
    leftJoinLateral(...args) {
        return new SelectQueryBuilderImpl({
            ...this.#props,
            queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin('LateralLeftJoin', args)),
        });
    }
    orderBy(...args) {
        return new SelectQueryBuilderImpl({
            ...this.#props,
            queryNode: SelectQueryNode.cloneWithOrderByItems(this.#props.queryNode, parseOrderBy(args)),
        });
    }
    groupBy(groupBy) {
        return new SelectQueryBuilderImpl({
            ...this.#props,
            queryNode: SelectQueryNode.cloneWithGroupByItems(this.#props.queryNode, parseGroupBy(groupBy)),
        });
    }
    limit(limit) {
        return new SelectQueryBuilderImpl({
            ...this.#props,
            queryNode: SelectQueryNode.cloneWithLimit(this.#props.queryNode, LimitNode.create(parseValueExpression(limit))),
        });
    }
    offset(offset) {
        return new SelectQueryBuilderImpl({
            ...this.#props,
            queryNode: SelectQueryNode.cloneWithOffset(this.#props.queryNode, OffsetNode.create(parseValueExpression(offset))),
        });
    }
    fetch(rowCount, modifier = 'only') {
        return new SelectQueryBuilderImpl({
            ...this.#props,
            queryNode: SelectQueryNode.cloneWithFetch(this.#props.queryNode, parseFetch(rowCount, modifier)),
        });
    }
    top(expression, modifiers) {
        return new SelectQueryBuilderImpl({
            ...this.#props,
            queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers)),
        });
    }
    union(expression) {
        return new SelectQueryBuilderImpl({
            ...this.#props,
            queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations('union', expression, false)),
        });
    }
    unionAll(expression) {
        return new SelectQueryBuilderImpl({
            ...this.#props,
            queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations('union', expression, true)),
        });
    }
    intersect(expression) {
        return new SelectQueryBuilderImpl({
            ...this.#props,
            queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations('intersect', expression, false)),
        });
    }
    intersectAll(expression) {
        return new SelectQueryBuilderImpl({
            ...this.#props,
            queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations('intersect', expression, true)),
        });
    }
    except(expression) {
        return new SelectQueryBuilderImpl({
            ...this.#props,
            queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations('except', expression, false)),
        });
    }
    exceptAll(expression) {
        return new SelectQueryBuilderImpl({
            ...this.#props,
            queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations('except', expression, true)),
        });
    }
    as(alias) {
        return new AliasedSelectQueryBuilderImpl(this, alias);
    }
    clearSelect() {
        return new SelectQueryBuilderImpl({
            ...this.#props,
            queryNode: SelectQueryNode.cloneWithoutSelections(this.#props.queryNode),
        });
    }
    clearWhere() {
        return new SelectQueryBuilderImpl({
            ...this.#props,
            queryNode: QueryNode.cloneWithoutWhere(this.#props.queryNode),
        });
    }
    clearLimit() {
        return new SelectQueryBuilderImpl({
            ...this.#props,
            queryNode: SelectQueryNode.cloneWithoutLimit(this.#props.queryNode),
        });
    }
    clearOffset() {
        return new SelectQueryBuilderImpl({
            ...this.#props,
            queryNode: SelectQueryNode.cloneWithoutOffset(this.#props.queryNode),
        });
    }
    clearOrderBy() {
        return new SelectQueryBuilderImpl({
            ...this.#props,
            queryNode: SelectQueryNode.cloneWithoutOrderBy(this.#props.queryNode),
        });
    }
    clearGroupBy() {
        return new SelectQueryBuilderImpl({
            ...this.#props,
            queryNode: SelectQueryNode.cloneWithoutGroupBy(this.#props.queryNode),
        });
    }
    $call(func) {
        return func(this);
    }
    $if(condition, func) {
        if (condition) {
            return func(this);
        }
        return new SelectQueryBuilderImpl({
            ...this.#props,
        });
    }
    $castTo() {
        return new SelectQueryBuilderImpl(this.#props);
    }
    $narrowType() {
        return new SelectQueryBuilderImpl(this.#props);
    }
    $assertType() {
        return new SelectQueryBuilderImpl(this.#props);
    }
    $asTuple() {
        return new ExpressionWrapper(this.toOperationNode());
    }
    withPlugin(plugin) {
        return new SelectQueryBuilderImpl({
            ...this.#props,
            executor: this.#props.executor.withPlugin(plugin),
        });
    }
    toOperationNode() {
        return this.#props.executor.transformQuery(this.#props.queryNode, this.#props.queryId);
    }
    compile() {
        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
    }
    async execute() {
        const compiledQuery = this.compile();
        const result = await this.#props.executor.executeQuery(compiledQuery, this.#props.queryId);
        return result.rows;
    }
    async executeTakeFirst() {
        const [result] = await this.execute();
        return result;
    }
    async executeTakeFirstOrThrow(errorConstructor = NoResultError) {
        const result = await this.executeTakeFirst();
        if (result === undefined) {
            const error = isNoResultErrorConstructor(errorConstructor)
                ? new errorConstructor(this.toOperationNode())
                : errorConstructor(this.toOperationNode());
            throw error;
        }
        return result;
    }
    async *stream(chunkSize = 100) {
        const compiledQuery = this.compile();
        const stream = this.#props.executor.stream(compiledQuery, chunkSize, this.#props.queryId);
        for await (const item of stream) {
            yield* item.rows;
        }
    }
    async explain(format, options) {
        const builder = new SelectQueryBuilderImpl({
            ...this.#props,
            queryNode: QueryNode.cloneWithExplain(this.#props.queryNode, format, options),
        });
        return await builder.execute();
    }
}
preventAwait(SelectQueryBuilderImpl, "don't await SelectQueryBuilder instances directly. To execute the query you need to call `execute` or `executeTakeFirst`.");
function createSelectQueryBuilder(props) {
    return new SelectQueryBuilderImpl(props);
}
/**
 * {@link SelectQueryBuilder} with an alias. The result of calling {@link SelectQueryBuilder.as}.
 */
class AliasedSelectQueryBuilderImpl {
    #queryBuilder;
    #alias;
    constructor(queryBuilder, alias) {
        this.#queryBuilder = queryBuilder;
        this.#alias = alias;
    }
    get expression() {
        return this.#queryBuilder;
    }
    get alias() {
        return this.#alias;
    }
    get isAliasedSelectQueryBuilder() {
        return true;
    }
    toOperationNode() {
        return AliasNode.create(this.#queryBuilder.toOperationNode(), IdentifierNode.create(this.#alias));
    }
}
preventAwait(AliasedSelectQueryBuilderImpl, "don't await AliasedSelectQueryBuilder instances directly. AliasedSelectQueryBuilder should never be executed directly since it's always a part of another query.");

/// <reference types="./aggregate-function-node.d.ts" />
/**
 * @internal
 */
const AggregateFunctionNode = freeze({
    is(node) {
        return node.kind === 'AggregateFunctionNode';
    },
    create(aggregateFunction, aggregated = []) {
        return freeze({
            kind: 'AggregateFunctionNode',
            func: aggregateFunction,
            aggregated,
        });
    },
    cloneWithDistinct(aggregateFunctionNode) {
        return freeze({
            ...aggregateFunctionNode,
            distinct: true,
        });
    },
    cloneWithFilter(aggregateFunctionNode, filter) {
        return freeze({
            ...aggregateFunctionNode,
            filter: aggregateFunctionNode.filter
                ? WhereNode.cloneWithOperation(aggregateFunctionNode.filter, 'And', filter)
                : WhereNode.create(filter),
        });
    },
    cloneWithOrFilter(aggregateFunctionNode, filter) {
        return freeze({
            ...aggregateFunctionNode,
            filter: aggregateFunctionNode.filter
                ? WhereNode.cloneWithOperation(aggregateFunctionNode.filter, 'Or', filter)
                : WhereNode.create(filter),
        });
    },
    cloneWithOver(aggregateFunctionNode, over) {
        return freeze({
            ...aggregateFunctionNode,
            over,
        });
    },
});

/// <reference types="./function-node.d.ts" />
/**
 * @internal
 */
const FunctionNode = freeze({
    is(node) {
        return node.kind === 'FunctionNode';
    },
    create(func, args) {
        return freeze({
            kind: 'FunctionNode',
            func,
            arguments: args,
        });
    },
});

/// <reference types="./aggregate-function-builder.d.ts" />
class AggregateFunctionBuilder {
    #props;
    constructor(props) {
        this.#props = freeze(props);
    }
    /** @private */
    get expressionType() {
        return undefined;
    }
    /**
     * Returns an aliased version of the function.
     *
     * In addition to slapping `as "the_alias"` to the end of the SQL,
     * this method also provides strict typing:
     *
     * ```ts
     * const result = await db
     *   .selectFrom('person')
     *   .select(
     *     (eb) => eb.fn.count<number>('id').as('person_count')
     *   )
     *   .executeTakeFirstOrThrow()
     *
     * // `person_count: number` field exists in the result type.
     * console.log(result.person_count)
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * select count("id") as "person_count"
     * from "person"
     * ```
     */
    as(alias) {
        return new AliasedAggregateFunctionBuilder(this, alias);
    }
    /**
     * Adds a `distinct` clause inside the function.
     *
     * ### Examples
     *
     * ```ts
     * const result = await db
     *   .selectFrom('person')
     *   .select((eb) =>
     *     eb.fn.count<number>('first_name').distinct().as('first_name_count')
     *   )
     *   .executeTakeFirstOrThrow()
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * select count(distinct "first_name") as "first_name_count"
     * from "person"
     * ```
     */
    distinct() {
        return new AggregateFunctionBuilder({
            ...this.#props,
            aggregateFunctionNode: AggregateFunctionNode.cloneWithDistinct(this.#props.aggregateFunctionNode),
        });
    }
    filterWhere(...args) {
        return new AggregateFunctionBuilder({
            ...this.#props,
            aggregateFunctionNode: AggregateFunctionNode.cloneWithFilter(this.#props.aggregateFunctionNode, parseValueBinaryOperationOrExpression(args)),
        });
    }
    /**
     * Adds a `filter` clause with a nested `where` clause after the function, where
     * both sides of the operator are references to columns.
     *
     * Similar to {@link WhereInterface}'s `whereRef` method.
     *
     * ### Examples
     *
     * Count people with same first and last names versus general public:
     *
     * ```ts
     * const result = await db
     *   .selectFrom('person')
     *   .select((eb) => [
     *     eb.fn
     *       .count<number>('id')
     *       .filterWhereRef('first_name', '=', 'last_name')
     *       .as('repeat_name_count'),
     *     eb.fn.count<number>('id').as('total_count'),
     *   ])
     *   .executeTakeFirstOrThrow()
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * select
     *   count("id") filter(where "first_name" = "last_name") as "repeat_name_count",
     *   count("id") as "total_count"
     * from "person"
     * ```
     */
    filterWhereRef(lhs, op, rhs) {
        return new AggregateFunctionBuilder({
            ...this.#props,
            aggregateFunctionNode: AggregateFunctionNode.cloneWithFilter(this.#props.aggregateFunctionNode, parseReferentialBinaryOperation(lhs, op, rhs)),
        });
    }
    /**
     * Adds an `over` clause (window functions) after the function.
     *
     * ### Examples
     *
     * ```ts
     * const result = await db
     *   .selectFrom('person')
     *   .select(
     *     (eb) => eb.fn.avg<number>('age').over().as('average_age')
     *   )
     *   .execute()
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * select avg("age") over() as "average_age"
     * from "person"
     * ```
     *
     * Also supports passing a callback that returns an over builder,
     * allowing to add partition by and sort by clauses inside over.
     *
     * ```ts
     * const result = await db
     *   .selectFrom('person')
     *   .select(
     *     (eb) => eb.fn.avg<number>('age').over(
     *       ob => ob.partitionBy('last_name').orderBy('first_name', 'asc')
     *     ).as('average_age')
     *   )
     *   .execute()
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * select avg("age") over(partition by "last_name" order by "first_name" asc) as "average_age"
     * from "person"
     * ```
     */
    over(over) {
        const builder = createOverBuilder();
        return new AggregateFunctionBuilder({
            ...this.#props,
            aggregateFunctionNode: AggregateFunctionNode.cloneWithOver(this.#props.aggregateFunctionNode, (over ? over(builder) : builder).toOperationNode()),
        });
    }
    /**
     * Simply calls the provided function passing `this` as the only argument. `$call` returns
     * what the provided function returns.
     */
    $call(func) {
        return func(this);
    }
    /**
     * Casts the expression to the given type.
     *
     * This method call doesn't change the SQL in any way. This methods simply
     * returns a copy of this `AggregateFunctionBuilder` with a new output type.
     */
    $castTo() {
        return new AggregateFunctionBuilder(this.#props);
    }
    /**
     * Omit null from the expression's type.
     *
     * This function can be useful in cases where you know an expression can't be
     * null, but Kysely is unable to infer it.
     *
     * This method call doesn't change the SQL in any way. This methods simply
     * returns a copy of `this` with a new output type.
     */
    $notNull() {
        return new AggregateFunctionBuilder(this.#props);
    }
    toOperationNode() {
        return this.#props.aggregateFunctionNode;
    }
}
preventAwait(AggregateFunctionBuilder, "don't await AggregateFunctionBuilder instances. They are never executed directly and are always just a part of a query.");
/**
 * {@link AggregateFunctionBuilder} with an alias. The result of calling {@link AggregateFunctionBuilder.as}.
 */
class AliasedAggregateFunctionBuilder {
    #aggregateFunctionBuilder;
    #alias;
    constructor(aggregateFunctionBuilder, alias) {
        this.#aggregateFunctionBuilder = aggregateFunctionBuilder;
        this.#alias = alias;
    }
    /** @private */
    get expression() {
        return this.#aggregateFunctionBuilder;
    }
    /** @private */
    get alias() {
        return this.#alias;
    }
    toOperationNode() {
        return AliasNode.create(this.#aggregateFunctionBuilder.toOperationNode(), IdentifierNode.create(this.#alias));
    }
}

/// <reference types="./function-module.d.ts" />
function createFunctionModule() {
    const fn = (name, args) => {
        return new ExpressionWrapper(FunctionNode.create(name, parseReferenceExpressionOrList(args ?? [])));
    };
    const agg = (name, args) => {
        return new AggregateFunctionBuilder({
            aggregateFunctionNode: AggregateFunctionNode.create(name, args ? parseReferenceExpressionOrList(args) : undefined),
        });
    };
    return Object.assign(fn, {
        agg,
        avg(column) {
            return agg('avg', [column]);
        },
        coalesce(...values) {
            return fn('coalesce', values);
        },
        count(column) {
            return agg('count', [column]);
        },
        countAll(table) {
            return new AggregateFunctionBuilder({
                aggregateFunctionNode: AggregateFunctionNode.create('count', parseSelectAll(table)),
            });
        },
        max(column) {
            return agg('max', [column]);
        },
        min(column) {
            return agg('min', [column]);
        },
        sum(column) {
            return agg('sum', [column]);
        },
        any(column) {
            return fn('any', [column]);
        },
        jsonAgg(table) {
            return new AggregateFunctionBuilder({
                aggregateFunctionNode: AggregateFunctionNode.create('json_agg', [
                    isString(table) ? parseTable(table) : table.toOperationNode(),
                ]),
            });
        },
        toJson(table) {
            return new ExpressionWrapper(FunctionNode.create('to_json', [
                isString(table) ? parseTable(table) : table.toOperationNode(),
            ]));
        },
    });
}

/// <reference types="./unary-operation-node.d.ts" />
/**
 * @internal
 */
const UnaryOperationNode = freeze({
    is(node) {
        return node.kind === 'UnaryOperationNode';
    },
    create(operator, operand) {
        return freeze({
            kind: 'UnaryOperationNode',
            operator,
            operand,
        });
    },
});

/// <reference types="./unary-operation-parser.d.ts" />
function parseUnaryOperation(operator, operand) {
    return UnaryOperationNode.create(OperatorNode.create(operator), parseReferenceExpression(operand));
}

/// <reference types="./case-node.d.ts" />
/**
 * @internal
 */
const CaseNode = freeze({
    is(node) {
        return node.kind === 'CaseNode';
    },
    create(value) {
        return freeze({
            kind: 'CaseNode',
            value,
        });
    },
    cloneWithWhen(caseNode, when) {
        return freeze({
            ...caseNode,
            when: freeze(caseNode.when ? [...caseNode.when, when] : [when]),
        });
    },
    cloneWithThen(caseNode, then) {
        return freeze({
            ...caseNode,
            when: caseNode.when
                ? freeze([
                    ...caseNode.when.slice(0, -1),
                    WhenNode.cloneWithResult(caseNode.when[caseNode.when.length - 1], then),
                ])
                : undefined,
        });
    },
    cloneWith(caseNode, props) {
        return freeze({
            ...caseNode,
            ...props,
        });
    },
});

/// <reference types="./case-builder.d.ts" />
class CaseBuilder {
    #props;
    constructor(props) {
        this.#props = freeze(props);
    }
    when(...args) {
        return new CaseThenBuilder({
            ...this.#props,
            node: CaseNode.cloneWithWhen(this.#props.node, WhenNode.create(parseValueBinaryOperationOrExpression(args))),
        });
    }
}
class CaseThenBuilder {
    #props;
    constructor(props) {
        this.#props = freeze(props);
    }
    then(valueExpression) {
        return new CaseWhenBuilder({
            ...this.#props,
            node: CaseNode.cloneWithThen(this.#props.node, isSafeImmediateValue(valueExpression)
                ? parseSafeImmediateValue(valueExpression)
                : parseValueExpression(valueExpression)),
        });
    }
}
class CaseWhenBuilder {
    #props;
    constructor(props) {
        this.#props = freeze(props);
    }
    when(...args) {
        return new CaseThenBuilder({
            ...this.#props,
            node: CaseNode.cloneWithWhen(this.#props.node, WhenNode.create(parseValueBinaryOperationOrExpression(args))),
        });
    }
    else(valueExpression) {
        return new CaseEndBuilder({
            ...this.#props,
            node: CaseNode.cloneWith(this.#props.node, {
                else: isSafeImmediateValue(valueExpression)
                    ? parseSafeImmediateValue(valueExpression)
                    : parseValueExpression(valueExpression),
            }),
        });
    }
    end() {
        return new ExpressionWrapper(CaseNode.cloneWith(this.#props.node, { isStatement: false }));
    }
    endCase() {
        return new ExpressionWrapper(CaseNode.cloneWith(this.#props.node, { isStatement: true }));
    }
}
class CaseEndBuilder {
    #props;
    constructor(props) {
        this.#props = freeze(props);
    }
    end() {
        return new ExpressionWrapper(CaseNode.cloneWith(this.#props.node, { isStatement: false }));
    }
    endCase() {
        return new ExpressionWrapper(CaseNode.cloneWith(this.#props.node, { isStatement: true }));
    }
}

/// <reference types="./json-path-leg-node.d.ts" />
/**
 * @internal
 */
const JSONPathLegNode = freeze({
    is(node) {
        return node.kind === 'JSONPathLegNode';
    },
    create(type, value) {
        return freeze({
            kind: 'JSONPathLegNode',
            type,
            value,
        });
    },
});

/// <reference types="./json-path-builder.d.ts" />
class JSONPathBuilder {
    #node;
    constructor(node) {
        this.#node = node;
    }
    /**
     * Access an element of a JSON array in a specific location.
     *
     * Since there's no guarantee an element exists in the given array location, the
     * resulting type is always nullable. If you're sure the element exists, you
     * should use {@link SelectQueryBuilder.$assertType} to narrow the type safely.
     *
     * See also {@link key} to access properties of JSON objects.
     *
     * ### Examples
     *
     * ```ts
     * db.selectFrom('person').select(eb =>
     *   eb.ref('nicknames', '->').at(0).as('primary_nickname')
     * )
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * select "nicknames"->0 as "primary_nickname" from "person"
     *```
     *
     * Combined with {@link key}:
     *
     * ```ts
     * db.selectFrom('person').select(eb =>
     *   eb.ref('experience', '->').at(0).key('role').as('first_role')
     * )
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * select "experience"->0->'role' as "first_role" from "person"
     * ```
     *
     * You can use `'last'` to access the last element of the array in MySQL:
     *
     * ```ts
     * db.selectFrom('person').select(eb =>
     *   eb.ref('nicknames', '->$').at('last').as('last_nickname')
     * )
     * ```
     *
     * The generated SQL (MySQL):
     *
     * ```sql
     * select `nicknames`->'$[last]' as `last_nickname` from `person`
     * ```
     *
     * Or `'#-1'` in SQLite:
     *
     * ```ts
     * db.selectFrom('person').select(eb =>
     *   eb.ref('nicknames', '->>$').at('#-1').as('last_nickname')
     * )
     * ```
     *
     * The generated SQL (SQLite):
     *
     * ```sql
     * select "nicknames"->>'$[#-1]' as `last_nickname` from `person`
     * ```
     */
    at(index) {
        return this.#createBuilderWithPathLeg('ArrayLocation', index);
    }
    /**
     * Access a property of a JSON object.
     *
     * If a field is optional, the resulting type will be nullable.
     *
     * See also {@link at} to access elements of JSON arrays.
     *
     * ### Examples
     *
     * ```ts
     * db.selectFrom('person').select(eb =>
     *   eb.ref('address', '->').key('city').as('city')
     * )
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * select "address"->'city' as "city" from "person"
     * ```
     *
     * Going deeper:
     *
     * ```ts
     * db.selectFrom('person').select(eb =>
     *   eb.ref('profile', '->$').key('website').key('url').as('website_url')
     * )
     * ```
     *
     * The generated SQL (MySQL):
     *
     * ```sql
     * select `profile`->'$.website.url' as `website_url` from `person`
     * ```
     *
     * Combined with {@link at}:
     *
     * ```ts
     * db.selectFrom('person').select(eb =>
     *   eb.ref('profile', '->').key('addresses').at(0).key('city').as('city')
     * )
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * select "profile"->'addresses'->0->'city' as "city" from "person"
     * ```
     */
    key(key) {
        return this.#createBuilderWithPathLeg('Member', key);
    }
    #createBuilderWithPathLeg(legType, value) {
        if (JSONReferenceNode.is(this.#node)) {
            return new TraversedJSONPathBuilder(JSONReferenceNode.cloneWithTraversal(this.#node, JSONPathNode.is(this.#node.traversal)
                ? JSONPathNode.cloneWithLeg(this.#node.traversal, JSONPathLegNode.create(legType, value))
                : JSONOperatorChainNode.cloneWithValue(this.#node.traversal, ValueNode.createImmediate(value))));
        }
        return new TraversedJSONPathBuilder(JSONPathNode.cloneWithLeg(this.#node, JSONPathLegNode.create(legType, value)));
    }
}
class TraversedJSONPathBuilder extends JSONPathBuilder {
    #node;
    constructor(node) {
        super(node);
        this.#node = node;
    }
    /** @private */
    get expressionType() {
        return undefined;
    }
    as(alias) {
        return new AliasedJSONPathBuilder(this, alias);
    }
    /**
     * Change the output type of the json path.
     *
     * This method call doesn't change the SQL in any way. This methods simply
     * returns a copy of this `JSONPathBuilder` with a new output type.
     */
    $castTo() {
        return new JSONPathBuilder(this.#node);
    }
    $notNull() {
        return new JSONPathBuilder(this.#node);
    }
    toOperationNode() {
        return this.#node;
    }
}
class AliasedJSONPathBuilder {
    #jsonPath;
    #alias;
    constructor(jsonPath, alias) {
        this.#jsonPath = jsonPath;
        this.#alias = alias;
    }
    /** @private */
    get expression() {
        return this.#jsonPath;
    }
    /** @private */
    get alias() {
        return this.#alias;
    }
    toOperationNode() {
        return AliasNode.create(this.#jsonPath.toOperationNode(), isOperationNodeSource(this.#alias)
            ? this.#alias.toOperationNode()
            : IdentifierNode.create(this.#alias));
    }
}

/// <reference types="./tuple-node.d.ts" />
/**
 * @internal
 */
const TupleNode = freeze({
    is(node) {
        return node.kind === 'TupleNode';
    },
    create(values) {
        return freeze({
            kind: 'TupleNode',
            values: freeze(values),
        });
    },
});

/// <reference types="./data-type-node.d.ts" />
const SIMPLE_COLUMN_DATA_TYPES = [
    'varchar',
    'char',
    'text',
    'integer',
    'int2',
    'int4',
    'int8',
    'smallint',
    'bigint',
    'boolean',
    'real',
    'double precision',
    'float4',
    'float8',
    'decimal',
    'numeric',
    'binary',
    'bytea',
    'date',
    'datetime',
    'time',
    'timetz',
    'timestamp',
    'timestamptz',
    'serial',
    'bigserial',
    'uuid',
    'json',
    'jsonb',
    'blob',
    'varbinary',
];
const COLUMN_DATA_TYPE_REGEX = [
    /^varchar\(\d+\)$/,
    /^char\(\d+\)$/,
    /^decimal\(\d+, \d+\)$/,
    /^numeric\(\d+, \d+\)$/,
    /^binary\(\d+\)$/,
    /^datetime\(\d+\)$/,
    /^time\(\d+\)$/,
    /^timetz\(\d+\)$/,
    /^timestamp\(\d+\)$/,
    /^timestamptz\(\d+\)$/,
    /^varbinary\(\d+\)$/,
];
/**
 * @internal
 */
const DataTypeNode = freeze({
    is(node) {
        return node.kind === 'DataTypeNode';
    },
    create(dataType) {
        return freeze({
            kind: 'DataTypeNode',
            dataType,
        });
    },
});
function isColumnDataType(dataType) {
    if (SIMPLE_COLUMN_DATA_TYPES.includes(dataType)) {
        return true;
    }
    if (COLUMN_DATA_TYPE_REGEX.some((r) => r.test(dataType))) {
        return true;
    }
    return false;
}

/// <reference types="./data-type-parser.d.ts" />
function parseDataTypeExpression(dataType) {
    if (isOperationNodeSource(dataType)) {
        return dataType.toOperationNode();
    }
    if (isColumnDataType(dataType)) {
        return DataTypeNode.create(dataType);
    }
    throw new Error(`invalid column data type ${JSON.stringify(dataType)}`);
}

/// <reference types="./cast-node.d.ts" />
/**
 * @internal
 */
const CastNode = freeze({
    is(node) {
        return node.kind === 'CastNode';
    },
    create(expression, dataType) {
        return freeze({
            kind: 'CastNode',
            expression,
            dataType,
        });
    },
});

/// <reference types="./expression-builder.d.ts" />
function createExpressionBuilder(executor = NOOP_QUERY_EXECUTOR) {
    function binary(lhs, op, rhs) {
        return new ExpressionWrapper(parseValueBinaryOperation(lhs, op, rhs));
    }
    function unary(op, expr) {
        return new ExpressionWrapper(parseUnaryOperation(op, expr));
    }
    const eb = Object.assign(binary, {
        fn: undefined,
        eb: undefined,
        selectFrom(table) {
            return createSelectQueryBuilder({
                queryId: createQueryId(),
                executor,
                queryNode: SelectQueryNode.createFrom(parseTableExpressionOrList(table)),
            });
        },
        case(reference) {
            return new CaseBuilder({
                node: CaseNode.create(isUndefined(reference)
                    ? undefined
                    : parseReferenceExpression(reference)),
            });
        },
        ref(reference, op) {
            if (isUndefined(op)) {
                return new ExpressionWrapper(parseStringReference(reference));
            }
            return new JSONPathBuilder(parseJSONReference(reference, op));
        },
        jsonPath() {
            return new JSONPathBuilder(JSONPathNode.create());
        },
        table(table) {
            return new ExpressionWrapper(parseTable(table));
        },
        val(value) {
            return new ExpressionWrapper(parseValueExpression(value));
        },
        refTuple(...values) {
            return new ExpressionWrapper(TupleNode.create(values.map(parseReferenceExpression)));
        },
        tuple(...values) {
            return new ExpressionWrapper(TupleNode.create(values.map(parseValueExpression)));
        },
        lit(value) {
            return new ExpressionWrapper(parseSafeImmediateValue(value));
        },
        unary,
        not(expr) {
            return unary('not', expr);
        },
        exists(expr) {
            return unary('exists', expr);
        },
        neg(expr) {
            return unary('-', expr);
        },
        between(expr, start, end) {
            return new ExpressionWrapper(BinaryOperationNode.create(parseReferenceExpression(expr), OperatorNode.create('between'), AndNode.create(parseValueExpression(start), parseValueExpression(end))));
        },
        betweenSymmetric(expr, start, end) {
            return new ExpressionWrapper(BinaryOperationNode.create(parseReferenceExpression(expr), OperatorNode.create('between symmetric'), AndNode.create(parseValueExpression(start), parseValueExpression(end))));
        },
        and(exprs) {
            if (isReadonlyArray(exprs)) {
                return new ExpressionWrapper(parseFilterList(exprs, 'and'));
            }
            return new ExpressionWrapper(parseFilterObject(exprs, 'and'));
        },
        or(exprs) {
            if (isReadonlyArray(exprs)) {
                return new ExpressionWrapper(parseFilterList(exprs, 'or'));
            }
            return new ExpressionWrapper(parseFilterObject(exprs, 'or'));
        },
        parens(...args) {
            const node = parseValueBinaryOperationOrExpression(args);
            if (ParensNode.is(node)) {
                // No double wrapping.
                return new ExpressionWrapper(node);
            }
            else {
                return new ExpressionWrapper(ParensNode.create(node));
            }
        },
        cast(expr, dataType) {
            return new ExpressionWrapper(CastNode.create(parseReferenceExpression(expr), parseDataTypeExpression(dataType)));
        },
        withSchema(schema) {
            return createExpressionBuilder(executor.withPluginAtFront(new WithSchemaPlugin(schema)));
        },
    });
    eb.fn = createFunctionModule();
    eb.eb = eb;
    return eb;
}
function expressionBuilder(_) {
    return createExpressionBuilder();
}

/// <reference types="./expression-parser.d.ts" />
function parseExpression(exp) {
    if (isOperationNodeSource(exp)) {
        return exp.toOperationNode();
    }
    else if (isFunction(exp)) {
        return exp(expressionBuilder()).toOperationNode();
    }
    throw new Error(`invalid expression: ${JSON.stringify(exp)}`);
}
function parseAliasedExpression(exp) {
    if (isOperationNodeSource(exp)) {
        return exp.toOperationNode();
    }
    else if (isFunction(exp)) {
        return exp(expressionBuilder()).toOperationNode();
    }
    throw new Error(`invalid aliased expression: ${JSON.stringify(exp)}`);
}
function isExpressionOrFactory(obj) {
    return isExpression(obj) || isAliasedExpression(obj) || isFunction(obj);
}

/// <reference types="./table-parser.d.ts" />
function parseTableExpressionOrList(table) {
    if (isReadonlyArray(table)) {
        return table.map((it) => parseTableExpression(it));
    }
    else {
        return [parseTableExpression(table)];
    }
}
function parseTableExpression(table) {
    if (isString(table)) {
        return parseAliasedTable(table);
    }
    else {
        return parseAliasedExpression(table);
    }
}
function parseAliasedTable(from) {
    const ALIAS_SEPARATOR = ' as ';
    if (from.includes(ALIAS_SEPARATOR)) {
        const [table, alias] = from.split(ALIAS_SEPARATOR).map(trim$1);
        return AliasNode.create(parseTable(table), IdentifierNode.create(alias));
    }
    else {
        return parseTable(from);
    }
}
function parseTable(from) {
    const SCHEMA_SEPARATOR = '.';
    if (from.includes(SCHEMA_SEPARATOR)) {
        const [schema, table] = from.split(SCHEMA_SEPARATOR).map(trim$1);
        return TableNode.createWithSchema(schema, table);
    }
    else {
        return TableNode.create(from);
    }
}
function trim$1(str) {
    return str.trim();
}

/// <reference types="./add-column-node.d.ts" />
/**
 * @internal
 */
const AddColumnNode = freeze({
    is(node) {
        return node.kind === 'AddColumnNode';
    },
    create(column) {
        return freeze({
            kind: 'AddColumnNode',
            column,
        });
    },
});

/// <reference types="./column-definition-node.d.ts" />
/**
 * @internal
 */
const ColumnDefinitionNode = freeze({
    is(node) {
        return node.kind === 'ColumnDefinitionNode';
    },
    create(column, dataType) {
        return freeze({
            kind: 'ColumnDefinitionNode',
            column: ColumnNode.create(column),
            dataType,
        });
    },
    cloneWithFrontModifier(node, modifier) {
        return freeze({
            ...node,
            frontModifiers: node.frontModifiers
                ? freeze([...node.frontModifiers, modifier])
                : [modifier],
        });
    },
    cloneWithEndModifier(node, modifier) {
        return freeze({
            ...node,
            endModifiers: node.endModifiers
                ? freeze([...node.endModifiers, modifier])
                : [modifier],
        });
    },
    cloneWith(node, props) {
        return freeze({
            ...node,
            ...props,
        });
    },
});

/// <reference types="./drop-column-node.d.ts" />
/**
 * @internal
 */
const DropColumnNode = freeze({
    is(node) {
        return node.kind === 'DropColumnNode';
    },
    create(column) {
        return freeze({
            kind: 'DropColumnNode',
            column: ColumnNode.create(column),
        });
    },
});

/// <reference types="./rename-column-node.d.ts" />
/**
 * @internal
 */
const RenameColumnNode = freeze({
    is(node) {
        return node.kind === 'RenameColumnNode';
    },
    create(column, newColumn) {
        return freeze({
            kind: 'RenameColumnNode',
            column: ColumnNode.create(column),
            renameTo: ColumnNode.create(newColumn),
        });
    },
});

/// <reference types="./check-constraint-node.d.ts" />
/**
 * @internal
 */
const CheckConstraintNode = freeze({
    is(node) {
        return node.kind === 'CheckConstraintNode';
    },
    create(expression, constraintName) {
        return freeze({
            kind: 'CheckConstraintNode',
            expression,
            name: constraintName ? IdentifierNode.create(constraintName) : undefined,
        });
    },
});

/// <reference types="./references-node.d.ts" />
const ON_MODIFY_FOREIGN_ACTIONS = [
    'no action',
    'restrict',
    'cascade',
    'set null',
    'set default',
];
/**
 * @internal
 */
const ReferencesNode = freeze({
    is(node) {
        return node.kind === 'ReferencesNode';
    },
    create(table, columns) {
        return freeze({
            kind: 'ReferencesNode',
            table,
            columns: freeze([...columns]),
        });
    },
    cloneWithOnDelete(references, onDelete) {
        return freeze({
            ...references,
            onDelete,
        });
    },
    cloneWithOnUpdate(references, onUpdate) {
        return freeze({
            ...references,
            onUpdate,
        });
    },
});

/// <reference types="./default-value-parser.d.ts" />
function parseDefaultValueExpression(value) {
    return isOperationNodeSource(value)
        ? value.toOperationNode()
        : ValueNode.createImmediate(value);
}

/// <reference types="./generated-node.d.ts" />
/**
 * @internal
 */
const GeneratedNode = freeze({
    is(node) {
        return node.kind === 'GeneratedNode';
    },
    create(params) {
        return freeze({
            kind: 'GeneratedNode',
            ...params,
        });
    },
    createWithExpression(expression) {
        return freeze({
            kind: 'GeneratedNode',
            always: true,
            expression,
        });
    },
    cloneWith(node, params) {
        return freeze({
            ...node,
            ...params,
        });
    },
});

/// <reference types="./default-value-node.d.ts" />
/**
 * @internal
 */
const DefaultValueNode = freeze({
    is(node) {
        return node.kind === 'DefaultValueNode';
    },
    create(defaultValue) {
        return freeze({
            kind: 'DefaultValueNode',
            defaultValue,
        });
    },
});

/// <reference types="./on-modify-action-parser.d.ts" />
function parseOnModifyForeignAction(action) {
    if (ON_MODIFY_FOREIGN_ACTIONS.includes(action)) {
        return action;
    }
    throw new Error(`invalid OnModifyForeignAction ${action}`);
}

/// <reference types="./column-definition-builder.d.ts" />
class ColumnDefinitionBuilder {
    #node;
    constructor(node) {
        this.#node = node;
    }
    /**
     * Adds `auto_increment` or `autoincrement` to the column definition
     * depending on the dialect.
     *
     * Some dialects like PostgreSQL don't support this. On PostgreSQL
     * you can use the `serial` or `bigserial` data type instead.
     */
    autoIncrement() {
        return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { autoIncrement: true }));
    }
    /**
     * Makes the column an identity column.
     *
     * This only works on some dialects like MS SQL Server (MSSQL).
     *
     * For PostgreSQL's `generated always as identity` use {@link generatedAlwaysAsIdentity}.
     */
    identity() {
        return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { identity: true }));
    }
    /**
     * Makes the column the primary key.
     *
     * If you want to specify a composite primary key use the
     * {@link CreateTableBuilder.addPrimaryKeyConstraint} method.
     */
    primaryKey() {
        return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { primaryKey: true }));
    }
    /**
     * Adds a foreign key constraint for the column.
     *
     * If your database engine doesn't support foreign key constraints in the
     * column definition (like MySQL 5) you need to call the table level
     * {@link CreateTableBuilder.addForeignKeyConstraint} method instead.
     *
     * ### Examples
     *
     * ```ts
     * col.references('person.id')
     * ```
     */
    references(ref) {
        const references = parseStringReference(ref);
        if (!references.table || SelectAllNode.is(references.column)) {
            throw new Error(`invalid call references('${ref}'). The reference must have format table.column or schema.table.column`);
        }
        return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
            references: ReferencesNode.create(references.table, [
                references.column,
            ]),
        }));
    }
    /**
     * Adds an `on delete` constraint for the foreign key column.
     *
     * If your database engine doesn't support foreign key constraints in the
     * column definition (like MySQL 5) you need to call the table level
     * {@link CreateTableBuilder.addForeignKeyConstraint} method instead.
     *
     * ### Examples
     *
     * ```ts
     * col.references('person.id').onDelete('cascade')
     * ```
     */
    onDelete(onDelete) {
        if (!this.#node.references) {
            throw new Error('on delete constraint can only be added for foreign keys');
        }
        return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
            references: ReferencesNode.cloneWithOnDelete(this.#node.references, parseOnModifyForeignAction(onDelete)),
        }));
    }
    /**
     * Adds an `on update` constraint for the foreign key column.
     *
     * ### Examples
     *
     * ```ts
     * col.references('person.id').onUpdate('cascade')
     * ```
     */
    onUpdate(onUpdate) {
        if (!this.#node.references) {
            throw new Error('on update constraint can only be added for foreign keys');
        }
        return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
            references: ReferencesNode.cloneWithOnUpdate(this.#node.references, parseOnModifyForeignAction(onUpdate)),
        }));
    }
    /**
     * Adds a unique constraint for the column.
     */
    unique() {
        return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { unique: true }));
    }
    /**
     * Adds a `not null` constraint for the column.
     */
    notNull() {
        return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { notNull: true }));
    }
    /**
     * Adds a `unsigned` modifier for the column.
     *
     * This only works on some dialects like MySQL.
     */
    unsigned() {
        return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { unsigned: true }));
    }
    /**
     * Adds a default value constraint for the column.
     *
     * ### Examples
     *
     * ```ts
     * db.schema
     *   .createTable('pet')
     *   .addColumn('number_of_legs', 'integer', (col) => col.defaultTo(4))
     *   .execute()
     * ```
     *
     * Values passed to `defaultTo` are interpreted as value literals by default. You can define
     * an arbitrary SQL expression using the {@link sql} template tag:
     *
     * ```ts
     * import {sql } from 'kysely'
     *
     * db.schema
     *   .createTable('pet')
     *   .addColumn(
     *     'number_of_legs',
     *     'integer',
     *     (col) => col.defaultTo(sql`any SQL here`)
     *   )
     *   .execute()
     * ```
     */
    defaultTo(value) {
        return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
            defaultTo: DefaultValueNode.create(parseDefaultValueExpression(value)),
        }));
    }
    /**
     * Adds a check constraint for the column.
     *
     * ### Examples
     *
     * ```ts
     * import {sql } from 'kysely'
     *
     * db.schema
     *   .createTable('pet')
     *   .addColumn('number_of_legs', 'integer', (col) =>
     *     col.check(sql`number_of_legs < 5`)
     *   )
     *   .execute()
     * ```
     */
    check(expression) {
        return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
            check: CheckConstraintNode.create(expression.toOperationNode()),
        }));
    }
    /**
     * Makes the column a generated column using a `generated always as` statement.
     *
     * ### Examples
     *
     * ```ts
     * import {sql } from 'kysely'
     *
     * db.schema
     *   .createTable('person')
     *   .addColumn('full_name', 'varchar(255)',
     *     (col) => col.generatedAlwaysAs(sql`concat(first_name, ' ', last_name)`)
     *   )
     *   .execute()
     * ```
     */
    generatedAlwaysAs(expression) {
        return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
            generated: GeneratedNode.createWithExpression(expression.toOperationNode()),
        }));
    }
    /**
     * Adds the `generated always as identity` specifier.
     *
     * This only works on some dialects like PostgreSQL.
     *
     * For MS SQL Server (MSSQL)'s identity column use {@link identity}.
     */
    generatedAlwaysAsIdentity() {
        return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
            generated: GeneratedNode.create({ identity: true, always: true }),
        }));
    }
    /**
     * Adds the `generated by default as identity` specifier on supported dialects.
     */
    generatedByDefaultAsIdentity() {
        return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
            generated: GeneratedNode.create({ identity: true, byDefault: true }),
        }));
    }
    /**
     * Makes a generated column stored instead of virtual. This method can only
     * be used with {@link generatedAlwaysAs}
     *
     * ### Examples
     *
     * ```ts
     * db.schema
     *   .createTable('person')
     *   .addColumn('full_name', 'varchar(255)', (col) => col
     *     .generatedAlwaysAs("concat(first_name, ' ', last_name)")
     *     .stored()
     *   )
     *   .execute()
     * ```
     */
    stored() {
        if (!this.#node.generated) {
            throw new Error('stored() can only be called after generatedAlwaysAs');
        }
        return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
            generated: GeneratedNode.cloneWith(this.#node.generated, {
                stored: true,
            }),
        }));
    }
    /**
     * This can be used to add any additional SQL right after the column's data type.
     *
     * ### Examples
     *
     * ```ts
     * db.schema.createTable('person')
     *  .addColumn('id', 'integer', col => col.primaryKey())
     *  .addColumn('first_name', 'varchar(36)', col => col.modifyFront(sql`collate utf8mb4_general_ci`).notNull())
     *  .execute()
     * ```
     *
     * The generated SQL (MySQL):
     *
     * ```sql
     * create table `person` (
     *   `id` integer primary key,
     *   `first_name` varchar(36) collate utf8mb4_general_ci not null
     * )
     * ```
     */
    modifyFront(modifier) {
        return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWithFrontModifier(this.#node, modifier.toOperationNode()));
    }
    /**
     * Adds `nulls not distinct` specifier.
     * Should be used with `unique` constraint.
     *
     * This only works on some dialects like PostgreSQL.
     *
     * ### Examples
     *
     * ```ts
     * db.schema.createTable('person')
     *  .addColumn('id', 'integer', col => col.primaryKey())
     *  .addColumn('first_name', 'varchar(30)', col => col.unique().nullsNotDistinct())
     *  .execute()
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * create table "person" (
     *   "id" integer primary key,
     *   "first_name" varchar(30) unique nulls not distinct
     * )
     * ```
     */
    nullsNotDistinct() {
        return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { nullsNotDistinct: true }));
    }
    /**
     * Adds `if not exists` specifier.
     * This only works for PostgreSQL.
     */
    ifNotExists() {
        return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { ifNotExists: true }));
    }
    /**
     * This can be used to add any additional SQL to the end of the column definition.
     *
     * ### Examples
     *
     * ```ts
     * db.schema.createTable('person')
     *  .addColumn('id', 'integer', col => col.primaryKey())
     *  .addColumn('age', 'integer', col => col.unsigned().notNull().modifyEnd(sql`comment ${sql.lit('it is not polite to ask a woman her age')}`))
     *  .execute()
     * ```
     *
     * The generated SQL (MySQL):
     *
     * ```sql
     * create table `person` (
     *   `id` integer primary key,
     *   `age` integer unsigned not null comment 'it is not polite to ask a woman her age'
     * )
     * ```
     */
    modifyEnd(modifier) {
        return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWithEndModifier(this.#node, modifier.toOperationNode()));
    }
    /**
     * Simply calls the provided function passing `this` as the only argument. `$call` returns
     * what the provided function returns.
     */
    $call(func) {
        return func(this);
    }
    toOperationNode() {
        return this.#node;
    }
}
preventAwait(ColumnDefinitionBuilder, "don't await ColumnDefinitionBuilder instances directly.");

/// <reference types="./modify-column-node.d.ts" />
/**
 * @internal
 */
const ModifyColumnNode = freeze({
    is(node) {
        return node.kind === 'ModifyColumnNode';
    },
    create(column) {
        return freeze({
            kind: 'ModifyColumnNode',
            column,
        });
    },
});

/// <reference types="./foreign-key-constraint-node.d.ts" />
/**
 * @internal
 */
const ForeignKeyConstraintNode = freeze({
    is(node) {
        return node.kind === 'ForeignKeyConstraintNode';
    },
    create(sourceColumns, targetTable, targetColumns, constraintName) {
        return freeze({
            kind: 'ForeignKeyConstraintNode',
            columns: sourceColumns,
            references: ReferencesNode.create(targetTable, targetColumns),
            name: constraintName ? IdentifierNode.create(constraintName) : undefined,
        });
    },
    cloneWith(node, props) {
        return freeze({
            ...node,
            ...props,
        });
    },
});

/// <reference types="./foreign-key-constraint-builder.d.ts" />
class ForeignKeyConstraintBuilder {
    #node;
    constructor(node) {
        this.#node = node;
    }
    onDelete(onDelete) {
        return new ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.cloneWith(this.#node, {
            onDelete: parseOnModifyForeignAction(onDelete),
        }));
    }
    onUpdate(onUpdate) {
        return new ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.cloneWith(this.#node, {
            onUpdate: parseOnModifyForeignAction(onUpdate),
        }));
    }
    /**
     * Simply calls the provided function passing `this` as the only argument. `$call` returns
     * what the provided function returns.
     */
    $call(func) {
        return func(this);
    }
    toOperationNode() {
        return this.#node;
    }
}
preventAwait(ForeignKeyConstraintBuilder, "don't await ForeignKeyConstraintBuilder instances directly.");

/// <reference types="./add-constraint-node.d.ts" />
/**
 * @internal
 */
const AddConstraintNode = freeze({
    is(node) {
        return node.kind === 'AddConstraintNode';
    },
    create(constraint) {
        return freeze({
            kind: 'AddConstraintNode',
            constraint,
        });
    },
});

/// <reference types="./unique-constraint-node.d.ts" />
/**
 * @internal
 */
const UniqueConstraintNode = freeze({
    is(node) {
        return node.kind === 'UniqueConstraintNode';
    },
    create(columns, constraintName, nullsNotDistinct) {
        return freeze({
            kind: 'UniqueConstraintNode',
            columns: freeze(columns.map(ColumnNode.create)),
            name: constraintName ? IdentifierNode.create(constraintName) : undefined,
            nullsNotDistinct,
        });
    },
    cloneWith(node, props) {
        return freeze({
            ...node,
            ...props,
        });
    },
});

/// <reference types="./drop-constraint-node.d.ts" />
/**
 * @internal
 */
const DropConstraintNode = freeze({
    is(node) {
        return node.kind === 'DropConstraintNode';
    },
    create(constraintName) {
        return freeze({
            kind: 'DropConstraintNode',
            constraintName: IdentifierNode.create(constraintName),
        });
    },
    cloneWith(dropConstraint, props) {
        return freeze({
            ...dropConstraint,
            ...props,
        });
    },
});

/// <reference types="./alter-column-node.d.ts" />
/**
 * @internal
 */
const AlterColumnNode = freeze({
    is(node) {
        return node.kind === 'AlterColumnNode';
    },
    create(column, prop, value) {
        return freeze({
            kind: 'AlterColumnNode',
            column: ColumnNode.create(column),
            [prop]: value,
        });
    },
});

/// <reference types="./alter-column-builder.d.ts" />
class AlterColumnBuilder {
    #column;
    constructor(column) {
        this.#column = column;
    }
    setDataType(dataType) {
        return new AlteredColumnBuilder(AlterColumnNode.create(this.#column, 'dataType', parseDataTypeExpression(dataType)));
    }
    setDefault(value) {
        return new AlteredColumnBuilder(AlterColumnNode.create(this.#column, 'setDefault', parseDefaultValueExpression(value)));
    }
    dropDefault() {
        return new AlteredColumnBuilder(AlterColumnNode.create(this.#column, 'dropDefault', true));
    }
    setNotNull() {
        return new AlteredColumnBuilder(AlterColumnNode.create(this.#column, 'setNotNull', true));
    }
    dropNotNull() {
        return new AlteredColumnBuilder(AlterColumnNode.create(this.#column, 'dropNotNull', true));
    }
    /**
     * Simply calls the provided function passing `this` as the only argument. `$call` returns
     * what the provided function returns.
     */
    $call(func) {
        return func(this);
    }
}
preventAwait(AlterColumnBuilder, "don't await AlterColumnBuilder instances");
/**
 * Allows us to force consumers to do exactly one alteration to a column.
 *
 * Basically, deny the following:
 *
 * ```ts
 * db.schema.alterTable('person').alterColumn('age', (ac) => ac)
 * ```
 *
 * ```ts
 * db.schema.alterTable('person').alterColumn('age', (ac) => ac.dropNotNull().setNotNull())
 * ```
 *
 * Which would now throw a compilation error, instead of a runtime error.
 */
class AlteredColumnBuilder {
    #alterColumnNode;
    constructor(alterColumnNode) {
        this.#alterColumnNode = alterColumnNode;
    }
    toOperationNode() {
        return this.#alterColumnNode;
    }
}
preventAwait(AlteredColumnBuilder, "don't await AlteredColumnBuilder instances");

/// <reference types="./alter-table-executor.d.ts" />
class AlterTableExecutor {
    #props;
    constructor(props) {
        this.#props = freeze(props);
    }
    toOperationNode() {
        return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
    }
    compile() {
        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
    }
    async execute() {
        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
    }
}
preventAwait(AlterTableExecutor, "don't await AlterTableExecutor instances directly. To execute the query you need to call `execute`");

/// <reference types="./alter-table-add-foreign-key-constraint-builder.d.ts" />
class AlterTableAddForeignKeyConstraintBuilder {
    #props;
    constructor(props) {
        this.#props = freeze(props);
    }
    onDelete(onDelete) {
        return new AlterTableAddForeignKeyConstraintBuilder({
            ...this.#props,
            constraintBuilder: this.#props.constraintBuilder.onDelete(onDelete),
        });
    }
    onUpdate(onUpdate) {
        return new AlterTableAddForeignKeyConstraintBuilder({
            ...this.#props,
            constraintBuilder: this.#props.constraintBuilder.onUpdate(onUpdate),
        });
    }
    /**
     * Simply calls the provided function passing `this` as the only argument. `$call` returns
     * what the provided function returns.
     */
    $call(func) {
        return func(this);
    }
    toOperationNode() {
        return this.#props.executor.transformQuery(AlterTableNode.cloneWithTableProps(this.#props.node, {
            addConstraint: AddConstraintNode.create(this.#props.constraintBuilder.toOperationNode()),
        }), this.#props.queryId);
    }
    compile() {
        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
    }
    async execute() {
        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
    }
}
preventAwait(AlterTableAddForeignKeyConstraintBuilder, "don't await AlterTableAddForeignKeyConstraintBuilder instances directly. To execute the query you need to call `execute`");

/// <reference types="./alter-table-drop-constraint-builder.d.ts" />
class AlterTableDropConstraintBuilder {
    #props;
    constructor(props) {
        this.#props = freeze(props);
    }
    ifExists() {
        return new AlterTableDropConstraintBuilder({
            ...this.#props,
            node: AlterTableNode.cloneWithTableProps(this.#props.node, {
                dropConstraint: DropConstraintNode.cloneWith(this.#props.node.dropConstraint, {
                    ifExists: true,
                }),
            }),
        });
    }
    cascade() {
        return new AlterTableDropConstraintBuilder({
            ...this.#props,
            node: AlterTableNode.cloneWithTableProps(this.#props.node, {
                dropConstraint: DropConstraintNode.cloneWith(this.#props.node.dropConstraint, {
                    modifier: 'cascade',
                }),
            }),
        });
    }
    restrict() {
        return new AlterTableDropConstraintBuilder({
            ...this.#props,
            node: AlterTableNode.cloneWithTableProps(this.#props.node, {
                dropConstraint: DropConstraintNode.cloneWith(this.#props.node.dropConstraint, {
                    modifier: 'restrict',
                }),
            }),
        });
    }
    /**
     * Simply calls the provided function passing `this` as the only argument. `$call` returns
     * what the provided function returns.
     */
    $call(func) {
        return func(this);
    }
    toOperationNode() {
        return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
    }
    compile() {
        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
    }
    async execute() {
        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
    }
}
preventAwait(AlterTableDropConstraintBuilder, "don't await AlterTableDropConstraintBuilder instances directly. To execute the query you need to call `execute`");

/// <reference types="./primary-constraint-node.d.ts" />
/**
 * @internal
 */
const PrimaryConstraintNode = freeze({
    is(node) {
        return node.kind === 'PrimaryKeyConstraintNode';
    },
    create(columns, constraintName) {
        return freeze({
            kind: 'PrimaryKeyConstraintNode',
            columns: freeze(columns.map(ColumnNode.create)),
            name: constraintName ? IdentifierNode.create(constraintName) : undefined,
        });
    },
});

/// <reference types="./add-index-node.d.ts" />
/**
 * @internal
 */
const AddIndexNode = freeze({
    is(node) {
        return node.kind === 'AddIndexNode';
    },
    create(name) {
        return freeze({
            kind: 'AddIndexNode',
            name: IdentifierNode.create(name),
        });
    },
    cloneWith(node, props) {
        return freeze({
            ...node,
            ...props,
        });
    },
    cloneWithColumns(node, columns) {
        return freeze({
            ...node,
            columns: [...(node.columns || []), ...columns],
        });
    },
});

/// <reference types="./alter-table-add-index-builder.d.ts" />
class AlterTableAddIndexBuilder {
    #props;
    constructor(props) {
        this.#props = freeze(props);
    }
    /**
     * Makes the index unique.
     */
    unique() {
        return new AlterTableAddIndexBuilder({
            ...this.#props,
            node: AlterTableNode.cloneWithTableProps(this.#props.node, {
                addIndex: AddIndexNode.cloneWith(this.#props.node.addIndex, {
                    unique: true,
                }),
            }),
        });
    }
    /**
     * Adds a column to the index.
     *
     * Also see {@link columns} for adding multiple columns at once or {@link expression}
     * for specifying an arbitrary expression.
     *
     * ### Examples
     *
     * ```ts
     * await db.schema
     *         .alterTable('person')
     *         .createIndex('person_first_name_and_age_index')
     *         .column('first_name')
     *         .column('age desc')
     *         .execute()
     * ```
     *
     * The generated SQL (MySQL):
     *
     * ```sql
     * alter table `person` add index `person_first_name_and_age_index` (`first_name`, `age` desc)
     * ```
     */
    column(column) {
        return new AlterTableAddIndexBuilder({
            ...this.#props,
            node: AlterTableNode.cloneWithTableProps(this.#props.node, {
                addIndex: AddIndexNode.cloneWithColumns(this.#props.node.addIndex, [
                    parseOrderedColumnName(column),
                ]),
            }),
        });
    }
    /**
     * Specifies a list of columns for the index.
     *
     * Also see {@link column} for adding a single column or {@link expression} for
     * specifying an arbitrary expression.
     *
     * ### Examples
     *
     * ```ts
     * await db.schema
     *         .alterTable('person')
     *         .addIndex('person_first_name_and_age_index')
     *         .columns(['first_name', 'age desc'])
     *         .execute()
     * ```
     *
     * The generated SQL (MySQL):
     *
     * ```sql
     * alter table `person` add index `person_first_name_and_age_index` (`first_name`, `age` desc)
     * ```
     */
    columns(columns) {
        return new AlterTableAddIndexBuilder({
            ...this.#props,
            node: AlterTableNode.cloneWithTableProps(this.#props.node, {
                addIndex: AddIndexNode.cloneWithColumns(this.#props.node.addIndex, columns.map(parseOrderedColumnName)),
            }),
        });
    }
    /**
     * Specifies an arbitrary expression for the index.
     *
     * ### Examples
     *
     * ```ts
     * import {sql } from 'kysely'
     *
     * await db.schema
     *   .alterTable('person')
     *   .addIndex('person_first_name_index')
     *   .expression(sql<boolean>`(first_name < 'Sami')`)
     *   .execute()
     * ```
     *
     * The generated SQL (MySQL):
     *
     * ```sql
     * alter table `person` add index `person_first_name_index` ((first_name < 'Sami'))
     * ```
     */
    expression(expression) {
        return new AlterTableAddIndexBuilder({
            ...this.#props,
            node: AlterTableNode.cloneWithTableProps(this.#props.node, {
                addIndex: AddIndexNode.cloneWithColumns(this.#props.node.addIndex, [
                    expression.toOperationNode(),
                ]),
            }),
        });
    }
    using(indexType) {
        return new AlterTableAddIndexBuilder({
            ...this.#props,
            node: AlterTableNode.cloneWithTableProps(this.#props.node, {
                addIndex: AddIndexNode.cloneWith(this.#props.node.addIndex, {
                    using: RawNode.createWithSql(indexType),
                }),
            }),
        });
    }
    /**
     * Simply calls the provided function passing `this` as the only argument. `$call` returns
     * what the provided function returns.
     */
    $call(func) {
        return func(this);
    }
    toOperationNode() {
        return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
    }
    compile() {
        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
    }
    async execute() {
        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
    }
}
preventAwait(AlterTableAddIndexBuilder, "don't await AlterTableAddIndexBuilder instances directly. To execute the query you need to call `execute`");

/// <reference types="./unique-constraint-builder.d.ts" />
class UniqueConstraintNodeBuilder {
    #node;
    constructor(node) {
        this.#node = node;
    }
    toOperationNode() {
        return this.#node;
    }
    /**
     * Adds `nulls not distinct` to the unique constraint definition
     *
     * Supported by PostgreSQL dialect only
     */
    nullsNotDistinct() {
        return new UniqueConstraintNodeBuilder(UniqueConstraintNode.cloneWith(this.#node, { nullsNotDistinct: true }));
    }
}
preventAwait(UniqueConstraintNodeBuilder, "don't await UniqueConstraintNodeBuilder instances directly.");

/// <reference types="./alter-table-builder.d.ts" />
/**
 * This builder can be used to create a `alter table` query.
 */
class AlterTableBuilder {
    #props;
    constructor(props) {
        this.#props = freeze(props);
    }
    renameTo(newTableName) {
        return new AlterTableExecutor({
            ...this.#props,
            node: AlterTableNode.cloneWithTableProps(this.#props.node, {
                renameTo: parseTable(newTableName),
            }),
        });
    }
    setSchema(newSchema) {
        return new AlterTableExecutor({
            ...this.#props,
            node: AlterTableNode.cloneWithTableProps(this.#props.node, {
                setSchema: IdentifierNode.create(newSchema),
            }),
        });
    }
    alterColumn(column, alteration) {
        const builder = alteration(new AlterColumnBuilder(column));
        return new AlterTableColumnAlteringBuilder({
            ...this.#props,
            node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, builder.toOperationNode()),
        });
    }
    dropColumn(column) {
        return new AlterTableColumnAlteringBuilder({
            ...this.#props,
            node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, DropColumnNode.create(column)),
        });
    }
    renameColumn(column, newColumn) {
        return new AlterTableColumnAlteringBuilder({
            ...this.#props,
            node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, RenameColumnNode.create(column, newColumn)),
        });
    }
    addColumn(columnName, dataType, build = noop) {
        const builder = build(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType))));
        return new AlterTableColumnAlteringBuilder({
            ...this.#props,
            node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, AddColumnNode.create(builder.toOperationNode())),
        });
    }
    modifyColumn(columnName, dataType, build = noop) {
        const builder = build(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType))));
        return new AlterTableColumnAlteringBuilder({
            ...this.#props,
            node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, ModifyColumnNode.create(builder.toOperationNode())),
        });
    }
    /**
     * See {@link CreateTableBuilder.addUniqueConstraint}
     */
    addUniqueConstraint(constraintName, columns, build = noop) {
        const uniqueConstraintBuilder = build(new UniqueConstraintNodeBuilder(UniqueConstraintNode.create(columns, constraintName)));
        return new AlterTableExecutor({
            ...this.#props,
            node: AlterTableNode.cloneWithTableProps(this.#props.node, {
                addConstraint: AddConstraintNode.create(uniqueConstraintBuilder.toOperationNode()),
            }),
        });
    }
    /**
     * See {@link CreateTableBuilder.addCheckConstraint}
     */
    addCheckConstraint(constraintName, checkExpression) {
        return new AlterTableExecutor({
            ...this.#props,
            node: AlterTableNode.cloneWithTableProps(this.#props.node, {
                addConstraint: AddConstraintNode.create(CheckConstraintNode.create(checkExpression.toOperationNode(), constraintName)),
            }),
        });
    }
    /**
     * See {@link CreateTableBuilder.addForeignKeyConstraint}
     *
     * Unlike {@link CreateTableBuilder.addForeignKeyConstraint} this method returns
     * the constraint builder and doesn't take a callback as the last argument. This
     * is because you can only add one column per `ALTER TABLE` query.
     */
    addForeignKeyConstraint(constraintName, columns, targetTable, targetColumns) {
        return new AlterTableAddForeignKeyConstraintBuilder({
            ...this.#props,
            constraintBuilder: new ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.create(columns.map(ColumnNode.create), parseTable(targetTable), targetColumns.map(ColumnNode.create), constraintName)),
        });
    }
    /**
     * See {@link CreateTableBuilder.addPrimaryKeyConstraint}
     */
    addPrimaryKeyConstraint(constraintName, columns) {
        return new AlterTableExecutor({
            ...this.#props,
            node: AlterTableNode.cloneWithTableProps(this.#props.node, {
                addConstraint: AddConstraintNode.create(PrimaryConstraintNode.create(columns, constraintName)),
            }),
        });
    }
    dropConstraint(constraintName) {
        return new AlterTableDropConstraintBuilder({
            ...this.#props,
            node: AlterTableNode.cloneWithTableProps(this.#props.node, {
                dropConstraint: DropConstraintNode.create(constraintName),
            }),
        });
    }
    /**
     * This can be used to add index to table.
     *
     *  ### Examples
     *
     * ```ts
     * db.schema.alterTable('person')
     *   .addIndex('person_email_index')
     *   .column('email')
     *   .unique()
     *   .execute()
     * ```
     *
     * The generated SQL (MySQL):
     *
     * ```sql
     * alter table `person` add unique index `person_email_index` (`email`)
     * ```
     */
    addIndex(indexName) {
        return new AlterTableAddIndexBuilder({
            ...this.#props,
            node: AlterTableNode.cloneWithTableProps(this.#props.node, {
                addIndex: AddIndexNode.create(indexName),
            }),
        });
    }
    /**
     * This can be used to drop index from table.
     *
     * ### Examples
     *
     * ```ts
     * db.schema.alterTable('person')
     *   .dropIndex('person_email_index')
     *   .execute()
     * ```
     *
     * The generated SQL (MySQL):
     *
     * ```sql
     * alter table `person` drop index `test_first_name_index`
     * ```
     */
    dropIndex(indexName) {
        return new AlterTableExecutor({
            ...this.#props,
            node: AlterTableNode.cloneWithTableProps(this.#props.node, {
                dropIndex: DropIndexNode.create(indexName),
            }),
        });
    }
    /**
     * Calls the given function passing `this` as the only argument.
     *
     * See {@link CreateTableBuilder.$call}
     */
    $call(func) {
        return func(this);
    }
}
preventAwait(AlterTableBuilder, "don't await AlterTableBuilder instances");
class AlterTableColumnAlteringBuilder {
    #props;
    constructor(props) {
        this.#props = freeze(props);
    }
    alterColumn(column, alteration) {
        const builder = alteration(new AlterColumnBuilder(column));
        return new AlterTableColumnAlteringBuilder({
            ...this.#props,
            node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, builder.toOperationNode()),
        });
    }
    dropColumn(column) {
        return new AlterTableColumnAlteringBuilder({
            ...this.#props,
            node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, DropColumnNode.create(column)),
        });
    }
    renameColumn(column, newColumn) {
        return new AlterTableColumnAlteringBuilder({
            ...this.#props,
            node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, RenameColumnNode.create(column, newColumn)),
        });
    }
    addColumn(columnName, dataType, build = noop) {
        const builder = build(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType))));
        return new AlterTableColumnAlteringBuilder({
            ...this.#props,
            node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, AddColumnNode.create(builder.toOperationNode())),
        });
    }
    modifyColumn(columnName, dataType, build = noop) {
        const builder = build(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType))));
        return new AlterTableColumnAlteringBuilder({
            ...this.#props,
            node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, ModifyColumnNode.create(builder.toOperationNode())),
        });
    }
    toOperationNode() {
        return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
    }
    compile() {
        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
    }
    async execute() {
        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
    }
}
preventAwait(AlterTableColumnAlteringBuilder, "don't await AlterTableColumnAlteringBuilder instances directly. To execute the query you need to call `execute`");

/// <reference types="./immediate-value-transformer.d.ts" />
/**
 * Transforms all ValueNodes to immediate.
 *
 * WARNING! This should never be part of the public API. Users should never use this.
 * This is an internal helper.
 *
 * @internal
 */
class ImmediateValueTransformer extends OperationNodeTransformer {
    transformValue(node) {
        return {
            ...super.transformValue(node),
            immediate: true,
        };
    }
}

/// <reference types="./create-index-builder.d.ts" />
class CreateIndexBuilder {
    #props;
    constructor(props) {
        this.#props = freeze(props);
    }
    /**
     * Adds the "if not exists" modifier.
     *
     * If the index already exists, no error is thrown if this method has been called.
     */
    ifNotExists() {
        return new CreateIndexBuilder({
            ...this.#props,
            node: CreateIndexNode.cloneWith(this.#props.node, {
                ifNotExists: true,
            }),
        });
    }
    /**
     * Makes the index unique.
     */
    unique() {
        return new CreateIndexBuilder({
            ...this.#props,
            node: CreateIndexNode.cloneWith(this.#props.node, {
                unique: true,
            }),
        });
    }
    /**
     * Adds `nulls not distinct` specifier to index.
     * This only works on some dialects like PostgreSQL.
     *
     * ### Examples
     *
     * ```ts
     * db.schema.createIndex('person_first_name_index')
     *  .on('person')
     *  .column('first_name')
     *  .nullsNotDistinct()
     *  .execute()
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * create index "person_first_name_index"
     * on "test" ("first_name")
     * nulls not distinct;
     * ```
     */
    nullsNotDistinct() {
        return new CreateIndexBuilder({
            ...this.#props,
            node: CreateIndexNode.cloneWith(this.#props.node, {
                nullsNotDistinct: true,
            }),
        });
    }
    /**
     * Specifies the table for the index.
     */
    on(table) {
        return new CreateIndexBuilder({
            ...this.#props,
            node: CreateIndexNode.cloneWith(this.#props.node, {
                table: parseTable(table),
            }),
        });
    }
    /**
     * Adds a column to the index.
     *
     * Also see {@link columns} for adding multiple columns at once or {@link expression}
     * for specifying an arbitrary expression.
     *
     * ### Examples
     *
     * ```ts
     * await db.schema
     *         .createIndex('person_first_name_and_age_index')
     *         .on('person')
     *         .column('first_name')
     *         .column('age desc')
     *         .execute()
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * create index "person_first_name_and_age_index" on "person" ("first_name", "age" desc)
     * ```
     */
    column(column) {
        return new CreateIndexBuilder({
            ...this.#props,
            node: CreateIndexNode.cloneWithColumns(this.#props.node, [
                parseOrderedColumnName(column),
            ]),
        });
    }
    /**
     * Specifies a list of columns for the index.
     *
     * Also see {@link column} for adding a single column or {@link expression} for
     * specifying an arbitrary expression.
     *
     * ### Examples
     *
     * ```ts
     * await db.schema
     *         .createIndex('person_first_name_and_age_index')
     *         .on('person')
     *         .columns(['first_name', 'age desc'])
     *         .execute()
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * create index "person_first_name_and_age_index" on "person" ("first_name", "age" desc)
     * ```
     */
    columns(columns) {
        return new CreateIndexBuilder({
            ...this.#props,
            node: CreateIndexNode.cloneWithColumns(this.#props.node, columns.map(parseOrderedColumnName)),
        });
    }
    /**
     * Specifies an arbitrary expression for the index.
     *
     * ### Examples
     *
     * ```ts
     * import {sql } from 'kysely'
     *
     * await db.schema
     *   .createIndex('person_first_name_index')
     *   .on('person')
     *   .expression(sql`first_name COLLATE "fi_FI"`)
     *   .execute()
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * create index "person_first_name_index" on "person" (first_name COLLATE "fi_FI")
     * ```
     */
    expression(expression) {
        return new CreateIndexBuilder({
            ...this.#props,
            node: CreateIndexNode.cloneWithColumns(this.#props.node, [
                expression.toOperationNode(),
            ]),
        });
    }
    using(indexType) {
        return new CreateIndexBuilder({
            ...this.#props,
            node: CreateIndexNode.cloneWith(this.#props.node, {
                using: RawNode.createWithSql(indexType),
            }),
        });
    }
    where(...args) {
        const transformer = new ImmediateValueTransformer();
        return new CreateIndexBuilder({
            ...this.#props,
            node: QueryNode.cloneWithWhere(this.#props.node, transformer.transformNode(parseValueBinaryOperationOrExpression(args))),
        });
    }
    /**
     * Simply calls the provided function passing `this` as the only argument. `$call` returns
     * what the provided function returns.
     */
    $call(func) {
        return func(this);
    }
    toOperationNode() {
        return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
    }
    compile() {
        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
    }
    async execute() {
        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
    }
}
preventAwait(CreateIndexBuilder, "don't await CreateIndexBuilder instances directly. To execute the query you need to call `execute`");

/// <reference types="./create-schema-builder.d.ts" />
class CreateSchemaBuilder {
    #props;
    constructor(props) {
        this.#props = freeze(props);
    }
    ifNotExists() {
        return new CreateSchemaBuilder({
            ...this.#props,
            node: CreateSchemaNode.cloneWith(this.#props.node, { ifNotExists: true }),
        });
    }
    /**
     * Simply calls the provided function passing `this` as the only argument. `$call` returns
     * what the provided function returns.
     */
    $call(func) {
        return func(this);
    }
    toOperationNode() {
        return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
    }
    compile() {
        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
    }
    async execute() {
        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
    }
}
preventAwait(CreateSchemaBuilder, "don't await CreateSchemaBuilder instances directly. To execute the query you need to call `execute`");

/// <reference types="./on-commit-action-parse.d.ts" />
function parseOnCommitAction(action) {
    if (ON_COMMIT_ACTIONS.includes(action)) {
        return action;
    }
    throw new Error(`invalid OnCommitAction ${action}`);
}

/// <reference types="./create-table-builder.d.ts" />
/**
 * This builder can be used to create a `create table` query.
 */
class CreateTableBuilder {
    #props;
    constructor(props) {
        this.#props = freeze(props);
    }
    /**
     * Adds the "temporary" modifier.
     *
     * Use this to create a temporary table.
     */
    temporary() {
        return new CreateTableBuilder({
            ...this.#props,
            node: CreateTableNode.cloneWith(this.#props.node, {
                temporary: true,
            }),
        });
    }
    /**
     * Adds an "on commit" statement.
     *
     * This can be used in conjunction with temporary tables on supported databases
     * like PostgreSQL.
     */
    onCommit(onCommit) {
        return new CreateTableBuilder({
            ...this.#props,
            node: CreateTableNode.cloneWith(this.#props.node, {
                onCommit: parseOnCommitAction(onCommit),
            }),
        });
    }
    /**
     * Adds the "if not exists" modifier.
     *
     * If the table already exists, no error is thrown if this method has been called.
     */
    ifNotExists() {
        return new CreateTableBuilder({
            ...this.#props,
            node: CreateTableNode.cloneWith(this.#props.node, {
                ifNotExists: true,
            }),
        });
    }
    /**
     * Adds a column to the table.
     *
     * ### Examples
     *
     * ```ts
     * import {sql } from 'kysely'
     *
     * await db.schema
     *   .createTable('person')
     *   .addColumn('id', 'integer', (col) => col.autoIncrement().primaryKey()),
     *   .addColumn('first_name', 'varchar(50)', (col) => col.notNull())
     *   .addColumn('last_name', 'varchar(255)')
     *   .addColumn('bank_balance', 'numeric(8, 2)')
     *   // You can specify any data type using the `sql` tag if the types
     *   // don't include it.
     *   .addColumn('data', sql`any_type_here`)
     *   .addColumn('parent_id', 'integer', (col) =>
     *     col.references('person.id').onDelete('cascade'))
     *   )
     * ```
     *
     * With this method, it's once again good to remember that Kysely just builds the
     * query and doesn't provide the same API for all databases. For example, some
     * databases like older MySQL don't support the `references` statement in the
     * column definition. Instead foreign key constraints need to be defined in the
     * `create table` query. See the next example:
     *
     * ```ts
     *   .addColumn('parent_id', 'integer')
     *   .addForeignKeyConstraint(
     *     'person_parent_id_fk', ['parent_id'], 'person', ['id'],
     *     (cb) => cb.onDelete('cascade')
     *   )
     * ```
     *
     * Another good example is that PostgreSQL doesn't support the `auto_increment`
     * keyword and you need to define an autoincrementing column for example using
     * `serial`:
     *
     * ```ts
     * await db.schema
     *   .createTable('person')
     *   .addColumn('id', 'serial', (col) => col.primaryKey()),
     * ```
     */
    addColumn(columnName, dataType, build = noop) {
        const columnBuilder = build(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType))));
        return new CreateTableBuilder({
            ...this.#props,
            node: CreateTableNode.cloneWithColumn(this.#props.node, columnBuilder.toOperationNode()),
        });
    }
    /**
     * Adds a primary key constraint for one or more columns.
     *
     * The constraint name can be anything you want, but it must be unique
     * across the whole database.
     *
     * ### Examples
     *
     * ```ts
     * addPrimaryKeyConstraint('primary_key', ['first_name', 'last_name'])
     * ```
     */
    addPrimaryKeyConstraint(constraintName, columns) {
        return new CreateTableBuilder({
            ...this.#props,
            node: CreateTableNode.cloneWithConstraint(this.#props.node, PrimaryConstraintNode.create(columns, constraintName)),
        });
    }
    /**
     * Adds a unique constraint for one or more columns.
     *
     * The constraint name can be anything you want, but it must be unique
     * across the whole database.
     *
     * ### Examples
     *
     * ```ts
     * addUniqueConstraint('first_name_last_name_unique', ['first_name', 'last_name'])
     * ```
     *
     * In dialects such as PostgreSQL you can specify `nulls not distinct` as follows:
     * ```ts
     * addUniqueConstraint('first_name_last_name_unique', ['first_name', 'last_name'], (builder) => builder.nullsNotDistinct())
     * ```
     */
    addUniqueConstraint(constraintName, columns, build = noop) {
        const uniqueConstraintBuilder = build(new UniqueConstraintNodeBuilder(UniqueConstraintNode.create(columns, constraintName)));
        return new CreateTableBuilder({
            ...this.#props,
            node: CreateTableNode.cloneWithConstraint(this.#props.node, uniqueConstraintBuilder.toOperationNode()),
        });
    }
    /**
     * Adds a check constraint.
     *
     * The constraint name can be anything you want, but it must be unique
     * across the whole database.
     *
     * ### Examples
     *
     * ```ts
     * import {sql } from 'kysely'
     *
     * addCheckConstraint('check_legs', sql`number_of_legs < 5`)
     * ```
     */
    addCheckConstraint(constraintName, checkExpression) {
        return new CreateTableBuilder({
            ...this.#props,
            node: CreateTableNode.cloneWithConstraint(this.#props.node, CheckConstraintNode.create(checkExpression.toOperationNode(), constraintName)),
        });
    }
    /**
     * Adds a foreign key constraint.
     *
     * The constraint name can be anything you want, but it must be unique
     * across the whole database.
     *
     * ### Examples
     *
     * ```ts
     * addForeignKeyConstraint(
     *   'owner_id_foreign',
     *   ['owner_id'],
     *   'person',
     *   ['id'],
     * )
     * ```
     *
     * Add constraint for multiple columns:
     *
     * ```ts
     * addForeignKeyConstraint(
     *   'owner_id_foreign',
     *   ['owner_id1', 'owner_id2'],
     *   'person',
     *   ['id1', 'id2'],
     *   (cb) => cb.onDelete('cascade')
     * )
     * ```
     */
    addForeignKeyConstraint(constraintName, columns, targetTable, targetColumns, build = noop) {
        const builder = build(new ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.create(columns.map(ColumnNode.create), parseTable(targetTable), targetColumns.map(ColumnNode.create), constraintName)));
        return new CreateTableBuilder({
            ...this.#props,
            node: CreateTableNode.cloneWithConstraint(this.#props.node, builder.toOperationNode()),
        });
    }
    /**
     * This can be used to add any additional SQL to the front of the query __after__ the `create` keyword.
     *
     * Also see {@link temporary}.
     *
     * ### Examples
     *
     * ```ts
     * db.schema.createTable('person')
     *   .modifyFront(sql`global temporary`)
     *   .addColumn('id', 'integer', col => col.primaryKey())
     *   .addColumn('first_name', 'varchar(64)', col => col.notNull())
     *   .addColumn('last_name', 'varchar(64), col => col.notNull())
     *   .execute()
     * ```
     *
     * The generated SQL (Postgres):
     *
     * ```sql
     * create global temporary table "person" (
     *   "id" integer primary key,
     *   "first_name" varchar(64) not null,
     *   "last_name" varchar(64) not null
     * )
     * ```
     */
    modifyFront(modifier) {
        return new CreateTableBuilder({
            ...this.#props,
            node: CreateTableNode.cloneWithFrontModifier(this.#props.node, modifier.toOperationNode()),
        });
    }
    /**
     * This can be used to add any additional SQL to the end of the query.
     *
     * Also see {@link onCommit}.
     *
     * ### Examples
     *
     * ```ts
     * db.schema.createTable('person')
     *   .addColumn('id', 'integer', col => col => primaryKey())
     *   .addColumn('first_name', 'varchar(64)', col => col.notNull())
     *   .addColumn('last_name', 'varchar(64), col => col.notNull())
     *   .modifyEnd(sql`collate utf8_unicode_ci`)
     *   .execute()
     * ```
     *
     * The generated SQL (MySQL):
     *
     * ```sql
     * create table `person` (
     *   `id` integer primary key,
     *   `first_name` varchar(64) not null,
     *   `last_name` varchar(64) not null
     * ) collate utf8_unicode_ci
     * ```
     */
    modifyEnd(modifier) {
        return new CreateTableBuilder({
            ...this.#props,
            node: CreateTableNode.cloneWithEndModifier(this.#props.node, modifier.toOperationNode()),
        });
    }
    /**
     * Allows to create table from `select` query.
     *
     * ### Examples
     *
     * ```ts
     * db.schema.createTable('copy')
     *   .temporary()
     *   .as(db.selectFrom('person').select(['first_name', 'last_name']))
     *   .execute()
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * create temporary table "copy" as
     * select "first_name", "last_name" from "person"
     * ```
     */
    as(expression) {
        return new CreateTableBuilder({
            ...this.#props,
            node: CreateTableNode.cloneWith(this.#props.node, {
                selectQuery: parseExpression(expression),
            }),
        });
    }
    /**
     * Calls the given function passing `this` as the only argument.
     *
     * ### Examples
     *
     * ```ts
     * db.schema
     *   .createTable('test')
     *   .$call((builder) => builder.addColumn('id', 'integer'))
     *   .execute()
     * ```
     *
     * ```ts
     * const addDefaultColumns = <T extends string, C extends string = never>(
     *   builder: CreateTableBuilder<T, C>
     * ) => {
     *   return builder
     *     .addColumn('id', 'integer', (col) => col.notNull())
     *     .addColumn('created_at', 'date', (col) =>
     *       col.notNull().defaultTo(sql`now()`)
     *     )
     *     .addColumn('updated_at', 'date', (col) =>
     *       col.notNull().defaultTo(sql`now()`)
     *     )
     * }
     *
     * db.schema
     *   .createTable('test')
     *   .$call(addDefaultColumns)
     *   .execute()
     * ```
     */
    $call(func) {
        return func(this);
    }
    toOperationNode() {
        return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
    }
    compile() {
        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
    }
    async execute() {
        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
    }
}
preventAwait(CreateTableBuilder, "don't await CreateTableBuilder instances directly. To execute the query you need to call `execute`");

/// <reference types="./drop-index-builder.d.ts" />
class DropIndexBuilder {
    #props;
    constructor(props) {
        this.#props = freeze(props);
    }
    /**
     * Specifies the table the index was created for. This is not needed
     * in all dialects.
     */
    on(table) {
        return new DropIndexBuilder({
            ...this.#props,
            node: DropIndexNode.cloneWith(this.#props.node, {
                table: parseTable(table),
            }),
        });
    }
    ifExists() {
        return new DropIndexBuilder({
            ...this.#props,
            node: DropIndexNode.cloneWith(this.#props.node, {
                ifExists: true,
            }),
        });
    }
    cascade() {
        return new DropIndexBuilder({
            ...this.#props,
            node: DropIndexNode.cloneWith(this.#props.node, {
                cascade: true,
            }),
        });
    }
    /**
     * Simply calls the provided function passing `this` as the only argument. `$call` returns
     * what the provided function returns.
     */
    $call(func) {
        return func(this);
    }
    toOperationNode() {
        return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
    }
    compile() {
        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
    }
    async execute() {
        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
    }
}
preventAwait(DropIndexBuilder, "don't await DropIndexBuilder instances directly. To execute the query you need to call `execute`");

/// <reference types="./drop-schema-builder.d.ts" />
class DropSchemaBuilder {
    #props;
    constructor(props) {
        this.#props = freeze(props);
    }
    ifExists() {
        return new DropSchemaBuilder({
            ...this.#props,
            node: DropSchemaNode.cloneWith(this.#props.node, {
                ifExists: true,
            }),
        });
    }
    cascade() {
        return new DropSchemaBuilder({
            ...this.#props,
            node: DropSchemaNode.cloneWith(this.#props.node, {
                cascade: true,
            }),
        });
    }
    /**
     * Simply calls the provided function passing `this` as the only argument. `$call` returns
     * what the provided function returns.
     */
    $call(func) {
        return func(this);
    }
    toOperationNode() {
        return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
    }
    compile() {
        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
    }
    async execute() {
        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
    }
}
preventAwait(DropSchemaBuilder, "don't await DropSchemaBuilder instances directly. To execute the query you need to call `execute`");

/// <reference types="./drop-table-builder.d.ts" />
class DropTableBuilder {
    #props;
    constructor(props) {
        this.#props = freeze(props);
    }
    ifExists() {
        return new DropTableBuilder({
            ...this.#props,
            node: DropTableNode.cloneWith(this.#props.node, {
                ifExists: true,
            }),
        });
    }
    cascade() {
        return new DropTableBuilder({
            ...this.#props,
            node: DropTableNode.cloneWith(this.#props.node, {
                cascade: true,
            }),
        });
    }
    /**
     * Simply calls the provided function passing `this` as the only argument. `$call` returns
     * what the provided function returns.
     */
    $call(func) {
        return func(this);
    }
    toOperationNode() {
        return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
    }
    compile() {
        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
    }
    async execute() {
        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
    }
}
preventAwait(DropTableBuilder, "don't await DropTableBuilder instances directly. To execute the query you need to call `execute`");

/// <reference types="./create-view-node.d.ts" />
/**
 * @internal
 */
const CreateViewNode = freeze({
    is(node) {
        return node.kind === 'CreateViewNode';
    },
    create(name) {
        return freeze({
            kind: 'CreateViewNode',
            name: SchemableIdentifierNode.create(name),
        });
    },
    cloneWith(createView, params) {
        return freeze({
            ...createView,
            ...params,
        });
    },
});

/// <reference types="./immediate-value-plugin.d.ts" />
/**
 * Transforms all ValueNodes to immediate.
 *
 * WARNING! This should never be part of the public API. Users should never use this.
 * This is an internal helper.
 *
 * @internal
 */
class ImmediateValuePlugin {
    #transformer = new ImmediateValueTransformer();
    transformQuery(args) {
        return this.#transformer.transformNode(args.node);
    }
    transformResult(args) {
        return Promise.resolve(args.result);
    }
}

/// <reference types="./create-view-builder.d.ts" />
class CreateViewBuilder {
    #props;
    constructor(props) {
        this.#props = freeze(props);
    }
    /**
     * Adds the "temporary" modifier.
     *
     * Use this to create a temporary view.
     */
    temporary() {
        return new CreateViewBuilder({
            ...this.#props,
            node: CreateViewNode.cloneWith(this.#props.node, {
                temporary: true,
            }),
        });
    }
    materialized() {
        return new CreateViewBuilder({
            ...this.#props,
            node: CreateViewNode.cloneWith(this.#props.node, {
                materialized: true,
            }),
        });
    }
    /**
     * Only implemented on some dialects like SQLite. On most dialects, use {@link orReplace}.
     */
    ifNotExists() {
        return new CreateViewBuilder({
            ...this.#props,
            node: CreateViewNode.cloneWith(this.#props.node, {
                ifNotExists: true,
            }),
        });
    }
    orReplace() {
        return new CreateViewBuilder({
            ...this.#props,
            node: CreateViewNode.cloneWith(this.#props.node, {
                orReplace: true,
            }),
        });
    }
    columns(columns) {
        return new CreateViewBuilder({
            ...this.#props,
            node: CreateViewNode.cloneWith(this.#props.node, {
                columns: columns.map(parseColumnName),
            }),
        });
    }
    /**
     * Sets the select query or a `values` statement that creates the view.
     *
     * WARNING!
     * Some dialects don't support parameterized queries in DDL statements and therefore
     * the query or raw {@link sql } expression passed here is interpolated into a single
     * string opening an SQL injection vulnerability. DO NOT pass unchecked user input
     * into the query or raw expression passed to this method!
     */
    as(query) {
        const queryNode = query
            .withPlugin(new ImmediateValuePlugin())
            .toOperationNode();
        return new CreateViewBuilder({
            ...this.#props,
            node: CreateViewNode.cloneWith(this.#props.node, {
                as: queryNode,
            }),
        });
    }
    /**
     * Simply calls the provided function passing `this` as the only argument. `$call` returns
     * what the provided function returns.
     */
    $call(func) {
        return func(this);
    }
    toOperationNode() {
        return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
    }
    compile() {
        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
    }
    async execute() {
        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
    }
}
preventAwait(CreateViewBuilder, "don't await CreateViewBuilder instances directly. To execute the query you need to call `execute`");

/// <reference types="./drop-view-node.d.ts" />
/**
 * @internal
 */
const DropViewNode = freeze({
    is(node) {
        return node.kind === 'DropViewNode';
    },
    create(name) {
        return freeze({
            kind: 'DropViewNode',
            name: SchemableIdentifierNode.create(name),
        });
    },
    cloneWith(dropView, params) {
        return freeze({
            ...dropView,
            ...params,
        });
    },
});

/// <reference types="./drop-view-builder.d.ts" />
class DropViewBuilder {
    #props;
    constructor(props) {
        this.#props = freeze(props);
    }
    materialized() {
        return new DropViewBuilder({
            ...this.#props,
            node: DropViewNode.cloneWith(this.#props.node, {
                materialized: true,
            }),
        });
    }
    ifExists() {
        return new DropViewBuilder({
            ...this.#props,
            node: DropViewNode.cloneWith(this.#props.node, {
                ifExists: true,
            }),
        });
    }
    cascade() {
        return new DropViewBuilder({
            ...this.#props,
            node: DropViewNode.cloneWith(this.#props.node, {
                cascade: true,
            }),
        });
    }
    /**
     * Simply calls the provided function passing `this` as the only argument. `$call` returns
     * what the provided function returns.
     */
    $call(func) {
        return func(this);
    }
    toOperationNode() {
        return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
    }
    compile() {
        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
    }
    async execute() {
        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
    }
}
preventAwait(DropViewBuilder, "don't await DropViewBuilder instances directly. To execute the query you need to call `execute`");

/// <reference types="./create-type-node.d.ts" />
/**
 * @internal
 */
const CreateTypeNode = freeze({
    is(node) {
        return node.kind === 'CreateTypeNode';
    },
    create(name) {
        return freeze({
            kind: 'CreateTypeNode',
            name,
        });
    },
    cloneWithEnum(createType, values) {
        return freeze({
            ...createType,
            enum: ValueListNode.create(values.map((value) => ValueNode.createImmediate(value))),
        });
    },
});

/// <reference types="./create-type-builder.d.ts" />
class CreateTypeBuilder {
    #props;
    constructor(props) {
        this.#props = freeze(props);
    }
    toOperationNode() {
        return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
    }
    /**
     * Creates an anum type.
     *
     * ### Examples
     *
     * ```ts
     * db.schema.createType('species').asEnum(['cat', 'dog', 'frog'])
     * ```
     */
    asEnum(values) {
        return new CreateTypeBuilder({
            ...this.#props,
            node: CreateTypeNode.cloneWithEnum(this.#props.node, values),
        });
    }
    /**
     * Simply calls the provided function passing `this` as the only argument. `$call` returns
     * what the provided function returns.
     */
    $call(func) {
        return func(this);
    }
    compile() {
        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
    }
    async execute() {
        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
    }
}
preventAwait(CreateTypeBuilder, "don't await CreateTypeBuilder instances directly. To execute the query you need to call `execute`");

/// <reference types="./drop-type-node.d.ts" />
/**
 * @internal
 */
const DropTypeNode = freeze({
    is(node) {
        return node.kind === 'DropTypeNode';
    },
    create(name) {
        return freeze({
            kind: 'DropTypeNode',
            name,
        });
    },
    cloneWith(dropType, params) {
        return freeze({
            ...dropType,
            ...params,
        });
    },
});

/// <reference types="./drop-type-builder.d.ts" />
class DropTypeBuilder {
    #props;
    constructor(props) {
        this.#props = freeze(props);
    }
    ifExists() {
        return new DropTypeBuilder({
            ...this.#props,
            node: DropTypeNode.cloneWith(this.#props.node, {
                ifExists: true,
            }),
        });
    }
    /**
     * Simply calls the provided function passing `this` as the only argument. `$call` returns
     * what the provided function returns.
     */
    $call(func) {
        return func(this);
    }
    toOperationNode() {
        return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
    }
    compile() {
        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
    }
    async execute() {
        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
    }
}
preventAwait(DropTypeBuilder, "don't await DropTypeBuilder instances directly. To execute the query you need to call `execute`");

/// <reference types="./identifier-parser.d.ts" />
function parseSchemableIdentifier(id) {
    const SCHEMA_SEPARATOR = '.';
    if (id.includes(SCHEMA_SEPARATOR)) {
        const parts = id.split(SCHEMA_SEPARATOR).map(trim);
        if (parts.length === 2) {
            return SchemableIdentifierNode.createWithSchema(parts[0], parts[1]);
        }
        else {
            throw new Error(`invalid schemable identifier ${id}`);
        }
    }
    else {
        return SchemableIdentifierNode.create(id);
    }
}
function trim(str) {
    return str.trim();
}

/// <reference types="./schema.d.ts" />
/**
 * Provides methods for building database schema.
 */
class SchemaModule {
    #executor;
    constructor(executor) {
        this.#executor = executor;
    }
    /**
     * Create a new table.
     *
     * ### Examples
     *
     * This example creates a new table with columns `id`, `first_name`,
     * `last_name` and `gender`:
     *
     * ```ts
     * await db.schema
     *   .createTable('person')
     *   .addColumn('id', 'integer', col => col.primaryKey().autoIncrement())
     *   .addColumn('first_name', 'varchar', col => col.notNull())
     *   .addColumn('last_name', 'varchar', col => col.notNull())
     *   .addColumn('gender', 'varchar')
     *   .execute()
     * ```
     *
     * This example creates a table with a foreign key. Not all database
     * engines support column-level foreign key constraint definitions.
     * For example if you are using MySQL 5.X see the next example after
     * this one.
     *
     * ```ts
     * await db.schema
     *   .createTable('pet')
     *   .addColumn('id', 'integer', col => col.primaryKey().autoIncrement())
     *   .addColumn('owner_id', 'integer', col => col
     *     .references('person.id')
     *     .onDelete('cascade')
     *   )
     *   .execute()
     * ```
     *
     * This example adds a foreign key constraint for a columns just
     * like the previous example, but using a table-level statement.
     * On MySQL 5.X you need to define foreign key constraints like
     * this:
     *
     * ```ts
     * await db.schema
     *   .createTable('pet')
     *   .addColumn('id', 'integer', col => col.primaryKey().autoIncrement())
     *   .addColumn('owner_id', 'integer')
     *   .addForeignKeyConstraint(
     *     'pet_owner_id_foreign', ['owner_id'], 'person', ['id'],
     *     (constraint) => constraint.onDelete('cascade')
     *   )
     *   .execute()
     * ```
     */
    createTable(table) {
        return new CreateTableBuilder({
            queryId: createQueryId(),
            executor: this.#executor,
            node: CreateTableNode.create(parseTable(table)),
        });
    }
    /**
     * Drop a table.
     *
     * ### Examples
     *
     * ```ts
     * await db.schema
     *   .dropTable('person')
     *   .execute()
     * ```
     */
    dropTable(table) {
        return new DropTableBuilder({
            queryId: createQueryId(),
            executor: this.#executor,
            node: DropTableNode.create(parseTable(table)),
        });
    }
    /**
     * Create a new index.
     *
     * ### Examples
     *
     * ```ts
     * await db.schema
     *   .createIndex('person_full_name_unique_index')
     *   .on('person')
     *   .columns(['first_name', 'last_name'])
     *   .execute()
     * ```
     */
    createIndex(indexName) {
        return new CreateIndexBuilder({
            queryId: createQueryId(),
            executor: this.#executor,
            node: CreateIndexNode.create(indexName),
        });
    }
    /**
     * Drop an index.
     *
     * ### Examples
     *
     * ```ts
     * await db.schema
     *   .dropIndex('person_full_name_unique_index')
     *   .execute()
     * ```
     */
    dropIndex(indexName) {
        return new DropIndexBuilder({
            queryId: createQueryId(),
            executor: this.#executor,
            node: DropIndexNode.create(indexName),
        });
    }
    /**
     * Create a new schema.
     *
     * ### Examples
     *
     * ```ts
     * await db.schema
     *   .createSchema('some_schema')
     *   .execute()
     * ```
     */
    createSchema(schema) {
        return new CreateSchemaBuilder({
            queryId: createQueryId(),
            executor: this.#executor,
            node: CreateSchemaNode.create(schema),
        });
    }
    /**
     * Drop a schema.
     *
     * ### Examples
     *
     * ```ts
     * await db.schema
     *   .dropSchema('some_schema')
     *   .execute()
     * ```
     */
    dropSchema(schema) {
        return new DropSchemaBuilder({
            queryId: createQueryId(),
            executor: this.#executor,
            node: DropSchemaNode.create(schema),
        });
    }
    /**
     * Alter a table.
     *
     * ### Examples
     *
     * ```ts
     * await db.schema
     *   .alterTable('person')
     *   .alterColumn('first_name', (ac) => ac.setDataType('text'))
     *   .execute()
     * ```
     */
    alterTable(table) {
        return new AlterTableBuilder({
            queryId: createQueryId(),
            executor: this.#executor,
            node: AlterTableNode.create(parseTable(table)),
        });
    }
    /**
     * Create a new view.
     *
     * ### Examples
     *
     * ```ts
     * await db.schema
     *   .createView('dogs')
     *   .orReplace()
     *   .as(db.selectFrom('pet').selectAll().where('species', '=', 'dog'))
     *   .execute()
     * ```
     */
    createView(viewName) {
        return new CreateViewBuilder({
            queryId: createQueryId(),
            executor: this.#executor,
            node: CreateViewNode.create(viewName),
        });
    }
    /**
     * Drop a view.
     *
     * ### Examples
     *
     * ```ts
     * await db.schema
     *   .dropView('dogs')
     *   .ifExists()
     *   .execute()
     * ```
     */
    dropView(viewName) {
        return new DropViewBuilder({
            queryId: createQueryId(),
            executor: this.#executor,
            node: DropViewNode.create(viewName),
        });
    }
    /**
     * Create a new type.
     *
     * Only some dialects like PostgreSQL have user-defined types.
     *
     * ### Examples
     *
     * ```ts
     * await db.schema
     *   .createType('species')
     *   .asEnum(['dog', 'cat', 'frog'])
     *   .execute()
     * ```
     */
    createType(typeName) {
        return new CreateTypeBuilder({
            queryId: createQueryId(),
            executor: this.#executor,
            node: CreateTypeNode.create(parseSchemableIdentifier(typeName)),
        });
    }
    /**
     * Drop a type.
     *
     * Only some dialects like PostgreSQL have user-defined types.
     *
     * ### Examples
     *
     * ```ts
     * await db.schema
     *   .dropType('species')
     *   .ifExists()
     *   .execute()
     * ```
     */
    dropType(typeName) {
        return new DropTypeBuilder({
            queryId: createQueryId(),
            executor: this.#executor,
            node: DropTypeNode.create(parseSchemableIdentifier(typeName)),
        });
    }
    /**
     * Returns a copy of this schema module with the given plugin installed.
     */
    withPlugin(plugin) {
        return new SchemaModule(this.#executor.withPlugin(plugin));
    }
    /**
     * Returns a copy of this schema module  without any plugins.
     */
    withoutPlugins() {
        return new SchemaModule(this.#executor.withoutPlugins());
    }
    /**
     * See {@link QueryCreator.withSchema}
     */
    withSchema(schema) {
        return new SchemaModule(this.#executor.withPluginAtFront(new WithSchemaPlugin(schema)));
    }
}

/// <reference types="./dynamic.d.ts" />
class DynamicModule {
    /**
     * Creates a dynamic reference to a column that is not know at compile time.
     *
     * Kysely is built in a way that by default you can't refer to tables or columns
     * that are not actually visible in the current query and context. This is all
     * done by TypeScript at compile time, which means that you need to know the
     * columns and tables at compile time. This is not always the case of course.
     *
     * This method is meant to be used in those cases where the column names
     * come from the user input or are not otherwise known at compile time.
     *
     * WARNING! Unlike values, column names are not escaped by the database engine
     * or Kysely and if you pass in unchecked column names using this method, you
     * create an SQL injection vulnerability. Always __always__ validate the user
     * input before passing it to this method.
     *
     * There are couple of examples below for some use cases, but you can pass
     * `ref` to other methods as well. If the types allow you to pass a `ref`
     * value to some place, it should work.
     *
     * ### Examples
     *
     * Filter by a column not know at compile time:
     *
     * ```ts
     * async function someQuery(filterColumn: string, filterValue: string) {
     *   const { ref } = db.dynamic
     *
     *   return await db
     *     .selectFrom('person')
     *     .selectAll()
     *     .where(ref(filterColumn), '=', filterValue)
     *     .execute()
     * }
     *
     * someQuery('first_name', 'Arnold')
     * someQuery('person.last_name', 'Aniston')
     * ```
     *
     * Order by a column not know at compile time:
     *
     * ```ts
     * async function someQuery(orderBy: string) {
     *   const { ref } = db.dynamic
     *
     *   return await db
     *     .selectFrom('person')
     *     .select('person.first_name as fn')
     *     .orderBy(ref(orderBy))
     *     .execute()
     * }
     *
     * someQuery('fn')
     * ```
     *
     * In this example we add selections dynamically:
     *
     * ```ts
     * const { ref } = db.dynamic
     *
     * // Some column name provided by the user. Value not known at compile time.
     * const columnFromUserInput = req.query.select;
     *
     * // A type that lists all possible values `columnFromUserInput` can have.
     * // You can use `keyof Person` if any column of an interface is allowed.
     * type PossibleColumns = 'last_name' | 'first_name' | 'birth_date'
     *
     * const [person] = await db.selectFrom('person')
     *   .select([
     *     ref<PossibleColumns>(columnFromUserInput),
     *     'id'
     *   ])
     *   .execute()
     *
     * // The resulting type contains all `PossibleColumns` as optional fields
     * // because we cannot know which field was actually selected before
     * // running the code.
     * const lastName: string | undefined = person.last_name
     * const firstName: string | undefined = person.first_name
     * const birthDate: string | undefined = person.birth_date
     *
     * // The result type also contains the compile time selection `id`.
     * person.id
     * ```
     */
    ref(reference) {
        return new DynamicReferenceBuilder(reference);
    }
}

/// <reference types="./default-connection-provider.d.ts" />
class DefaultConnectionProvider {
    #driver;
    constructor(driver) {
        this.#driver = driver;
    }
    async provideConnection(consumer) {
        const connection = await this.#driver.acquireConnection();
        try {
            return await consumer(connection);
        }
        finally {
            await this.#driver.releaseConnection(connection);
        }
    }
}

/// <reference types="./default-query-executor.d.ts" />
class DefaultQueryExecutor extends QueryExecutorBase {
    #compiler;
    #adapter;
    #connectionProvider;
    constructor(compiler, adapter, connectionProvider, plugins = []) {
        super(plugins);
        this.#compiler = compiler;
        this.#adapter = adapter;
        this.#connectionProvider = connectionProvider;
    }
    get adapter() {
        return this.#adapter;
    }
    compileQuery(node) {
        return this.#compiler.compileQuery(node);
    }
    provideConnection(consumer) {
        return this.#connectionProvider.provideConnection(consumer);
    }
    withPlugins(plugins) {
        return new DefaultQueryExecutor(this.#compiler, this.#adapter, this.#connectionProvider, [...this.plugins, ...plugins]);
    }
    withPlugin(plugin) {
        return new DefaultQueryExecutor(this.#compiler, this.#adapter, this.#connectionProvider, [...this.plugins, plugin]);
    }
    withPluginAtFront(plugin) {
        return new DefaultQueryExecutor(this.#compiler, this.#adapter, this.#connectionProvider, [plugin, ...this.plugins]);
    }
    withConnectionProvider(connectionProvider) {
        return new DefaultQueryExecutor(this.#compiler, this.#adapter, connectionProvider, [...this.plugins]);
    }
    withoutPlugins() {
        return new DefaultQueryExecutor(this.#compiler, this.#adapter, this.#connectionProvider, []);
    }
}

/// <reference types="./performance-now.d.ts" />
function performanceNow() {
    if (typeof performance !== 'undefined' && isFunction(performance.now)) {
        return performance.now();
    }
    else {
        return Date.now();
    }
}

/// <reference types="./runtime-driver.d.ts" />
/**
 * A small wrapper around {@link Driver} that makes sure the driver is
 * initialized before it is used, only initialized and destroyed
 * once etc.
 */
class RuntimeDriver {
    #driver;
    #log;
    #initPromise;
    #initDone;
    #destroyPromise;
    #connections = new WeakSet();
    constructor(driver, log) {
        this.#initDone = false;
        this.#driver = driver;
        this.#log = log;
    }
    async init() {
        if (this.#destroyPromise) {
            throw new Error('driver has already been destroyed');
        }
        if (!this.#initPromise) {
            this.#initPromise = this.#driver
                .init()
                .then(() => {
                this.#initDone = true;
            })
                .catch((err) => {
                this.#initPromise = undefined;
                return Promise.reject(err);
            });
        }
        await this.#initPromise;
    }
    async acquireConnection() {
        if (this.#destroyPromise) {
            throw new Error('driver has already been destroyed');
        }
        if (!this.#initDone) {
            await this.init();
        }
        const connection = await this.#driver.acquireConnection();
        if (!this.#connections.has(connection)) {
            if (this.#needsLogging()) {
                this.#addLogging(connection);
            }
            this.#connections.add(connection);
        }
        return connection;
    }
    async releaseConnection(connection) {
        await this.#driver.releaseConnection(connection);
    }
    beginTransaction(connection, settings) {
        return this.#driver.beginTransaction(connection, settings);
    }
    commitTransaction(connection) {
        return this.#driver.commitTransaction(connection);
    }
    rollbackTransaction(connection) {
        return this.#driver.rollbackTransaction(connection);
    }
    async destroy() {
        if (!this.#initPromise) {
            return;
        }
        await this.#initPromise;
        if (!this.#destroyPromise) {
            this.#destroyPromise = this.#driver.destroy().catch((err) => {
                this.#destroyPromise = undefined;
                return Promise.reject(err);
            });
        }
        await this.#destroyPromise;
    }
    #needsLogging() {
        return (this.#log.isLevelEnabled('query') || this.#log.isLevelEnabled('error'));
    }
    // This method monkey patches the database connection's executeQuery method
    // by adding logging code around it. Monkey patching is not pretty, but it's
    // the best option in this case.
    #addLogging(connection) {
        const executeQuery = connection.executeQuery;
        connection.executeQuery = async (compiledQuery) => {
            let caughtError;
            const startTime = performanceNow();
            try {
                return await executeQuery.call(connection, compiledQuery);
            }
            catch (error) {
                caughtError = error;
                await this.#logError(error, compiledQuery, startTime);
                throw error;
            }
            finally {
                if (!caughtError) {
                    await this.#logQuery(compiledQuery, startTime);
                }
            }
        };
    }
    async #logError(error, compiledQuery, startTime) {
        await this.#log.error(() => ({
            level: 'error',
            error,
            query: compiledQuery,
            queryDurationMillis: this.#calculateDurationMillis(startTime),
        }));
    }
    async #logQuery(compiledQuery, startTime) {
        await this.#log.query(() => ({
            level: 'query',
            query: compiledQuery,
            queryDurationMillis: this.#calculateDurationMillis(startTime),
        }));
    }
    #calculateDurationMillis(startTime) {
        return performanceNow() - startTime;
    }
}

/// <reference types="./single-connection-provider.d.ts" />
const ignoreError = () => { };
class SingleConnectionProvider {
    #connection;
    #runningPromise;
    constructor(connection) {
        this.#connection = connection;
    }
    async provideConnection(consumer) {
        while (this.#runningPromise) {
            await this.#runningPromise.catch(ignoreError);
        }
        // `#runningPromise` must be set to undefined before it's
        // resolved or rejected. Otherwise the while loop above
        // will misbehave.
        this.#runningPromise = this.#run(consumer).finally(() => {
            this.#runningPromise = undefined;
        });
        return this.#runningPromise;
    }
    // Run the runner in an async function to make sure it doesn't
    // throw synchronous errors.
    async #run(runner) {
        return await runner(this.#connection);
    }
}

/// <reference types="./driver.d.ts" />
const TRANSACTION_ISOLATION_LEVELS = [
    'read uncommitted',
    'read committed',
    'repeatable read',
    'serializable',
    'snapshot',
];

/// <reference types="./log.d.ts" />
freeze(['query', 'error']);
class Log {
    #levels;
    #logger;
    constructor(config) {
        if (isFunction(config)) {
            this.#logger = config;
            this.#levels = freeze({
                query: true,
                error: true,
            });
        }
        else {
            this.#logger = defaultLogger;
            this.#levels = freeze({
                query: config.includes('query'),
                error: config.includes('error'),
            });
        }
    }
    isLevelEnabled(level) {
        return this.#levels[level];
    }
    async query(getEvent) {
        if (this.#levels.query) {
            await this.#logger(getEvent());
        }
    }
    async error(getEvent) {
        if (this.#levels.error) {
            await this.#logger(getEvent());
        }
    }
}
function defaultLogger(event) {
    if (event.level === 'query') {
        console.log(`kysely:query: ${event.query.sql}`);
        console.log(`kysely:query: duration: ${event.queryDurationMillis.toFixed(1)}ms`);
    }
    else if (event.level === 'error') {
        if (event.error instanceof Error) {
            console.error(`kysely:error: ${event.error.stack ?? event.error.message}`);
        }
        else {
            console.error(`kysely:error: ${JSON.stringify({
                error: event.error,
                query: event.query.sql,
                queryDurationMillis: event.queryDurationMillis,
            })}`);
        }
    }
}

/// <reference types="./compilable.d.ts" />
function isCompilable(value) {
    return isObject(value) && isFunction(value.compile);
}

/// <reference types="./kysely.d.ts" />
/**
 * The main Kysely class.
 *
 * You should create one instance of `Kysely` per database using the {@link Kysely}
 * constructor. Each `Kysely` instance maintains its own connection pool.
 *
 * ### Examples
 *
 * This example assumes your database has tables `person` and `pet`:
 *
 * ```ts
 * import {Kysely, Generated, PostgresDialect } from 'kysely'
 *
 * interface PersonTable {
 *   id: Generated<number>
 *   first_name: string
 *   last_name: string
 * }
 *
 * interface PetTable {
 *   id: Generated<number>
 *   owner_id: number
 *   name: string
 *   species: 'cat' | 'dog'
 * }
 *
 * interface Database {
 *   person: PersonTable,
 *   pet: PetTable
 * }
 *
 * const db = new Kysely<Database>({
 *   dialect: new PostgresDialect({
 *     host: 'localhost',
 *     database: 'kysely_test',
 *   })
 * })
 * ```
 *
 * @typeParam DB - The database interface type. Keys of this type must be table names
 *    in the database and values must be interfaces that describe the rows in those
 *    tables. See the examples above.
 */
class Kysely extends QueryCreator {
    #props;
    constructor(args) {
        let superProps;
        let props;
        if (isKyselyProps(args)) {
            superProps = { executor: args.executor };
            props = { ...args };
        }
        else {
            const dialect = args.dialect;
            const driver = dialect.createDriver();
            const compiler = dialect.createQueryCompiler();
            const adapter = dialect.createAdapter();
            const log = new Log(args.log ?? []);
            const runtimeDriver = new RuntimeDriver(driver, log);
            const connectionProvider = new DefaultConnectionProvider(runtimeDriver);
            const executor = new DefaultQueryExecutor(compiler, adapter, connectionProvider, args.plugins ?? []);
            superProps = { executor };
            props = {
                config: args,
                executor,
                dialect,
                driver: runtimeDriver,
            };
        }
        super(superProps);
        this.#props = freeze(props);
    }
    /**
     * Returns the {@link SchemaModule} module for building database schema.
     */
    get schema() {
        return new SchemaModule(this.#props.executor);
    }
    /**
     * Returns a the {@link DynamicModule} module.
     *
     * The {@link DynamicModule} module can be used to bypass strict typing and
     * passing in dynamic values for the queries.
     */
    get dynamic() {
        return new DynamicModule();
    }
    /**
     * Returns a {@link DatabaseIntrospector | database introspector}.
     */
    get introspection() {
        return this.#props.dialect.createIntrospector(this.withoutPlugins());
    }
    case(value) {
        return new CaseBuilder({
            node: CaseNode.create(isUndefined(value) ? undefined : parseExpression(value)),
        });
    }
    /**
     * Returns a {@link FunctionModule} that can be used to write type safe function
     * calls.
     *
     * ```ts
     * await db.selectFrom('person')
     *   .innerJoin('pet', 'pet.owner_id', 'person.id')
     *   .select((eb) => [
     *     'person.id',
     *     eb.fn.count('pet.id').as('pet_count')
     *   ])
     *   .groupBy('person.id')
     *   .having((eb) => eb.fn.count('pet.id'), '>', 10)
     *   .execute()
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * select "person"."id", count("pet"."id") as "pet_count"
     * from "person"
     * inner join "pet" on "pet"."owner_id" = "person"."id"
     * group by "person"."id"
     * having count("pet"."id") > $1
     * ```
     */
    get fn() {
        return createFunctionModule();
    }
    /**
     * Creates a {@link TransactionBuilder} that can be used to run queries inside a transaction.
     *
     * The returned {@link TransactionBuilder} can be used to configure the transaction. The
     * {@link TransactionBuilder.execute} method can then be called to run the transaction.
     * {@link TransactionBuilder.execute} takes a function that is run inside the
     * transaction. If the function throws, the transaction is rolled back. Otherwise
     * the transaction is committed.
     *
     * The callback function passed to the {@link TransactionBuilder.execute | execute}
     * method gets the transaction object as its only argument. The transaction is
     * of type {@link Transaction} which inherits {@link Kysely}. Any query
     * started through the transaction object is executed inside the transaction.
     *
     * ### Examples
     *
     * <!-- siteExample("transactions", "Simple transaction", 10) -->
     *
     * This example inserts two rows in a transaction. If an error is thrown inside
     * the callback passed to the `execute` method, the transaction is rolled back.
     * Otherwise it's committed.
     *
     * ```ts
     * const catto = await db.transaction().execute(async (trx) => {
     *   const jennifer = await trx.insertInto('person')
     *     .values({
     *       first_name: 'Jennifer',
     *       last_name: 'Aniston',
     *       age: 40,
     *     })
     *     .returning('id')
     *     .executeTakeFirstOrThrow()
     *
     *   return await trx.insertInto('pet')
     *     .values({
     *       owner_id: jennifer.id,
     *       name: 'Catto',
     *       species: 'cat',
     *       is_favorite: false,
     *     })
     *     .returningAll()
     *     .executeTakeFirst()
     * })
     * ```
     *
     * Setting the isolation level:
     *
     * ```ts
     * await db
     *   .transaction()
     *   .setIsolationLevel('serializable')
     *   .execute(async (trx) => {
     *     await doStuff(trx)
     *   })
     * ```
     */
    transaction() {
        return new TransactionBuilder({ ...this.#props });
    }
    /**
     * Provides a kysely instance bound to a single database connection.
     *
     * ### Examples
     *
     * ```ts
     * await db
     *   .connection()
     *   .execute(async (db) => {
     *     // `db` is an instance of `Kysely` that's bound to a single
     *     // database connection. All queries executed through `db` use
     *     // the same connection.
     *     await doStuff(db)
     *   })
     * ```
     */
    connection() {
        return new ConnectionBuilder({ ...this.#props });
    }
    /**
     * Returns a copy of this Kysely instance with the given plugin installed.
     */
    withPlugin(plugin) {
        return new Kysely({
            ...this.#props,
            executor: this.#props.executor.withPlugin(plugin),
        });
    }
    /**
     * Returns a copy of this Kysely instance without any plugins.
     */
    withoutPlugins() {
        return new Kysely({
            ...this.#props,
            executor: this.#props.executor.withoutPlugins(),
        });
    }
    /**
     * @override
     */
    withSchema(schema) {
        return new Kysely({
            ...this.#props,
            executor: this.#props.executor.withPluginAtFront(new WithSchemaPlugin(schema)),
        });
    }
    /**
     * Returns a copy of this Kysely instance with tables added to its
     * database type.
     *
     * This method only modifies the types and doesn't affect any of the
     * executed queries in any way.
     *
     * ### Examples
     *
     * The following example adds and uses a temporary table:
     *
     * @example
     * ```ts
     * await db.schema
     *   .createTable('temp_table')
     *   .temporary()
     *   .addColumn('some_column', 'integer')
     *   .execute()
     *
     * const tempDb = db.withTables<{
     *   temp_table: {
     *     some_column: number
     *   }
     * }>()
     *
     * await tempDb
     *   .insertInto('temp_table')
     *   .values({ some_column: 100 })
     *   .execute()
     * ```
     */
    withTables() {
        return new Kysely({ ...this.#props });
    }
    /**
     * Releases all resources and disconnects from the database.
     *
     * You need to call this when you are done using the `Kysely` instance.
     */
    async destroy() {
        await this.#props.driver.destroy();
    }
    /**
     * Returns true if this `Kysely` instance is a transaction.
     *
     * You can also use `db instanceof Transaction`.
     */
    get isTransaction() {
        return false;
    }
    /**
     * @internal
     * @private
     */
    getExecutor() {
        return this.#props.executor;
    }
    /**
     * Executes a given compiled query or query builder.
     *
     * See {@link https://github.com/koskimas/kysely/blob/master/site/docs/recipes/splitting-build-compile-and-execute-code.md#execute-compiled-queries splitting build, compile and execute code recipe} for more information.
     */
    executeQuery(query, queryId = createQueryId()) {
        const compiledQuery = isCompilable(query) ? query.compile() : query;
        return this.getExecutor().executeQuery(compiledQuery, queryId);
    }
}
class Transaction extends Kysely {
    #props;
    constructor(props) {
        super(props);
        this.#props = props;
    }
    // The return type is `true` instead of `boolean` to make Kysely<DB>
    // unassignable to Transaction<DB> while allowing assignment the
    // other way around.
    get isTransaction() {
        return true;
    }
    transaction() {
        throw new Error('calling the transaction method for a Transaction is not supported');
    }
    connection() {
        throw new Error('calling the connection method for a Transaction is not supported');
    }
    async destroy() {
        throw new Error('calling the destroy method for a Transaction is not supported');
    }
    withPlugin(plugin) {
        return new Transaction({
            ...this.#props,
            executor: this.#props.executor.withPlugin(plugin),
        });
    }
    withoutPlugins() {
        return new Transaction({
            ...this.#props,
            executor: this.#props.executor.withoutPlugins(),
        });
    }
    /**
     * @override
     */
    withSchema(schema) {
        return new Transaction({
            ...this.#props,
            executor: this.#props.executor.withPluginAtFront(new WithSchemaPlugin(schema)),
        });
    }
    withTables() {
        return new Transaction({ ...this.#props });
    }
}
function isKyselyProps(obj) {
    return (isObject(obj) &&
        isObject(obj.config) &&
        isObject(obj.driver) &&
        isObject(obj.executor) &&
        isObject(obj.dialect));
}
class ConnectionBuilder {
    #props;
    constructor(props) {
        this.#props = freeze(props);
    }
    async execute(callback) {
        return this.#props.executor.provideConnection(async (connection) => {
            const executor = this.#props.executor.withConnectionProvider(new SingleConnectionProvider(connection));
            const db = new Kysely({
                ...this.#props,
                executor,
            });
            return await callback(db);
        });
    }
}
preventAwait(ConnectionBuilder, "don't await ConnectionBuilder instances directly. To execute the query you need to call the `execute` method");
class TransactionBuilder {
    #props;
    constructor(props) {
        this.#props = freeze(props);
    }
    setIsolationLevel(isolationLevel) {
        return new TransactionBuilder({
            ...this.#props,
            isolationLevel,
        });
    }
    async execute(callback) {
        const { isolationLevel, ...kyselyProps } = this.#props;
        const settings = { isolationLevel };
        validateTransactionSettings(settings);
        return this.#props.executor.provideConnection(async (connection) => {
            const executor = this.#props.executor.withConnectionProvider(new SingleConnectionProvider(connection));
            const transaction = new Transaction({
                ...kyselyProps,
                executor,
            });
            try {
                await this.#props.driver.beginTransaction(connection, settings);
                const result = await callback(transaction);
                await this.#props.driver.commitTransaction(connection);
                return result;
            }
            catch (error) {
                await this.#props.driver.rollbackTransaction(connection);
                throw error;
            }
        });
    }
}
preventAwait(TransactionBuilder, "don't await TransactionBuilder instances directly. To execute the transaction you need to call the `execute` method");
function validateTransactionSettings(settings) {
    if (settings.isolationLevel &&
        !TRANSACTION_ISOLATION_LEVELS.includes(settings.isolationLevel)) {
        throw new Error(`invalid transaction isolation level ${settings.isolationLevel}`);
    }
}

/// <reference types="./raw-builder.d.ts" />
class RawBuilderImpl {
    #props;
    constructor(props) {
        this.#props = freeze(props);
    }
    get expressionType() {
        return undefined;
    }
    get isRawBuilder() {
        return true;
    }
    as(alias) {
        return new AliasedRawBuilderImpl(this, alias);
    }
    $castTo() {
        return new RawBuilderImpl({ ...this.#props });
    }
    $notNull() {
        return new RawBuilderImpl(this.#props);
    }
    withPlugin(plugin) {
        return new RawBuilderImpl({
            ...this.#props,
            plugins: this.#props.plugins !== undefined
                ? freeze([...this.#props.plugins, plugin])
                : freeze([plugin]),
        });
    }
    toOperationNode() {
        return this.#toOperationNode(this.#getExecutor());
    }
    compile(executorProvider) {
        return this.#compile(this.#getExecutor(executorProvider));
    }
    async execute(executorProvider) {
        const executor = this.#getExecutor(executorProvider);
        return executor.executeQuery(this.#compile(executor), this.#props.queryId);
    }
    #getExecutor(executorProvider) {
        const executor = executorProvider !== undefined
            ? executorProvider.getExecutor()
            : NOOP_QUERY_EXECUTOR;
        return this.#props.plugins !== undefined
            ? executor.withPlugins(this.#props.plugins)
            : executor;
    }
    #toOperationNode(executor) {
        return executor.transformQuery(this.#props.rawNode, this.#props.queryId);
    }
    #compile(executor) {
        return executor.compileQuery(this.#toOperationNode(executor), this.#props.queryId);
    }
}
function createRawBuilder(props) {
    return new RawBuilderImpl(props);
}
preventAwait(RawBuilderImpl, "don't await RawBuilder instances directly. To execute the query you need to call `execute`");
class AliasedRawBuilderImpl {
    #rawBuilder;
    #alias;
    constructor(rawBuilder, alias) {
        this.#rawBuilder = rawBuilder;
        this.#alias = alias;
    }
    get expression() {
        return this.#rawBuilder;
    }
    get alias() {
        return this.#alias;
    }
    get rawBuilder() {
        return this.#rawBuilder;
    }
    toOperationNode() {
        return AliasNode.create(this.#rawBuilder.toOperationNode(), isOperationNodeSource(this.#alias)
            ? this.#alias.toOperationNode()
            : IdentifierNode.create(this.#alias));
    }
}
preventAwait(AliasedRawBuilderImpl, "don't await AliasedRawBuilder instances directly. AliasedRawBuilder should never be executed directly since it's always a part of another query.");

/// <reference types="./sql.d.ts" />
const sql = Object.assign((sqlFragments, ...parameters) => {
    return createRawBuilder({
        queryId: createQueryId(),
        rawNode: RawNode.create(sqlFragments, parameters?.map(parseParameter) ?? []),
    });
}, {
    ref(columnReference) {
        return createRawBuilder({
            queryId: createQueryId(),
            rawNode: RawNode.createWithChild(parseStringReference(columnReference)),
        });
    },
    val(value) {
        return createRawBuilder({
            queryId: createQueryId(),
            rawNode: RawNode.createWithChild(parseValueExpression(value)),
        });
    },
    value(value) {
        return this.val(value);
    },
    table(tableReference) {
        return createRawBuilder({
            queryId: createQueryId(),
            rawNode: RawNode.createWithChild(parseTable(tableReference)),
        });
    },
    id(...ids) {
        const fragments = new Array(ids.length + 1).fill('.');
        fragments[0] = '';
        fragments[fragments.length - 1] = '';
        return createRawBuilder({
            queryId: createQueryId(),
            rawNode: RawNode.create(fragments, ids.map(IdentifierNode.create)),
        });
    },
    lit(value) {
        return createRawBuilder({
            queryId: createQueryId(),
            rawNode: RawNode.createWithChild(ValueNode.createImmediate(value)),
        });
    },
    literal(value) {
        return this.lit(value);
    },
    raw(sql) {
        return createRawBuilder({
            queryId: createQueryId(),
            rawNode: RawNode.createWithSql(sql),
        });
    },
    join(array, separator = sql `, `) {
        const nodes = new Array(2 * array.length - 1);
        const sep = separator.toOperationNode();
        for (let i = 0; i < array.length; ++i) {
            nodes[2 * i] = parseParameter(array[i]);
            if (i !== array.length - 1) {
                nodes[2 * i + 1] = sep;
            }
        }
        return createRawBuilder({
            queryId: createQueryId(),
            rawNode: RawNode.createWithChildren(nodes),
        });
    },
});
function parseParameter(param) {
    if (isOperationNodeSource(param)) {
        return param.toOperationNode();
    }
    return parseValueExpression(param);
}

/// <reference types="./operation-node-visitor.d.ts" />
class OperationNodeVisitor {
    nodeStack = [];
    get parentNode() {
        return this.nodeStack[this.nodeStack.length - 2];
    }
    #visitors = freeze({
        AliasNode: this.visitAlias.bind(this),
        ColumnNode: this.visitColumn.bind(this),
        IdentifierNode: this.visitIdentifier.bind(this),
        SchemableIdentifierNode: this.visitSchemableIdentifier.bind(this),
        RawNode: this.visitRaw.bind(this),
        ReferenceNode: this.visitReference.bind(this),
        SelectQueryNode: this.visitSelectQuery.bind(this),
        SelectionNode: this.visitSelection.bind(this),
        TableNode: this.visitTable.bind(this),
        FromNode: this.visitFrom.bind(this),
        SelectAllNode: this.visitSelectAll.bind(this),
        AndNode: this.visitAnd.bind(this),
        OrNode: this.visitOr.bind(this),
        ValueNode: this.visitValue.bind(this),
        ValueListNode: this.visitValueList.bind(this),
        PrimitiveValueListNode: this.visitPrimitiveValueList.bind(this),
        ParensNode: this.visitParens.bind(this),
        JoinNode: this.visitJoin.bind(this),
        OperatorNode: this.visitOperator.bind(this),
        WhereNode: this.visitWhere.bind(this),
        InsertQueryNode: this.visitInsertQuery.bind(this),
        DeleteQueryNode: this.visitDeleteQuery.bind(this),
        ReturningNode: this.visitReturning.bind(this),
        CreateTableNode: this.visitCreateTable.bind(this),
        AddColumnNode: this.visitAddColumn.bind(this),
        ColumnDefinitionNode: this.visitColumnDefinition.bind(this),
        DropTableNode: this.visitDropTable.bind(this),
        DataTypeNode: this.visitDataType.bind(this),
        OrderByNode: this.visitOrderBy.bind(this),
        OrderByItemNode: this.visitOrderByItem.bind(this),
        GroupByNode: this.visitGroupBy.bind(this),
        GroupByItemNode: this.visitGroupByItem.bind(this),
        UpdateQueryNode: this.visitUpdateQuery.bind(this),
        ColumnUpdateNode: this.visitColumnUpdate.bind(this),
        LimitNode: this.visitLimit.bind(this),
        OffsetNode: this.visitOffset.bind(this),
        OnConflictNode: this.visitOnConflict.bind(this),
        OnDuplicateKeyNode: this.visitOnDuplicateKey.bind(this),
        CreateIndexNode: this.visitCreateIndex.bind(this),
        DropIndexNode: this.visitDropIndex.bind(this),
        ListNode: this.visitList.bind(this),
        PrimaryKeyConstraintNode: this.visitPrimaryKeyConstraint.bind(this),
        UniqueConstraintNode: this.visitUniqueConstraint.bind(this),
        ReferencesNode: this.visitReferences.bind(this),
        CheckConstraintNode: this.visitCheckConstraint.bind(this),
        WithNode: this.visitWith.bind(this),
        CommonTableExpressionNode: this.visitCommonTableExpression.bind(this),
        CommonTableExpressionNameNode: this.visitCommonTableExpressionName.bind(this),
        HavingNode: this.visitHaving.bind(this),
        CreateSchemaNode: this.visitCreateSchema.bind(this),
        DropSchemaNode: this.visitDropSchema.bind(this),
        AlterTableNode: this.visitAlterTable.bind(this),
        DropColumnNode: this.visitDropColumn.bind(this),
        RenameColumnNode: this.visitRenameColumn.bind(this),
        AlterColumnNode: this.visitAlterColumn.bind(this),
        ModifyColumnNode: this.visitModifyColumn.bind(this),
        AddConstraintNode: this.visitAddConstraint.bind(this),
        DropConstraintNode: this.visitDropConstraint.bind(this),
        ForeignKeyConstraintNode: this.visitForeignKeyConstraint.bind(this),
        CreateViewNode: this.visitCreateView.bind(this),
        DropViewNode: this.visitDropView.bind(this),
        GeneratedNode: this.visitGenerated.bind(this),
        DefaultValueNode: this.visitDefaultValue.bind(this),
        OnNode: this.visitOn.bind(this),
        ValuesNode: this.visitValues.bind(this),
        SelectModifierNode: this.visitSelectModifier.bind(this),
        CreateTypeNode: this.visitCreateType.bind(this),
        DropTypeNode: this.visitDropType.bind(this),
        ExplainNode: this.visitExplain.bind(this),
        DefaultInsertValueNode: this.visitDefaultInsertValue.bind(this),
        AggregateFunctionNode: this.visitAggregateFunction.bind(this),
        OverNode: this.visitOver.bind(this),
        PartitionByNode: this.visitPartitionBy.bind(this),
        PartitionByItemNode: this.visitPartitionByItem.bind(this),
        SetOperationNode: this.visitSetOperation.bind(this),
        BinaryOperationNode: this.visitBinaryOperation.bind(this),
        UnaryOperationNode: this.visitUnaryOperation.bind(this),
        UsingNode: this.visitUsing.bind(this),
        FunctionNode: this.visitFunction.bind(this),
        CaseNode: this.visitCase.bind(this),
        WhenNode: this.visitWhen.bind(this),
        JSONReferenceNode: this.visitJSONReference.bind(this),
        JSONPathNode: this.visitJSONPath.bind(this),
        JSONPathLegNode: this.visitJSONPathLeg.bind(this),
        JSONOperatorChainNode: this.visitJSONOperatorChain.bind(this),
        TupleNode: this.visitTuple.bind(this),
        MergeQueryNode: this.visitMergeQuery.bind(this),
        MatchedNode: this.visitMatched.bind(this),
        AddIndexNode: this.visitAddIndex.bind(this),
        CastNode: this.visitCast.bind(this),
        FetchNode: this.visitFetch.bind(this),
        TopNode: this.visitTop.bind(this),
        OutputNode: this.visitOutput.bind(this),
    });
    visitNode = (node) => {
        this.nodeStack.push(node);
        this.#visitors[node.kind](node);
        this.nodeStack.pop();
    };
}

/// <reference types="./default-query-compiler.d.ts" />
class DefaultQueryCompiler extends OperationNodeVisitor {
    #sql = '';
    #parameters = [];
    get numParameters() {
        return this.#parameters.length;
    }
    compileQuery(node) {
        this.#sql = '';
        this.#parameters = [];
        this.nodeStack.splice(0, this.nodeStack.length);
        this.visitNode(node);
        return freeze({
            query: node,
            sql: this.getSql(),
            parameters: [...this.#parameters],
        });
    }
    getSql() {
        return this.#sql;
    }
    visitSelectQuery(node) {
        const wrapInParens = this.parentNode !== undefined &&
            !ParensNode.is(this.parentNode) &&
            !InsertQueryNode.is(this.parentNode) &&
            !CreateTableNode.is(this.parentNode) &&
            !CreateViewNode.is(this.parentNode) &&
            !SetOperationNode.is(this.parentNode);
        if (this.parentNode === undefined && node.explain) {
            this.visitNode(node.explain);
            this.append(' ');
        }
        if (wrapInParens) {
            this.append('(');
        }
        if (node.with) {
            this.visitNode(node.with);
            this.append(' ');
        }
        this.append('select');
        if (node.distinctOn) {
            this.append(' ');
            this.compileDistinctOn(node.distinctOn);
        }
        if (node.frontModifiers?.length) {
            this.append(' ');
            this.compileList(node.frontModifiers, ' ');
        }
        if (node.top) {
            this.append(' ');
            this.visitNode(node.top);
        }
        if (node.selections) {
            this.append(' ');
            this.compileList(node.selections);
        }
        if (node.from) {
            this.append(' ');
            this.visitNode(node.from);
        }
        if (node.joins) {
            this.append(' ');
            this.compileList(node.joins, ' ');
        }
        if (node.where) {
            this.append(' ');
            this.visitNode(node.where);
        }
        if (node.groupBy) {
            this.append(' ');
            this.visitNode(node.groupBy);
        }
        if (node.having) {
            this.append(' ');
            this.visitNode(node.having);
        }
        if (node.setOperations) {
            this.append(' ');
            this.compileList(node.setOperations, ' ');
        }
        if (node.orderBy) {
            this.append(' ');
            this.visitNode(node.orderBy);
        }
        if (node.limit) {
            this.append(' ');
            this.visitNode(node.limit);
        }
        if (node.offset) {
            this.append(' ');
            this.visitNode(node.offset);
        }
        if (node.fetch) {
            this.append(' ');
            this.visitNode(node.fetch);
        }
        if (node.endModifiers?.length) {
            this.append(' ');
            this.compileList(this.sortSelectModifiers([...node.endModifiers]), ' ');
        }
        if (wrapInParens) {
            this.append(')');
        }
    }
    visitFrom(node) {
        this.append('from ');
        this.compileList(node.froms);
    }
    visitSelection(node) {
        this.visitNode(node.selection);
    }
    visitColumn(node) {
        this.visitNode(node.column);
    }
    compileDistinctOn(expressions) {
        this.append('distinct on (');
        this.compileList(expressions);
        this.append(')');
    }
    compileList(nodes, separator = ', ') {
        const lastIndex = nodes.length - 1;
        for (let i = 0; i <= lastIndex; i++) {
            this.visitNode(nodes[i]);
            if (i < lastIndex) {
                this.append(separator);
            }
        }
    }
    visitWhere(node) {
        this.append('where ');
        this.visitNode(node.where);
    }
    visitHaving(node) {
        this.append('having ');
        this.visitNode(node.having);
    }
    visitInsertQuery(node) {
        const rootQueryNode = this.nodeStack.find(QueryNode.is);
        const isSubQuery = rootQueryNode !== node;
        if (!isSubQuery && node.explain) {
            this.visitNode(node.explain);
            this.append(' ');
        }
        if (isSubQuery && !MergeQueryNode.is(rootQueryNode)) {
            this.append('(');
        }
        if (node.with) {
            this.visitNode(node.with);
            this.append(' ');
        }
        this.append(node.replace ? 'replace' : 'insert');
        if (node.ignore) {
            this.append(' ignore');
        }
        if (node.top) {
            this.append(' ');
            this.visitNode(node.top);
        }
        if (node.into) {
            this.append(' into ');
            this.visitNode(node.into);
        }
        if (node.columns) {
            this.append(' (');
            this.compileList(node.columns);
            this.append(')');
        }
        if (node.output) {
            this.append(' ');
            this.visitNode(node.output);
        }
        if (node.values) {
            this.append(' ');
            this.visitNode(node.values);
        }
        if (node.defaultValues) {
            this.append(' ');
            this.append('default values');
        }
        if (node.onConflict) {
            this.append(' ');
            this.visitNode(node.onConflict);
        }
        if (node.onDuplicateKey) {
            this.append(' ');
            this.visitNode(node.onDuplicateKey);
        }
        if (node.returning) {
            this.append(' ');
            this.visitNode(node.returning);
        }
        if (isSubQuery && !MergeQueryNode.is(rootQueryNode)) {
            this.append(')');
        }
    }
    visitValues(node) {
        this.append('values ');
        this.compileList(node.values);
    }
    visitDeleteQuery(node) {
        const isSubQuery = this.nodeStack.find(QueryNode.is) !== node;
        if (!isSubQuery && node.explain) {
            this.visitNode(node.explain);
            this.append(' ');
        }
        if (isSubQuery) {
            this.append('(');
        }
        if (node.with) {
            this.visitNode(node.with);
            this.append(' ');
        }
        this.append('delete ');
        if (node.top) {
            this.visitNode(node.top);
            this.append(' ');
        }
        this.visitNode(node.from);
        if (node.output) {
            this.append(' ');
            this.visitNode(node.output);
        }
        if (node.using) {
            this.append(' ');
            this.visitNode(node.using);
        }
        if (node.joins) {
            this.append(' ');
            this.compileList(node.joins, ' ');
        }
        if (node.where) {
            this.append(' ');
            this.visitNode(node.where);
        }
        if (node.orderBy) {
            this.append(' ');
            this.visitNode(node.orderBy);
        }
        if (node.limit) {
            this.append(' ');
            this.visitNode(node.limit);
        }
        if (node.returning) {
            this.append(' ');
            this.visitNode(node.returning);
        }
        if (isSubQuery) {
            this.append(')');
        }
    }
    visitReturning(node) {
        this.append('returning ');
        this.compileList(node.selections);
    }
    visitAlias(node) {
        this.visitNode(node.node);
        this.append(' as ');
        this.visitNode(node.alias);
    }
    visitReference(node) {
        if (node.table) {
            this.visitNode(node.table);
            this.append('.');
        }
        this.visitNode(node.column);
    }
    visitSelectAll(_) {
        this.append('*');
    }
    visitIdentifier(node) {
        this.append(this.getLeftIdentifierWrapper());
        this.compileUnwrappedIdentifier(node);
        this.append(this.getRightIdentifierWrapper());
    }
    compileUnwrappedIdentifier(node) {
        if (!isString(node.name)) {
            throw new Error('a non-string identifier was passed to compileUnwrappedIdentifier.');
        }
        this.append(this.sanitizeIdentifier(node.name));
    }
    visitAnd(node) {
        this.visitNode(node.left);
        this.append(' and ');
        this.visitNode(node.right);
    }
    visitOr(node) {
        this.visitNode(node.left);
        this.append(' or ');
        this.visitNode(node.right);
    }
    visitValue(node) {
        if (node.immediate) {
            this.appendImmediateValue(node.value);
        }
        else {
            this.appendValue(node.value);
        }
    }
    visitValueList(node) {
        this.append('(');
        this.compileList(node.values);
        this.append(')');
    }
    visitTuple(node) {
        this.append('(');
        this.compileList(node.values);
        this.append(')');
    }
    visitPrimitiveValueList(node) {
        this.append('(');
        const { values } = node;
        for (let i = 0; i < values.length; ++i) {
            this.appendValue(values[i]);
            if (i !== values.length - 1) {
                this.append(', ');
            }
        }
        this.append(')');
    }
    visitParens(node) {
        this.append('(');
        this.visitNode(node.node);
        this.append(')');
    }
    visitJoin(node) {
        this.append(JOIN_TYPE_SQL[node.joinType]);
        this.append(' ');
        this.visitNode(node.table);
        if (node.on) {
            this.append(' ');
            this.visitNode(node.on);
        }
    }
    visitOn(node) {
        this.append('on ');
        this.visitNode(node.on);
    }
    visitRaw(node) {
        const { sqlFragments, parameters: params } = node;
        for (let i = 0; i < sqlFragments.length; ++i) {
            this.append(sqlFragments[i]);
            if (params.length > i) {
                this.visitNode(params[i]);
            }
        }
    }
    visitOperator(node) {
        this.append(node.operator);
    }
    visitTable(node) {
        this.visitNode(node.table);
    }
    visitSchemableIdentifier(node) {
        if (node.schema) {
            this.visitNode(node.schema);
            this.append('.');
        }
        this.visitNode(node.identifier);
    }
    visitCreateTable(node) {
        this.append('create ');
        if (node.frontModifiers && node.frontModifiers.length > 0) {
            this.compileList(node.frontModifiers, ' ');
            this.append(' ');
        }
        if (node.temporary) {
            this.append('temporary ');
        }
        this.append('table ');
        if (node.ifNotExists) {
            this.append('if not exists ');
        }
        this.visitNode(node.table);
        if (node.selectQuery) {
            this.append(' as ');
            this.visitNode(node.selectQuery);
        }
        else {
            this.append(' (');
            this.compileList([...node.columns, ...(node.constraints ?? [])]);
            this.append(')');
            if (node.onCommit) {
                this.append(' on commit ');
                this.append(node.onCommit);
            }
            if (node.endModifiers && node.endModifiers.length > 0) {
                this.append(' ');
                this.compileList(node.endModifiers, ' ');
            }
        }
    }
    visitColumnDefinition(node) {
        if (node.ifNotExists) {
            this.append('if not exists ');
        }
        this.visitNode(node.column);
        this.append(' ');
        this.visitNode(node.dataType);
        if (node.unsigned) {
            this.append(' unsigned');
        }
        if (node.frontModifiers && node.frontModifiers.length > 0) {
            this.append(' ');
            this.compileList(node.frontModifiers, ' ');
        }
        if (node.generated) {
            this.append(' ');
            this.visitNode(node.generated);
        }
        if (node.identity) {
            this.append(' identity');
        }
        if (node.defaultTo) {
            this.append(' ');
            this.visitNode(node.defaultTo);
        }
        if (node.notNull) {
            this.append(' not null');
        }
        if (node.unique) {
            this.append(' unique');
        }
        if (node.nullsNotDistinct) {
            this.append(' nulls not distinct');
        }
        if (node.primaryKey) {
            this.append(' primary key');
        }
        if (node.autoIncrement) {
            this.append(' ');
            this.append(this.getAutoIncrement());
        }
        if (node.references) {
            this.append(' ');
            this.visitNode(node.references);
        }
        if (node.check) {
            this.append(' ');
            this.visitNode(node.check);
        }
        if (node.endModifiers && node.endModifiers.length > 0) {
            this.append(' ');
            this.compileList(node.endModifiers, ' ');
        }
    }
    getAutoIncrement() {
        return 'auto_increment';
    }
    visitReferences(node) {
        this.append('references ');
        this.visitNode(node.table);
        this.append(' (');
        this.compileList(node.columns);
        this.append(')');
        if (node.onDelete) {
            this.append(' on delete ');
            this.append(node.onDelete);
        }
        if (node.onUpdate) {
            this.append(' on update ');
            this.append(node.onUpdate);
        }
    }
    visitDropTable(node) {
        this.append('drop table ');
        if (node.ifExists) {
            this.append('if exists ');
        }
        this.visitNode(node.table);
        if (node.cascade) {
            this.append(' cascade');
        }
    }
    visitDataType(node) {
        this.append(node.dataType);
    }
    visitOrderBy(node) {
        this.append('order by ');
        this.compileList(node.items);
    }
    visitOrderByItem(node) {
        this.visitNode(node.orderBy);
        if (node.direction) {
            this.append(' ');
            this.visitNode(node.direction);
        }
    }
    visitGroupBy(node) {
        this.append('group by ');
        this.compileList(node.items);
    }
    visitGroupByItem(node) {
        this.visitNode(node.groupBy);
    }
    visitUpdateQuery(node) {
        const rootQueryNode = this.nodeStack.find(QueryNode.is);
        const isSubQuery = rootQueryNode !== node;
        if (!isSubQuery && node.explain) {
            this.visitNode(node.explain);
            this.append(' ');
        }
        if (isSubQuery && !MergeQueryNode.is(rootQueryNode)) {
            this.append('(');
        }
        if (node.with) {
            this.visitNode(node.with);
            this.append(' ');
        }
        this.append('update ');
        if (node.top) {
            this.visitNode(node.top);
            this.append(' ');
        }
        if (node.table) {
            this.visitNode(node.table);
            this.append(' ');
        }
        this.append('set ');
        if (node.updates) {
            this.compileList(node.updates);
        }
        if (node.output) {
            this.append(' ');
            this.visitNode(node.output);
        }
        if (node.from) {
            this.append(' ');
            this.visitNode(node.from);
        }
        if (node.joins) {
            this.append(' ');
            this.compileList(node.joins, ' ');
        }
        if (node.where) {
            this.append(' ');
            this.visitNode(node.where);
        }
        if (node.limit) {
            this.append(' ');
            this.visitNode(node.limit);
        }
        if (node.returning) {
            this.append(' ');
            this.visitNode(node.returning);
        }
        if (isSubQuery && !MergeQueryNode.is(rootQueryNode)) {
            this.append(')');
        }
    }
    visitColumnUpdate(node) {
        this.visitNode(node.column);
        this.append(' = ');
        this.visitNode(node.value);
    }
    visitLimit(node) {
        this.append('limit ');
        this.visitNode(node.limit);
    }
    visitOffset(node) {
        this.append('offset ');
        this.visitNode(node.offset);
    }
    visitOnConflict(node) {
        this.append('on conflict');
        if (node.columns) {
            this.append(' (');
            this.compileList(node.columns);
            this.append(')');
        }
        else if (node.constraint) {
            this.append(' on constraint ');
            this.visitNode(node.constraint);
        }
        else if (node.indexExpression) {
            this.append(' (');
            this.visitNode(node.indexExpression);
            this.append(')');
        }
        if (node.indexWhere) {
            this.append(' ');
            this.visitNode(node.indexWhere);
        }
        if (node.doNothing === true) {
            this.append(' do nothing');
        }
        else if (node.updates) {
            this.append(' do update set ');
            this.compileList(node.updates);
            if (node.updateWhere) {
                this.append(' ');
                this.visitNode(node.updateWhere);
            }
        }
    }
    visitOnDuplicateKey(node) {
        this.append('on duplicate key update ');
        this.compileList(node.updates);
    }
    visitCreateIndex(node) {
        this.append('create ');
        if (node.unique) {
            this.append('unique ');
        }
        this.append('index ');
        if (node.ifNotExists) {
            this.append('if not exists ');
        }
        this.visitNode(node.name);
        if (node.table) {
            this.append(' on ');
            this.visitNode(node.table);
        }
        if (node.using) {
            this.append(' using ');
            this.visitNode(node.using);
        }
        if (node.columns) {
            this.append(' (');
            this.compileList(node.columns);
            this.append(')');
        }
        if (node.nullsNotDistinct) {
            this.append(' nulls not distinct');
        }
        if (node.where) {
            this.append(' ');
            this.visitNode(node.where);
        }
    }
    visitDropIndex(node) {
        this.append('drop index ');
        if (node.ifExists) {
            this.append('if exists ');
        }
        this.visitNode(node.name);
        if (node.table) {
            this.append(' on ');
            this.visitNode(node.table);
        }
        if (node.cascade) {
            this.append(' cascade');
        }
    }
    visitCreateSchema(node) {
        this.append('create schema ');
        if (node.ifNotExists) {
            this.append('if not exists ');
        }
        this.visitNode(node.schema);
    }
    visitDropSchema(node) {
        this.append('drop schema ');
        if (node.ifExists) {
            this.append('if exists ');
        }
        this.visitNode(node.schema);
        if (node.cascade) {
            this.append(' cascade');
        }
    }
    visitPrimaryKeyConstraint(node) {
        if (node.name) {
            this.append('constraint ');
            this.visitNode(node.name);
            this.append(' ');
        }
        this.append('primary key (');
        this.compileList(node.columns);
        this.append(')');
    }
    visitUniqueConstraint(node) {
        if (node.name) {
            this.append('constraint ');
            this.visitNode(node.name);
            this.append(' ');
        }
        this.append('unique');
        if (node.nullsNotDistinct) {
            this.append(' nulls not distinct');
        }
        this.append(' (');
        this.compileList(node.columns);
        this.append(')');
    }
    visitCheckConstraint(node) {
        if (node.name) {
            this.append('constraint ');
            this.visitNode(node.name);
            this.append(' ');
        }
        this.append('check (');
        this.visitNode(node.expression);
        this.append(')');
    }
    visitForeignKeyConstraint(node) {
        if (node.name) {
            this.append('constraint ');
            this.visitNode(node.name);
            this.append(' ');
        }
        this.append('foreign key (');
        this.compileList(node.columns);
        this.append(') ');
        this.visitNode(node.references);
        if (node.onDelete) {
            this.append(' on delete ');
            this.append(node.onDelete);
        }
        if (node.onUpdate) {
            this.append(' on update ');
            this.append(node.onUpdate);
        }
    }
    visitList(node) {
        this.compileList(node.items);
    }
    visitWith(node) {
        this.append('with ');
        if (node.recursive) {
            this.append('recursive ');
        }
        this.compileList(node.expressions);
    }
    visitCommonTableExpression(node) {
        this.visitNode(node.name);
        this.append(' as ');
        if (isBoolean(node.materialized)) {
            if (!node.materialized) {
                this.append('not ');
            }
            this.append('materialized ');
        }
        this.visitNode(node.expression);
    }
    visitCommonTableExpressionName(node) {
        this.visitNode(node.table);
        if (node.columns) {
            this.append('(');
            this.compileList(node.columns);
            this.append(')');
        }
    }
    visitAlterTable(node) {
        this.append('alter table ');
        this.visitNode(node.table);
        this.append(' ');
        if (node.renameTo) {
            this.append('rename to ');
            this.visitNode(node.renameTo);
        }
        if (node.setSchema) {
            this.append('set schema ');
            this.visitNode(node.setSchema);
        }
        if (node.addConstraint) {
            this.visitNode(node.addConstraint);
        }
        if (node.dropConstraint) {
            this.visitNode(node.dropConstraint);
        }
        if (node.columnAlterations) {
            this.compileColumnAlterations(node.columnAlterations);
        }
        if (node.addIndex) {
            this.visitNode(node.addIndex);
        }
        if (node.dropIndex) {
            this.visitNode(node.dropIndex);
        }
    }
    visitAddColumn(node) {
        this.append('add column ');
        this.visitNode(node.column);
    }
    visitRenameColumn(node) {
        this.append('rename column ');
        this.visitNode(node.column);
        this.append(' to ');
        this.visitNode(node.renameTo);
    }
    visitDropColumn(node) {
        this.append('drop column ');
        this.visitNode(node.column);
    }
    visitAlterColumn(node) {
        this.append('alter column ');
        this.visitNode(node.column);
        this.append(' ');
        if (node.dataType) {
            if (this.announcesNewColumnDataType()) {
                this.append('type ');
            }
            this.visitNode(node.dataType);
            if (node.dataTypeExpression) {
                this.append('using ');
                this.visitNode(node.dataTypeExpression);
            }
        }
        if (node.setDefault) {
            this.append('set default ');
            this.visitNode(node.setDefault);
        }
        if (node.dropDefault) {
            this.append('drop default');
        }
        if (node.setNotNull) {
            this.append('set not null');
        }
        if (node.dropNotNull) {
            this.append('drop not null');
        }
    }
    visitModifyColumn(node) {
        this.append('modify column ');
        this.visitNode(node.column);
    }
    visitAddConstraint(node) {
        this.append('add ');
        this.visitNode(node.constraint);
    }
    visitDropConstraint(node) {
        this.append('drop constraint ');
        if (node.ifExists) {
            this.append('if exists ');
        }
        this.visitNode(node.constraintName);
        if (node.modifier === 'cascade') {
            this.append(' cascade');
        }
        else if (node.modifier === 'restrict') {
            this.append(' restrict');
        }
    }
    visitSetOperation(node) {
        this.append(node.operator);
        this.append(' ');
        if (node.all) {
            this.append('all ');
        }
        this.visitNode(node.expression);
    }
    visitCreateView(node) {
        this.append('create ');
        if (node.orReplace) {
            this.append('or replace ');
        }
        if (node.materialized) {
            this.append('materialized ');
        }
        if (node.temporary) {
            this.append('temporary ');
        }
        this.append('view ');
        if (node.ifNotExists) {
            this.append('if not exists ');
        }
        this.visitNode(node.name);
        this.append(' ');
        if (node.columns) {
            this.append('(');
            this.compileList(node.columns);
            this.append(') ');
        }
        if (node.as) {
            this.append('as ');
            this.visitNode(node.as);
        }
    }
    visitDropView(node) {
        this.append('drop ');
        if (node.materialized) {
            this.append('materialized ');
        }
        this.append('view ');
        if (node.ifExists) {
            this.append('if exists ');
        }
        this.visitNode(node.name);
        if (node.cascade) {
            this.append(' cascade');
        }
    }
    visitGenerated(node) {
        this.append('generated ');
        if (node.always) {
            this.append('always ');
        }
        if (node.byDefault) {
            this.append('by default ');
        }
        this.append('as ');
        if (node.identity) {
            this.append('identity');
        }
        if (node.expression) {
            this.append('(');
            this.visitNode(node.expression);
            this.append(')');
        }
        if (node.stored) {
            this.append(' stored');
        }
    }
    visitDefaultValue(node) {
        this.append('default ');
        this.visitNode(node.defaultValue);
    }
    visitSelectModifier(node) {
        if (node.rawModifier) {
            this.visitNode(node.rawModifier);
        }
        else {
            this.append(SELECT_MODIFIER_SQL[node.modifier]);
        }
        if (node.of) {
            this.append(' of ');
            this.compileList(node.of, ', ');
        }
    }
    visitCreateType(node) {
        this.append('create type ');
        this.visitNode(node.name);
        if (node.enum) {
            this.append(' as enum ');
            this.visitNode(node.enum);
        }
    }
    visitDropType(node) {
        this.append('drop type ');
        if (node.ifExists) {
            this.append('if exists ');
        }
        this.visitNode(node.name);
    }
    visitExplain(node) {
        this.append('explain');
        if (node.options || node.format) {
            this.append(' ');
            this.append(this.getLeftExplainOptionsWrapper());
            if (node.options) {
                this.visitNode(node.options);
                if (node.format) {
                    this.append(this.getExplainOptionsDelimiter());
                }
            }
            if (node.format) {
                this.append('format');
                this.append(this.getExplainOptionAssignment());
                this.append(node.format);
            }
            this.append(this.getRightExplainOptionsWrapper());
        }
    }
    visitDefaultInsertValue(_) {
        this.append('default');
    }
    visitAggregateFunction(node) {
        this.append(node.func);
        this.append('(');
        if (node.distinct) {
            this.append('distinct ');
        }
        this.compileList(node.aggregated);
        this.append(')');
        if (node.filter) {
            this.append(' filter(');
            this.visitNode(node.filter);
            this.append(')');
        }
        if (node.over) {
            this.append(' ');
            this.visitNode(node.over);
        }
    }
    visitOver(node) {
        this.append('over(');
        if (node.partitionBy) {
            this.visitNode(node.partitionBy);
            if (node.orderBy) {
                this.append(' ');
            }
        }
        if (node.orderBy) {
            this.visitNode(node.orderBy);
        }
        this.append(')');
    }
    visitPartitionBy(node) {
        this.append('partition by ');
        this.compileList(node.items);
    }
    visitPartitionByItem(node) {
        this.visitNode(node.partitionBy);
    }
    visitBinaryOperation(node) {
        this.visitNode(node.leftOperand);
        this.append(' ');
        this.visitNode(node.operator);
        this.append(' ');
        this.visitNode(node.rightOperand);
    }
    visitUnaryOperation(node) {
        this.visitNode(node.operator);
        if (!this.isMinusOperator(node.operator)) {
            this.append(' ');
        }
        this.visitNode(node.operand);
    }
    isMinusOperator(node) {
        return OperatorNode.is(node) && node.operator === '-';
    }
    visitUsing(node) {
        this.append('using ');
        this.compileList(node.tables);
    }
    visitFunction(node) {
        this.append(node.func);
        this.append('(');
        this.compileList(node.arguments);
        this.append(')');
    }
    visitCase(node) {
        this.append('case');
        if (node.value) {
            this.append(' ');
            this.visitNode(node.value);
        }
        if (node.when) {
            this.append(' ');
            this.compileList(node.when, ' ');
        }
        if (node.else) {
            this.append(' else ');
            this.visitNode(node.else);
        }
        this.append(' end');
        if (node.isStatement) {
            this.append(' case');
        }
    }
    visitWhen(node) {
        this.append('when ');
        this.visitNode(node.condition);
        if (node.result) {
            this.append(' then ');
            this.visitNode(node.result);
        }
    }
    visitJSONReference(node) {
        this.visitNode(node.reference);
        this.visitNode(node.traversal);
    }
    visitJSONPath(node) {
        if (node.inOperator) {
            this.visitNode(node.inOperator);
        }
        this.append("'$");
        for (const pathLeg of node.pathLegs) {
            this.visitNode(pathLeg);
        }
        this.append("'");
    }
    visitJSONPathLeg(node) {
        const isArrayLocation = node.type === 'ArrayLocation';
        this.append(isArrayLocation ? '[' : '.');
        this.append(String(node.value));
        if (isArrayLocation) {
            this.append(']');
        }
    }
    visitJSONOperatorChain(node) {
        for (let i = 0, len = node.values.length; i < len; i++) {
            if (i === len - 1) {
                this.visitNode(node.operator);
            }
            else {
                this.append('->');
            }
            this.visitNode(node.values[i]);
        }
    }
    visitMergeQuery(node) {
        if (node.with) {
            this.visitNode(node.with);
            this.append(' ');
        }
        this.append('merge ');
        if (node.top) {
            this.visitNode(node.top);
            this.append(' ');
        }
        this.append('into ');
        this.visitNode(node.into);
        if (node.using) {
            this.append(' ');
            this.visitNode(node.using);
        }
        if (node.whens) {
            this.append(' ');
            this.compileList(node.whens, ' ');
        }
        if (node.output) {
            this.append(' ');
            this.visitNode(node.output);
        }
    }
    visitMatched(node) {
        if (node.not) {
            this.append('not ');
        }
        this.append('matched');
        if (node.bySource) {
            this.append(' by source');
        }
    }
    visitAddIndex(node) {
        this.append('add ');
        if (node.unique) {
            this.append('unique ');
        }
        this.append('index ');
        this.visitNode(node.name);
        if (node.columns) {
            this.append(' (');
            this.compileList(node.columns);
            this.append(')');
        }
        if (node.using) {
            this.append(' using ');
            this.visitNode(node.using);
        }
    }
    visitCast(node) {
        this.append('cast(');
        this.visitNode(node.expression);
        this.append(' as ');
        this.visitNode(node.dataType);
        this.append(')');
    }
    visitFetch(node) {
        this.append('fetch next ');
        this.visitNode(node.rowCount);
        this.append(` rows ${node.modifier}`);
    }
    visitOutput(node) {
        this.append('output ');
        this.compileList(node.selections);
    }
    visitTop(node) {
        this.append(`top(${node.expression})`);
        if (node.modifiers) {
            this.append(` ${node.modifiers}`);
        }
    }
    append(str) {
        this.#sql += str;
    }
    appendValue(parameter) {
        this.addParameter(parameter);
        this.append(this.getCurrentParameterPlaceholder());
    }
    getLeftIdentifierWrapper() {
        return '"';
    }
    getRightIdentifierWrapper() {
        return '"';
    }
    getCurrentParameterPlaceholder() {
        return '$' + this.numParameters;
    }
    getLeftExplainOptionsWrapper() {
        return '(';
    }
    getExplainOptionAssignment() {
        return ' ';
    }
    getExplainOptionsDelimiter() {
        return ', ';
    }
    getRightExplainOptionsWrapper() {
        return ')';
    }
    sanitizeIdentifier(identifier) {
        const leftWrap = this.getLeftIdentifierWrapper();
        const rightWrap = this.getRightIdentifierWrapper();
        let sanitized = '';
        for (const c of identifier) {
            sanitized += c;
            if (c === leftWrap) {
                sanitized += leftWrap;
            }
            else if (c === rightWrap) {
                sanitized += rightWrap;
            }
        }
        return sanitized;
    }
    addParameter(parameter) {
        this.#parameters.push(parameter);
    }
    appendImmediateValue(value) {
        if (isString(value)) {
            this.append(`'${value}'`);
        }
        else if (isNumber(value) || isBoolean(value)) {
            this.append(value.toString());
        }
        else if (isNull(value)) {
            this.append('null');
        }
        else if (isDate(value)) {
            this.appendImmediateValue(value.toISOString());
        }
        else if (isBigInt(value)) {
            this.appendImmediateValue(value.toString());
        }
        else {
            throw new Error(`invalid immediate value ${value}`);
        }
    }
    sortSelectModifiers(arr) {
        arr.sort((left, right) => left.modifier && right.modifier
            ? SELECT_MODIFIER_PRIORITY[left.modifier] -
                SELECT_MODIFIER_PRIORITY[right.modifier]
            : 1);
        return freeze(arr);
    }
    compileColumnAlterations(columnAlterations) {
        this.compileList(columnAlterations);
    }
    /**
     * controls whether the dialect adds a "type" keyword before a column's new data
     * type in an ALTER TABLE statement.
     */
    announcesNewColumnDataType() {
        return true;
    }
}
const SELECT_MODIFIER_SQL = freeze({
    ForKeyShare: 'for key share',
    ForNoKeyUpdate: 'for no key update',
    ForUpdate: 'for update',
    ForShare: 'for share',
    NoWait: 'nowait',
    SkipLocked: 'skip locked',
    Distinct: 'distinct',
});
const SELECT_MODIFIER_PRIORITY = freeze({
    ForKeyShare: 1,
    ForNoKeyUpdate: 1,
    ForUpdate: 1,
    ForShare: 1,
    NoWait: 2,
    SkipLocked: 2,
    Distinct: 0,
});
const JOIN_TYPE_SQL = freeze({
    InnerJoin: 'inner join',
    LeftJoin: 'left join',
    RightJoin: 'right join',
    FullJoin: 'full join',
    LateralInnerJoin: 'inner join lateral',
    LateralLeftJoin: 'left join lateral',
    Using: 'using',
});

/// <reference types="./compiled-query.d.ts" />
const CompiledQuery = freeze({
    raw(sql, parameters = []) {
        return freeze({
            sql,
            query: RawNode.createWithSql(sql),
            parameters: freeze(parameters),
        });
    },
});

/// <reference types="./dummy-driver.d.ts" />
/**
 * A driver that does absolutely nothing.
 *
 * You can use this to create Kysely instances solely for building queries
 *
 * ### Examples
 *
 * This example creates a Kysely instance for building postgres queries:
 *
 * ```ts
 * const db = new Kysely<Database>({
 *   dialect: {
 *     createAdapter() {
 *       return new PostgresAdapter()
 *     },
 *     createDriver() {
 *       return new DummyDriver()
 *     },
 *     createIntrospector(db: Kysely<any>) {
 *       return new PostgresIntrospector(db)
 *     },
 *     createQueryCompiler() {
 *       return new PostgresQueryCompiler()
 *     },
 *   },
 * })
 * ```
 *
 * You can use it to build a query and compile it to SQL but trying to
 * execute the query will throw an error.
 *
 * ```ts
 * const { sql } = db.selectFrom('person').selectAll().compile()
 * console.log(sql) // select * from "person"
 * ```
 */
class DummyDriver {
    async init() {
        // Nothing to do here.
    }
    async acquireConnection() {
        return new DummyConnection();
    }
    async beginTransaction() {
        // Nothing to do here.
    }
    async commitTransaction() {
        // Nothing to do here.
    }
    async rollbackTransaction() {
        // Nothing to do here.
    }
    async releaseConnection() {
        // Nothing to do here.
    }
    async destroy() {
        // Nothing to do here.
    }
}
class DummyConnection {
    async executeQuery() {
        return {
            rows: [],
        };
    }
    async *streamQuery() {
        // Nothing to do here.
    }
}

/// <reference types="./dialect-adapter-base.d.ts" />
/**
 * A basic implementation of `DialectAdapter` with sensible default values.
 * Third-party dialects can extend this instead of implementing the `DialectAdapter`
 * interface from scratch. That way all new settings will get default values when
 * they are added and there will be less breaking changes.
 */
class DialectAdapterBase {
    get supportsCreateIfNotExists() {
        return true;
    }
    get supportsTransactionalDdl() {
        return false;
    }
    get supportsReturning() {
        return false;
    }
    get supportsOutput() {
        return false;
    }
}

/// <reference types="./migrator.d.ts" />
const DEFAULT_MIGRATION_TABLE = 'kysely_migration';
const DEFAULT_MIGRATION_LOCK_TABLE = 'kysely_migration_lock';
freeze({ __noMigrations__: true });

/// <reference types="./postgres-query-compiler.d.ts" />
const ID_WRAP_REGEX = /"/g;
class PostgresQueryCompiler extends DefaultQueryCompiler {
    sanitizeIdentifier(identifier) {
        return identifier.replace(ID_WRAP_REGEX, '""');
    }
}

/// <reference types="./postgres-introspector.d.ts" />
class PostgresIntrospector {
    #db;
    constructor(db) {
        this.#db = db;
    }
    async getSchemas() {
        let rawSchemas = await this.#db
            .selectFrom('pg_catalog.pg_namespace')
            .select('nspname')
            .$castTo()
            .execute();
        return rawSchemas.map((it) => ({ name: it.nspname }));
    }
    async getTables(options = { withInternalKyselyTables: false }) {
        let query = this.#db
            // column
            .selectFrom('pg_catalog.pg_attribute as a')
            // table
            .innerJoin('pg_catalog.pg_class as c', 'a.attrelid', 'c.oid')
            // table schema
            .innerJoin('pg_catalog.pg_namespace as ns', 'c.relnamespace', 'ns.oid')
            // column data type
            .innerJoin('pg_catalog.pg_type as typ', 'a.atttypid', 'typ.oid')
            // column data type schema
            .innerJoin('pg_catalog.pg_namespace as dtns', 'typ.typnamespace', 'dtns.oid')
            .select([
            'a.attname as column',
            'a.attnotnull as not_null',
            'a.atthasdef as has_default',
            'c.relname as table',
            'c.relkind as table_type',
            'ns.nspname as schema',
            'typ.typname as type',
            'dtns.nspname as type_schema',
            sql `col_description(a.attrelid, a.attnum)`.as('column_description'),
            // Detect if the column is auto incrementing by finding the sequence
            // that is created for `serial` and `bigserial` columns.
            this.#db
                .selectFrom('pg_class')
                .select(sql `true`.as('auto_incrementing'))
                // Make sure the sequence is in the same schema as the table.
                .whereRef('relnamespace', '=', 'c.relnamespace')
                .where('relkind', '=', 'S')
                .where('relname', '=', sql `c.relname || '_' || a.attname || '_seq'`)
                .as('auto_incrementing'),
        ])
            // r == normal table
            .where((eb) => eb.or([eb('c.relkind', '=', 'r'), eb('c.relkind', '=', 'v'), eb('c.relkind', '=', 'p')]))
            .where('ns.nspname', '!~', '^pg_')
            .where('ns.nspname', '!=', 'information_schema')
            // No system columns
            .where('a.attnum', '>=', 0)
            .where('a.attisdropped', '!=', true)
            .orderBy('ns.nspname')
            .orderBy('c.relname')
            .orderBy('a.attnum')
            .$castTo();
        if (!options.withInternalKyselyTables) {
            query = query
                .where('c.relname', '!=', DEFAULT_MIGRATION_TABLE)
                .where('c.relname', '!=', DEFAULT_MIGRATION_LOCK_TABLE);
        }
        const rawColumns = await query.execute();
        return this.#parseTableMetadata(rawColumns);
    }
    async getMetadata(options) {
        return {
            tables: await this.getTables(options),
        };
    }
    #parseTableMetadata(columns) {
        return columns.reduce((tables, it) => {
            let table = tables.find((tbl) => tbl.name === it.table && tbl.schema === it.schema);
            if (!table) {
                table = freeze({
                    name: it.table,
                    isView: it.table_type === 'v',
                    schema: it.schema,
                    columns: [],
                });
                tables.push(table);
            }
            table.columns.push(freeze({
                name: it.column,
                dataType: it.type,
                dataTypeSchema: it.type_schema,
                isNullable: !it.not_null,
                isAutoIncrementing: !!it.auto_incrementing,
                hasDefaultValue: it.has_default,
                comment: it.column_description ?? undefined,
            }));
            return tables;
        }, []);
    }
}

/// <reference types="./postgres-adapter.d.ts" />
// Random id for our transaction lock.
const LOCK_ID = BigInt('3853314791062309107');
class PostgresAdapter extends DialectAdapterBase {
    get supportsTransactionalDdl() {
        return true;
    }
    get supportsReturning() {
        return true;
    }
    async acquireMigrationLock(db, _opt) {
        // Acquire a transaction level advisory lock.
        await sql `select pg_advisory_xact_lock(${sql.lit(LOCK_ID)})`.execute(db);
    }
    async releaseMigrationLock(_db, _opt) {
        // Nothing to do here. `pg_advisory_xact_lock` is automatically released at the
        // end of the transaction and since `supportsTransactionalDdl` true, we know
        // the `db` instance passed to acquireMigrationLock is actually a transaction.
    }
}

/// <reference types="./stack-trace-utils.d.ts" />
function extendStackTrace(err, stackError) {
    if (isStackHolder(err) && stackError.stack) {
        // Remove the first line that just says `Error`.
        const stackExtension = stackError.stack.split('\n').slice(1).join('\n');
        err.stack += `\n${stackExtension}`;
        return err;
    }
    return err;
}
function isStackHolder(obj) {
    return isObject(obj) && isString(obj.stack);
}

/// <reference types="./postgres-driver.d.ts" />
const PRIVATE_RELEASE_METHOD = Symbol();
class PostgresDriver {
    #config;
    #connections = new WeakMap();
    #pool;
    constructor(config) {
        this.#config = freeze({ ...config });
    }
    async init() {
        this.#pool = isFunction(this.#config.pool)
            ? await this.#config.pool()
            : this.#config.pool;
    }
    async acquireConnection() {
        const client = await this.#pool.connect();
        let connection = this.#connections.get(client);
        if (!connection) {
            connection = new PostgresConnection(client, {
                cursor: this.#config.cursor ?? null,
            });
            this.#connections.set(client, connection);
            // The driver must take care of calling `onCreateConnection` when a new
            // connection is created. The `pg` module doesn't provide an async hook
            // for the connection creation. We need to call the method explicitly.
            if (this.#config.onCreateConnection) {
                await this.#config.onCreateConnection(connection);
            }
        }
        return connection;
    }
    async beginTransaction(connection, settings) {
        if (settings.isolationLevel) {
            await connection.executeQuery(CompiledQuery.raw(`start transaction isolation level ${settings.isolationLevel}`));
        }
        else {
            await connection.executeQuery(CompiledQuery.raw('begin'));
        }
    }
    async commitTransaction(connection) {
        await connection.executeQuery(CompiledQuery.raw('commit'));
    }
    async rollbackTransaction(connection) {
        await connection.executeQuery(CompiledQuery.raw('rollback'));
    }
    async releaseConnection(connection) {
        connection[PRIVATE_RELEASE_METHOD]();
    }
    async destroy() {
        if (this.#pool) {
            const pool = this.#pool;
            this.#pool = undefined;
            await pool.end();
        }
    }
}
class PostgresConnection {
    #client;
    #options;
    constructor(client, options) {
        this.#client = client;
        this.#options = options;
    }
    async executeQuery(compiledQuery) {
        try {
            const result = await this.#client.query(compiledQuery.sql, [
                ...compiledQuery.parameters,
            ]);
            if (result.command === 'INSERT' ||
                result.command === 'UPDATE' ||
                result.command === 'DELETE' ||
                result.command === 'MERGE') {
                const numAffectedRows = BigInt(result.rowCount);
                return {
                    // TODO: remove.
                    numUpdatedOrDeletedRows: numAffectedRows,
                    numAffectedRows,
                    rows: result.rows ?? [],
                };
            }
            return {
                rows: result.rows ?? [],
            };
        }
        catch (err) {
            throw extendStackTrace(err, new Error());
        }
    }
    async *streamQuery(compiledQuery, chunkSize) {
        if (!this.#options.cursor) {
            throw new Error("'cursor' is not present in your postgres dialect config. It's required to make streaming work in postgres.");
        }
        if (!Number.isInteger(chunkSize) || chunkSize <= 0) {
            throw new Error('chunkSize must be a positive integer');
        }
        const cursor = this.#client.query(new this.#options.cursor(compiledQuery.sql, compiledQuery.parameters.slice()));
        try {
            while (true) {
                const rows = await cursor.read(chunkSize);
                if (rows.length === 0) {
                    break;
                }
                yield {
                    rows,
                };
            }
        }
        finally {
            await cursor.close();
        }
    }
    [PRIVATE_RELEASE_METHOD]() {
        this.#client.release();
    }
}

/// <reference types="./postgres-dialect.d.ts" />
/**
 * PostgreSQL dialect that uses the [pg](https://node-postgres.com/) library.
 *
 * The constructor takes an instance of {@link PostgresDialectConfig}.
 *
 * ```ts
 * import {Pool } from 'pg'
 *
 * new PostgresDialect({
 *   pool: new Pool({
 *     database: 'some_db',
 *     host: 'localhost',
 *   })
 * })
 * ```
 *
 * If you want the pool to only be created once it's first used, `pool`
 * can be a function:
 *
 * ```ts
 * import {Pool } from 'pg'
 *
 * new PostgresDialect({
 *   pool: async () => new Pool({
 *     database: 'some_db',
 *     host: 'localhost',
 *   })
 * })
 * ```
 */
class PostgresDialect {
    #config;
    constructor(config) {
        this.#config = config;
    }
    createDriver() {
        return new PostgresDriver(this.#config);
    }
    createQueryCompiler() {
        return new PostgresQueryCompiler();
    }
    createAdapter() {
        return new PostgresAdapter();
    }
    createIntrospector(db) {
        return new PostgresIntrospector(db);
    }
}

class QueryAlias {
    name;
    constructor(name) {
        this.name = name;
    }
}
class Context {
    // The list of tables in the current context (including aliases for subqueries)
    namespace;
    usedAliases;
    constructor(namespace) {
        this.namespace = namespace;
        this.usedAliases = new Set(namespace.values());
    }
    static new() {
        return new Context(new Map());
    }
    withReference(ref) {
        if (this.usedAliases.has(ref)) {
            throw new Error(`Alias "${ref}" already exists in the current context.`);
        }
        const newNamespace = new Map(this.namespace);
        newNamespace.set(new QueryAlias(ref), ref);
        return new Context(newNamespace);
    }
    withAliases(aliases) {
        const newNamespace = new Map(this.namespace);
        for (const alias of aliases) {
            let aliasName = alias.name;
            if (this.usedAliases.has(alias.name)) {
                for (const i of Array(100).keys()) {
                    aliasName = `${alias}_${i}`;
                    if (!this.usedAliases.has(aliasName)) {
                        break;
                    }
                    if (i === 99) {
                        throw new Error(`Alias ${aliasName} already exists in the current context: ${JSON.stringify(Array.from(this.usedAliases))}`);
                    }
                }
            }
            newNamespace.set(alias, aliasName);
        }
        return new Context(newNamespace);
    }
    getAlias(alias) {
        const name = this.namespace.get(alias);
        if (!name) {
            throw new Error(`Alias "${alias.name}" not found in the current context: ${JSON.stringify(Array.from(this.usedAliases))} / ${JSON.stringify(Array.from(this.namespace))}`);
        }
        return name;
    }
}
class Expression {
}
class LiteralExpression extends Expression {
    value;
    type;
    constructor(value, type) {
        super();
        this.value = value;
        this.type = type;
    }
    compile() {
        return sql `cast(${this.value} as ${sql.raw(this.type)})`;
    }
}
class LiteralUnknownExpression extends Expression {
    value;
    constructor(value) {
        super();
        this.value = value;
    }
    compile() {
        return sql `${this.value}`;
    }
}
class FunctionExpression extends Expression {
    name;
    args;
    constructor(name, args) {
        super();
        this.name = name;
        this.args = args;
    }
    compile(ctx) {
        return sql `${sql.ref(this.name)}(${sql.join(this.args.map((arg) => arg.compile(ctx)))})`;
    }
}
class BinaryOperatorExpression extends Expression {
    operator;
    args;
    constructor(operator, args) {
        super();
        this.operator = operator;
        this.args = args;
    }
    compile(ctx) {
        return sql `${this.args[0].compile(ctx)} ${sql.raw(this.operator)} ${this.args[1].compile(ctx)}`;
    }
}

const Sentinel = class Sentinel {
    static typeString() {
        return "sentinel";
    }
};
const genericArgs = { T: Sentinel, R: Sentinel };
const getRetType = (args, defn) => {
    const { args: params, ret } = typeof defn === "function" ? defn(genericArgs) : defn;
    if (args.length !== params.length) {
        return false;
    }
    let genericBindsTo;
    for (let i = 0; i < args.length; i++) {
        const arg = args[i];
        const param = params[i];
        if (param === Sentinel) {
            if (arg instanceof Any) {
                genericBindsTo = arg.getClass();
            }
            continue;
        }
        const subtype = param.subtype();
        const argSubtype = arg instanceof Any ? arg.getClass().subtype() : null;
        if (argSubtype != null && subtype?.subtype === Sentinel) {
            // If the argument is a subtype of the parameter, we can bind it
            // to the generic type.
            genericBindsTo = argSubtype.subtype;
            continue;
        }
        if (arg instanceof Any &&
            arg.getClass().typeString() !== param.typeString() &&
            !(arg instanceof param)) {
            // If the argument is not an instance of the parameter, we can't bind it.
            // Note that if the argument type is not an `Any` (i.e., its a primitive type),
            //  we assume it matches -- it shouldn't matter because we assert that primitive
            //  types will only be passed if all return types are the same.
            return false;
        }
    }
    if (!genericBindsTo) {
        if (ret === Sentinel) {
            throw new Error(`Cannot determine return type for function ${defn} with args ${args}`);
        }
        return { ret, genericBindsTo };
    }
    if (ret === Sentinel) {
        return { ret: genericBindsTo, genericBindsTo };
    }
    const retSubtype = "subtype" in ret && ret.subtype();
    if (retSubtype && retSubtype?.subtype === Sentinel) {
        return { ret: retSubtype.withSubtype(genericBindsTo), genericBindsTo };
    }
    return { ret, genericBindsTo };
};
class SelectableFunctionExpression extends SelectableExpression {
    fnExpr;
    constructor(fnExpr, schema) {
        super(schema);
        this.fnExpr = fnExpr;
    }
    compile(ctx) {
        return this.fnExpr.compile(ctx);
    }
}
const sqlFunction = (name, defn, args) => {
    const [{ matchingDef, RetType }] = defn.flatMap((def) => {
        const RetType = getRetType(args, def);
        return RetType
            ? [
                {
                    matchingDef: typeof def === "function" ? def(genericArgs) : def,
                    RetType: RetType.ret,
                    genericBindsTo: RetType.genericBindsTo,
                },
            ]
            : [];
    });
    if (!RetType) {
        console.error(`No matching function found for ${name}`, args, defn.map((d) => (typeof d === "function" ? d(genericArgs).args : d.args)));
        throw new Error(`No matching function found for ${name} with args ${JSON.stringify(args)} / ${JSON.stringify(defn)} / ${JSON.stringify(defn.map((d) => typeof d === "function" ? d(genericArgs).args : d.args))}`);
    }
    const argsAsExpressions = args.map((arg) => {
        if (arg instanceof Any) {
            return arg.toExpression();
        }
        // Rely on postgres to determine what the input type should be:
        return new LiteralUnknownExpression(arg);
    });
    return RetType.new(matchingDef.isOperator
        ? new BinaryOperatorExpression(name, argsAsExpressions)
        : new FunctionExpression(name, argsAsExpressions));
};

class PgAny {
    static parse(v) { return v; }
    static typeString() { return "any"; }
    anyValue(...args) {
        return sqlFunction("any_value", [({ T }) => ({ args: [T], ret: T, isOperator: false })], [this, ...args]);
    }
    anyValueTransfn(...args) {
        return sqlFunction("any_value_transfn", [({ T }) => ({ args: [T, T], ret: T, isOperator: false })], [this, ...args]);
    }
    arrayFill(...args) {
        return sqlFunction("array_fill", [({ T }) => ({ args: [T, Array$1.of((default_1$4))], ret: Array$1.of(T), isOperator: false }), ({ T }) => ({ args: [T, Array$1.of((default_1$4)), Array$1.of((default_1$4))], ret: Array$1.of(T), isOperator: false })], [this, ...args]);
    }
    arrayPrepend(...args) {
        return sqlFunction("array_prepend", [({ T }) => ({ args: [T, Array$1.of(T)], ret: Array$1.of(T), isOperator: false })], [this, ...args]);
    }
    concat(...args) {
        return sqlFunction("concat", [{ args: [(Any)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    count(...args) {
        return sqlFunction("count", [{ args: [(Any)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    cumeDist(...args) {
        return sqlFunction("cume_dist", [{ args: [(Any)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    denseRank(...args) {
        return sqlFunction("dense_rank", [{ args: [(Any)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    elemContainedByMultirange(...args) {
        return sqlFunction("elem_contained_by_multirange", [({ T }) => ({ args: [T, anymultirange], ret: (default_1$8), isOperator: false })], [this, ...args]);
    }
    elemContainedByRange(...args) {
        return sqlFunction("elem_contained_by_range", [({ T }) => ({ args: [T, anyrange], ret: (default_1$8), isOperator: false })], [this, ...args]);
    }
    firstValue(...args) {
        return sqlFunction("first_value", [({ T }) => ({ args: [T], ret: T, isOperator: false })], [this, ...args]);
    }
    jsonAgg(...args) {
        return sqlFunction("json_agg", [({ T }) => ({ args: [T], ret: (json), isOperator: false })], [this, ...args]);
    }
    jsonAggStrict(...args) {
        return sqlFunction("json_agg_strict", [({ T }) => ({ args: [T], ret: (json), isOperator: false })], [this, ...args]);
    }
    jsonBuildArray(...args) {
        return sqlFunction("json_build_array", [{ args: [(Any)], ret: (json), isOperator: false }], [this, ...args]);
    }
    jsonBuildObject(...args) {
        return sqlFunction("json_build_object", [{ args: [(Any)], ret: (json), isOperator: false }], [this, ...args]);
    }
    jsonObjectAgg(...args) {
        return sqlFunction("json_object_agg", [{ args: [(Any), (Any)], ret: (json), isOperator: false }], [this, ...args]);
    }
    jsonObjectAggStrict(...args) {
        return sqlFunction("json_object_agg_strict", [{ args: [(Any), (Any)], ret: (json), isOperator: false }], [this, ...args]);
    }
    jsonObjectAggUnique(...args) {
        return sqlFunction("json_object_agg_unique", [{ args: [(Any), (Any)], ret: (json), isOperator: false }], [this, ...args]);
    }
    jsonObjectAggUniqueStrict(...args) {
        return sqlFunction("json_object_agg_unique_strict", [{ args: [(Any), (Any)], ret: (json), isOperator: false }], [this, ...args]);
    }
    jsonPopulateRecord(...args) {
        return sqlFunction("json_populate_record", [({ T }) => ({ args: [T, (json), (default_1$8)], ret: T, isOperator: false })], [this, ...args]);
    }
    jsonPopulateRecordset(...args) {
        return sqlFunction("json_populate_recordset", [({ T }) => ({ args: [T, (json), (default_1$8)], ret: Setof.ofSchema({}), isOperator: false })], [this, ...args]);
    }
    jsonbAgg(...args) {
        return sqlFunction("jsonb_agg", [({ T }) => ({ args: [T], ret: (jsonb), isOperator: false })], [this, ...args]);
    }
    jsonbAggStrict(...args) {
        return sqlFunction("jsonb_agg_strict", [({ T }) => ({ args: [T], ret: (jsonb), isOperator: false })], [this, ...args]);
    }
    jsonbBuildArray(...args) {
        return sqlFunction("jsonb_build_array", [{ args: [(Any)], ret: (jsonb), isOperator: false }], [this, ...args]);
    }
    jsonbBuildObject(...args) {
        return sqlFunction("jsonb_build_object", [{ args: [(Any)], ret: (jsonb), isOperator: false }], [this, ...args]);
    }
    jsonbObjectAgg(...args) {
        return sqlFunction("jsonb_object_agg", [{ args: [(Any), (Any)], ret: (jsonb), isOperator: false }], [this, ...args]);
    }
    jsonbObjectAggStrict(...args) {
        return sqlFunction("jsonb_object_agg_strict", [{ args: [(Any), (Any)], ret: (jsonb), isOperator: false }], [this, ...args]);
    }
    jsonbObjectAggUnique(...args) {
        return sqlFunction("jsonb_object_agg_unique", [{ args: [(Any), (Any)], ret: (jsonb), isOperator: false }], [this, ...args]);
    }
    jsonbObjectAggUniqueStrict(...args) {
        return sqlFunction("jsonb_object_agg_unique_strict", [{ args: [(Any), (Any)], ret: (jsonb), isOperator: false }], [this, ...args]);
    }
    jsonbPopulateRecord(...args) {
        return sqlFunction("jsonb_populate_record", [({ T }) => ({ args: [T, (jsonb)], ret: T, isOperator: false })], [this, ...args]);
    }
    jsonbPopulateRecordValid(...args) {
        return sqlFunction("jsonb_populate_record_valid", [({ T }) => ({ args: [T, (jsonb)], ret: (default_1$8), isOperator: false })], [this, ...args]);
    }
    jsonbPopulateRecordset(...args) {
        return sqlFunction("jsonb_populate_recordset", [({ T }) => ({ args: [T, (jsonb)], ret: Setof.ofSchema({}), isOperator: false })], [this, ...args]);
    }
    lag(...args) {
        return sqlFunction("lag", [({ T }) => ({ args: [T, (default_1$4), T], ret: T, isOperator: false }), ({ T }) => ({ args: [T], ret: T, isOperator: false }), ({ T }) => ({ args: [T, (default_1$4)], ret: T, isOperator: false })], [this, ...args]);
    }
    lastValue(...args) {
        return sqlFunction("last_value", [({ T }) => ({ args: [T], ret: T, isOperator: false })], [this, ...args]);
    }
    lead(...args) {
        return sqlFunction("lead", [({ T }) => ({ args: [T, (default_1$4), T], ret: T, isOperator: false }), ({ T }) => ({ args: [T], ret: T, isOperator: false }), ({ T }) => ({ args: [T, (default_1$4)], ret: T, isOperator: false })], [this, ...args]);
    }
    mode(...args) {
        return sqlFunction("mode", [({ T }) => ({ args: [T], ret: T, isOperator: false })], [this, ...args]);
    }
    nthValue(...args) {
        return sqlFunction("nth_value", [({ T }) => ({ args: [T, (default_1$4)], ret: T, isOperator: false })], [this, ...args]);
    }
    numNonnulls(...args) {
        return sqlFunction("num_nonnulls", [{ args: [(Any)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    numNulls(...args) {
        return sqlFunction("num_nulls", [{ args: [(Any)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    percentRank(...args) {
        return sqlFunction("percent_rank", [{ args: [(Any)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    pgCollationFor(...args) {
        return sqlFunction("pg_collation_for", [{ args: [(Any)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    pgColumnCompression(...args) {
        return sqlFunction("pg_column_compression", [{ args: [(Any)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    pgColumnSize(...args) {
        return sqlFunction("pg_column_size", [{ args: [(Any)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    pgColumnToastChunkId(...args) {
        return sqlFunction("pg_column_toast_chunk_id", [{ args: [(Any)], ret: (oid$1), isOperator: false }], [this, ...args]);
    }
    pgTypeof(...args) {
        return sqlFunction("pg_typeof", [{ args: [(Any)], ret: (regtype), isOperator: false }], [this, ...args]);
    }
    quoteLiteral(...args) {
        return sqlFunction("quote_literal", [({ T }) => ({ args: [T], ret: (default_1$1), isOperator: false })], [this, ...args]);
    }
    quoteNullable(...args) {
        return sqlFunction("quote_nullable", [({ T }) => ({ args: [T], ret: (default_1$1), isOperator: false })], [this, ...args]);
    }
    rank(...args) {
        return sqlFunction("rank", [{ args: [(Any)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    toJson(...args) {
        return sqlFunction("to_json", [({ T }) => ({ args: [T], ret: (json), isOperator: false })], [this, ...args]);
    }
    toJsonb(...args) {
        return sqlFunction("to_jsonb", [({ T }) => ({ args: [T], ret: (jsonb), isOperator: false })], [this, ...args]);
    }
    widthBucket(...args) {
        return sqlFunction("width_bucket", [({ T }) => ({ args: [T, Array$1.of(T)], ret: (default_1$4), isOperator: false })], [this, ...args]);
    }
    ["||"](...args) {
        return sqlFunction("||", [({ T }) => ({ args: [T, Array$1.of(T)], ret: Array$1.of(T), isOperator: true })], [this, ...args]);
    }
    ["<@"](...args) {
        return sqlFunction("<@", [({ T }) => ({ args: [T, anymultirange], ret: (default_1$8), isOperator: true }), ({ T }) => ({ args: [T, anyrange], ret: (default_1$8), isOperator: true })], [this, ...args]);
    }
}

class Any extends PgAny {
    v;
    constructor(v) {
        super();
        this.v = v;
    }
    static new(v) {
        return new Any(v);
    }
    asAggregate() {
        return undefined;
    }
    static typeString() {
        return undefined;
    }
    static subtype() {
        return undefined;
    }
    toExpression() {
        if (this.v instanceof Expression) {
            return this.v;
        }
        const typeString = this.getClass()?.typeString();
        if (!typeString) {
            throw new Error(`Type string is not defined for ${this.constructor.name}`);
        }
        return new LiteralExpression(this.v, typeString);
    }
    serializeParamTypes = undefined;
    resultType = undefined;
    nullability = undefined;
    static parse(v) {
        return v;
    }
    execute(db) {
        const self = this;
        return {
            then(resolve, reject) {
                const expr = self.toExpression();
                const kexpr = db.selectNoFrom(expr.compile(Context.new()).as("val"));
                kexpr
                    .executeTakeFirst()
                    ?.then((result) => resolve((result?.val != null
                    ? self.getClass().parse(result.val)
                    : result?.val)))
                    .catch((err) => {
                    console.error("Error executing query:", kexpr.compile(), err);
                    reject(err);
                });
            },
        };
    }
    getClass() {
        return this.constructor;
    }
}

class aclitem extends Any {
    static new(v) { return new aclitem(v); }
    static parse(v) { return v; }
    static typeString() { return "aclitem"; }
    asAggregate() {
        return undefined;
    }
    aclitemeq(...args) {
        return sqlFunction("aclitemeq", [{ args: [(aclitem), (aclitem)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    hashAclitem(...args) {
        return sqlFunction("hash_aclitem", [{ args: [(aclitem)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    hashAclitemExtended(...args) {
        return sqlFunction("hash_aclitem_extended", [{ args: [(aclitem), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [{ args: [(aclitem), (aclitem)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
}

class anyenum extends Any {
    static parse(v) { return v; }
    static typeString() { return "anyenum"; }
    asAggregate() {
        return undefined;
    }
    enumCmp(...args) {
        return sqlFunction("enum_cmp", [({ T }) => ({ args: [T, T], ret: (default_1$4), isOperator: false })], [this, ...args]);
    }
    enumEq(...args) {
        return sqlFunction("enum_eq", [({ T }) => ({ args: [T, T], ret: (default_1$8), isOperator: false })], [this, ...args]);
    }
    enumFirst(...args) {
        return sqlFunction("enum_first", [({ T }) => ({ args: [T], ret: T, isOperator: false })], [this, ...args]);
    }
    enumGe(...args) {
        return sqlFunction("enum_ge", [({ T }) => ({ args: [T, T], ret: (default_1$8), isOperator: false })], [this, ...args]);
    }
    enumGt(...args) {
        return sqlFunction("enum_gt", [({ T }) => ({ args: [T, T], ret: (default_1$8), isOperator: false })], [this, ...args]);
    }
    enumLarger(...args) {
        return sqlFunction("enum_larger", [({ T }) => ({ args: [T, T], ret: T, isOperator: false })], [this, ...args]);
    }
    enumLast(...args) {
        return sqlFunction("enum_last", [({ T }) => ({ args: [T], ret: T, isOperator: false })], [this, ...args]);
    }
    enumLe(...args) {
        return sqlFunction("enum_le", [({ T }) => ({ args: [T, T], ret: (default_1$8), isOperator: false })], [this, ...args]);
    }
    enumLt(...args) {
        return sqlFunction("enum_lt", [({ T }) => ({ args: [T, T], ret: (default_1$8), isOperator: false })], [this, ...args]);
    }
    enumNe(...args) {
        return sqlFunction("enum_ne", [({ T }) => ({ args: [T, T], ret: (default_1$8), isOperator: false })], [this, ...args]);
    }
    enumRange(...args) {
        return sqlFunction("enum_range", [({ T }) => ({ args: [T], ret: Array$1.of(T), isOperator: false }), ({ T }) => ({ args: [T, T], ret: Array$1.of(T), isOperator: false })], [this, ...args]);
    }
    enumSmaller(...args) {
        return sqlFunction("enum_smaller", [({ T }) => ({ args: [T, T], ret: T, isOperator: false })], [this, ...args]);
    }
    hashenum(...args) {
        return sqlFunction("hashenum", [({ T }) => ({ args: [T], ret: (default_1$4), isOperator: false })], [this, ...args]);
    }
    hashenumextended(...args) {
        return sqlFunction("hashenumextended", [({ T }) => ({ args: [T, (default_1$3)], ret: (default_1$3), isOperator: false })], [this, ...args]);
    }
    max(...args) {
        return sqlFunction("max", [({ T }) => ({ args: [T], ret: T, isOperator: false })], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [({ T }) => ({ args: [T, T], ret: (default_1$8), isOperator: true })], [this, ...args]);
    }
    [">="](...args) {
        return sqlFunction(">=", [({ T }) => ({ args: [T, T], ret: (default_1$8), isOperator: true })], [this, ...args]);
    }
    [">"](...args) {
        return sqlFunction(">", [({ T }) => ({ args: [T, T], ret: (default_1$8), isOperator: true })], [this, ...args]);
    }
    ["<="](...args) {
        return sqlFunction("<=", [({ T }) => ({ args: [T, T], ret: (default_1$8), isOperator: true })], [this, ...args]);
    }
    ["<"](...args) {
        return sqlFunction("<", [({ T }) => ({ args: [T, T], ret: (default_1$8), isOperator: true })], [this, ...args]);
    }
    ["<>"](...args) {
        return sqlFunction("<>", [({ T }) => ({ args: [T, T], ret: (default_1$8), isOperator: true })], [this, ...args]);
    }
}

class anymultirange extends Any {
    static parse(v) { return v; }
    static typeString() { return "anymultirange"; }
    asAggregate() {
        return undefined;
    }
    hashMultirange(...args) {
        return sqlFunction("hash_multirange", [{ args: [anymultirange], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    hashMultirangeExtended(...args) {
        return sqlFunction("hash_multirange_extended", [{ args: [anymultirange, (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    isempty(...args) {
        return sqlFunction("isempty", [{ args: [anymultirange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    lower(...args) {
        return sqlFunction("lower", [({ T }) => ({ args: [anymultirange], ret: T, isOperator: false })], [this, ...args]);
    }
    lowerInc(...args) {
        return sqlFunction("lower_inc", [{ args: [anymultirange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    lowerInf(...args) {
        return sqlFunction("lower_inf", [{ args: [anymultirange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    multirangeAdjacentMultirange(...args) {
        return sqlFunction("multirange_adjacent_multirange", [{ args: [anymultirange, anymultirange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    multirangeAdjacentRange(...args) {
        return sqlFunction("multirange_adjacent_range", [{ args: [anymultirange, anyrange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    multirangeAfterMultirange(...args) {
        return sqlFunction("multirange_after_multirange", [{ args: [anymultirange, anymultirange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    multirangeAfterRange(...args) {
        return sqlFunction("multirange_after_range", [{ args: [anymultirange, anyrange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    multirangeBeforeMultirange(...args) {
        return sqlFunction("multirange_before_multirange", [{ args: [anymultirange, anymultirange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    multirangeBeforeRange(...args) {
        return sqlFunction("multirange_before_range", [{ args: [anymultirange, anyrange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    multirangeCmp(...args) {
        return sqlFunction("multirange_cmp", [{ args: [anymultirange, anymultirange], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    multirangeContainedByMultirange(...args) {
        return sqlFunction("multirange_contained_by_multirange", [{ args: [anymultirange, anymultirange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    multirangeContainedByRange(...args) {
        return sqlFunction("multirange_contained_by_range", [{ args: [anymultirange, anyrange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    multirangeContainsElem(...args) {
        return sqlFunction("multirange_contains_elem", [({ T }) => ({ args: [anymultirange, T], ret: (default_1$8), isOperator: false })], [this, ...args]);
    }
    multirangeContainsMultirange(...args) {
        return sqlFunction("multirange_contains_multirange", [{ args: [anymultirange, anymultirange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    multirangeContainsRange(...args) {
        return sqlFunction("multirange_contains_range", [{ args: [anymultirange, anyrange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    multirangeEq(...args) {
        return sqlFunction("multirange_eq", [{ args: [anymultirange, anymultirange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    multirangeGe(...args) {
        return sqlFunction("multirange_ge", [{ args: [anymultirange, anymultirange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    multirangeGt(...args) {
        return sqlFunction("multirange_gt", [{ args: [anymultirange, anymultirange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    multirangeIntersect(...args) {
        return sqlFunction("multirange_intersect", [{ args: [anymultirange, anymultirange], ret: anymultirange, isOperator: false }], [this, ...args]);
    }
    multirangeIntersectAggTransfn(...args) {
        return sqlFunction("multirange_intersect_agg_transfn", [{ args: [anymultirange, anymultirange], ret: anymultirange, isOperator: false }], [this, ...args]);
    }
    multirangeLe(...args) {
        return sqlFunction("multirange_le", [{ args: [anymultirange, anymultirange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    multirangeLt(...args) {
        return sqlFunction("multirange_lt", [{ args: [anymultirange, anymultirange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    multirangeMinus(...args) {
        return sqlFunction("multirange_minus", [{ args: [anymultirange, anymultirange], ret: anymultirange, isOperator: false }], [this, ...args]);
    }
    multirangeNe(...args) {
        return sqlFunction("multirange_ne", [{ args: [anymultirange, anymultirange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    multirangeOverlapsMultirange(...args) {
        return sqlFunction("multirange_overlaps_multirange", [{ args: [anymultirange, anymultirange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    multirangeOverlapsRange(...args) {
        return sqlFunction("multirange_overlaps_range", [{ args: [anymultirange, anyrange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    multirangeOverleftMultirange(...args) {
        return sqlFunction("multirange_overleft_multirange", [{ args: [anymultirange, anymultirange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    multirangeOverleftRange(...args) {
        return sqlFunction("multirange_overleft_range", [{ args: [anymultirange, anyrange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    multirangeOverrightMultirange(...args) {
        return sqlFunction("multirange_overright_multirange", [{ args: [anymultirange, anymultirange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    multirangeOverrightRange(...args) {
        return sqlFunction("multirange_overright_range", [{ args: [anymultirange, anyrange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    multirangeUnion(...args) {
        return sqlFunction("multirange_union", [{ args: [anymultirange, anymultirange], ret: anymultirange, isOperator: false }], [this, ...args]);
    }
    rangeAgg(...args) {
        return sqlFunction("range_agg", [{ args: [anymultirange], ret: anymultirange, isOperator: false }], [this, ...args]);
    }
    rangeIntersectAgg(...args) {
        return sqlFunction("range_intersect_agg", [{ args: [anymultirange], ret: anymultirange, isOperator: false }], [this, ...args]);
    }
    rangeMerge(...args) {
        return sqlFunction("range_merge", [{ args: [anymultirange], ret: anyrange, isOperator: false }], [this, ...args]);
    }
    unnest(...args) {
        return sqlFunction("unnest", [{ args: [anymultirange], ret: Setof.ofSchema({}), isOperator: false }], [this, ...args]);
    }
    upper(...args) {
        return sqlFunction("upper", [({ T }) => ({ args: [anymultirange], ret: T, isOperator: false })], [this, ...args]);
    }
    upperInc(...args) {
        return sqlFunction("upper_inc", [{ args: [anymultirange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    upperInf(...args) {
        return sqlFunction("upper_inf", [{ args: [anymultirange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    ["-|-"](...args) {
        return sqlFunction("-|-", [{ args: [anymultirange, anymultirange], ret: (default_1$8), isOperator: true }, { args: [anymultirange, anyrange], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">>"](...args) {
        return sqlFunction(">>", [{ args: [anymultirange, anymultirange], ret: (default_1$8), isOperator: true }, { args: [anymultirange, anyrange], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<<"](...args) {
        return sqlFunction("<<", [{ args: [anymultirange, anymultirange], ret: (default_1$8), isOperator: true }, { args: [anymultirange, anyrange], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["@>"](...args) {
        return sqlFunction("@>", [({ T }) => ({ args: [anymultirange, T], ret: (default_1$8), isOperator: true }), { args: [anymultirange, anymultirange], ret: (default_1$8), isOperator: true }, { args: [anymultirange, anyrange], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [{ args: [anymultirange, anymultirange], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">="](...args) {
        return sqlFunction(">=", [{ args: [anymultirange, anymultirange], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">"](...args) {
        return sqlFunction(">", [{ args: [anymultirange, anymultirange], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["*"](...args) {
        return sqlFunction("*", [{ args: [anymultirange, anymultirange], ret: anymultirange, isOperator: true }], [this, ...args]);
    }
    ["<="](...args) {
        return sqlFunction("<=", [{ args: [anymultirange, anymultirange], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<"](...args) {
        return sqlFunction("<", [{ args: [anymultirange, anymultirange], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["-"](...args) {
        return sqlFunction("-", [{ args: [anymultirange, anymultirange], ret: anymultirange, isOperator: true }], [this, ...args]);
    }
    ["<>"](...args) {
        return sqlFunction("<>", [{ args: [anymultirange, anymultirange], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["&&"](...args) {
        return sqlFunction("&&", [{ args: [anymultirange, anymultirange], ret: (default_1$8), isOperator: true }, { args: [anymultirange, anyrange], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["&<"](...args) {
        return sqlFunction("&<", [{ args: [anymultirange, anymultirange], ret: (default_1$8), isOperator: true }, { args: [anymultirange, anyrange], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["&>"](...args) {
        return sqlFunction("&>", [{ args: [anymultirange, anymultirange], ret: (default_1$8), isOperator: true }, { args: [anymultirange, anyrange], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["+"](...args) {
        return sqlFunction("+", [{ args: [anymultirange, anymultirange], ret: anymultirange, isOperator: true }], [this, ...args]);
    }
}

class anynonarray extends Any {
    static parse(v) { return v; }
    static typeString() { return "anynonarray"; }
    asAggregate() {
        return undefined;
    }
    anytextcat(...args) {
        return sqlFunction("anytextcat", [({ T }) => ({ args: [T, (default_1$1)], ret: (default_1$1), isOperator: false })], [this, ...args]);
    }
    arrayAgg(...args) {
        return sqlFunction("array_agg", [({ T }) => ({ args: [T], ret: Array$1.of(T), isOperator: false })], [this, ...args]);
    }
}

class anyrange extends Any {
    static parse(v) { return v; }
    static typeString() { return "anyrange"; }
    asAggregate() {
        return undefined;
    }
    hashRange(...args) {
        return sqlFunction("hash_range", [{ args: [anyrange], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    hashRangeExtended(...args) {
        return sqlFunction("hash_range_extended", [{ args: [anyrange, (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    isempty(...args) {
        return sqlFunction("isempty", [{ args: [anyrange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    lower(...args) {
        return sqlFunction("lower", [({ T }) => ({ args: [anyrange], ret: T, isOperator: false })], [this, ...args]);
    }
    lowerInc(...args) {
        return sqlFunction("lower_inc", [{ args: [anyrange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    lowerInf(...args) {
        return sqlFunction("lower_inf", [{ args: [anyrange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    multirange(...args) {
        return sqlFunction("multirange", [{ args: [anyrange], ret: anymultirange, isOperator: false }], [this, ...args]);
    }
    rangeAdjacent(...args) {
        return sqlFunction("range_adjacent", [{ args: [anyrange, anyrange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    rangeAdjacentMultirange(...args) {
        return sqlFunction("range_adjacent_multirange", [{ args: [anyrange, anymultirange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    rangeAfter(...args) {
        return sqlFunction("range_after", [{ args: [anyrange, anyrange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    rangeAfterMultirange(...args) {
        return sqlFunction("range_after_multirange", [{ args: [anyrange, anymultirange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    rangeAgg(...args) {
        return sqlFunction("range_agg", [{ args: [anyrange], ret: anymultirange, isOperator: false }], [this, ...args]);
    }
    rangeBefore(...args) {
        return sqlFunction("range_before", [{ args: [anyrange, anyrange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    rangeBeforeMultirange(...args) {
        return sqlFunction("range_before_multirange", [{ args: [anyrange, anymultirange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    rangeCmp(...args) {
        return sqlFunction("range_cmp", [{ args: [anyrange, anyrange], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    rangeContainedBy(...args) {
        return sqlFunction("range_contained_by", [{ args: [anyrange, anyrange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    rangeContainedByMultirange(...args) {
        return sqlFunction("range_contained_by_multirange", [{ args: [anyrange, anymultirange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    rangeContains(...args) {
        return sqlFunction("range_contains", [{ args: [anyrange, anyrange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    rangeContainsElem(...args) {
        return sqlFunction("range_contains_elem", [({ T }) => ({ args: [anyrange, T], ret: (default_1$8), isOperator: false })], [this, ...args]);
    }
    rangeContainsMultirange(...args) {
        return sqlFunction("range_contains_multirange", [{ args: [anyrange, anymultirange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    rangeEq(...args) {
        return sqlFunction("range_eq", [{ args: [anyrange, anyrange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    rangeGe(...args) {
        return sqlFunction("range_ge", [{ args: [anyrange, anyrange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    rangeGt(...args) {
        return sqlFunction("range_gt", [{ args: [anyrange, anyrange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    rangeIntersect(...args) {
        return sqlFunction("range_intersect", [{ args: [anyrange, anyrange], ret: anyrange, isOperator: false }], [this, ...args]);
    }
    rangeIntersectAgg(...args) {
        return sqlFunction("range_intersect_agg", [{ args: [anyrange], ret: anyrange, isOperator: false }], [this, ...args]);
    }
    rangeIntersectAggTransfn(...args) {
        return sqlFunction("range_intersect_agg_transfn", [{ args: [anyrange, anyrange], ret: anyrange, isOperator: false }], [this, ...args]);
    }
    rangeLe(...args) {
        return sqlFunction("range_le", [{ args: [anyrange, anyrange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    rangeLt(...args) {
        return sqlFunction("range_lt", [{ args: [anyrange, anyrange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    rangeMerge(...args) {
        return sqlFunction("range_merge", [{ args: [anyrange, anyrange], ret: anyrange, isOperator: false }], [this, ...args]);
    }
    rangeMinus(...args) {
        return sqlFunction("range_minus", [{ args: [anyrange, anyrange], ret: anyrange, isOperator: false }], [this, ...args]);
    }
    rangeNe(...args) {
        return sqlFunction("range_ne", [{ args: [anyrange, anyrange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    rangeOverlaps(...args) {
        return sqlFunction("range_overlaps", [{ args: [anyrange, anyrange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    rangeOverlapsMultirange(...args) {
        return sqlFunction("range_overlaps_multirange", [{ args: [anyrange, anymultirange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    rangeOverleft(...args) {
        return sqlFunction("range_overleft", [{ args: [anyrange, anyrange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    rangeOverleftMultirange(...args) {
        return sqlFunction("range_overleft_multirange", [{ args: [anyrange, anymultirange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    rangeOverright(...args) {
        return sqlFunction("range_overright", [{ args: [anyrange, anyrange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    rangeOverrightMultirange(...args) {
        return sqlFunction("range_overright_multirange", [{ args: [anyrange, anymultirange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    rangeUnion(...args) {
        return sqlFunction("range_union", [{ args: [anyrange, anyrange], ret: anyrange, isOperator: false }], [this, ...args]);
    }
    upper(...args) {
        return sqlFunction("upper", [({ T }) => ({ args: [anyrange], ret: T, isOperator: false })], [this, ...args]);
    }
    upperInc(...args) {
        return sqlFunction("upper_inc", [{ args: [anyrange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    upperInf(...args) {
        return sqlFunction("upper_inf", [{ args: [anyrange], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    ["-|-"](...args) {
        return sqlFunction("-|-", [{ args: [anyrange, anyrange], ret: (default_1$8), isOperator: true }, { args: [anyrange, anymultirange], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">>"](...args) {
        return sqlFunction(">>", [{ args: [anyrange, anyrange], ret: (default_1$8), isOperator: true }, { args: [anyrange, anymultirange], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<<"](...args) {
        return sqlFunction("<<", [{ args: [anyrange, anyrange], ret: (default_1$8), isOperator: true }, { args: [anyrange, anymultirange], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["@>"](...args) {
        return sqlFunction("@>", [{ args: [anyrange, anyrange], ret: (default_1$8), isOperator: true }, ({ T }) => ({ args: [anyrange, T], ret: (default_1$8), isOperator: true }), { args: [anyrange, anymultirange], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [{ args: [anyrange, anyrange], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">="](...args) {
        return sqlFunction(">=", [{ args: [anyrange, anyrange], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">"](...args) {
        return sqlFunction(">", [{ args: [anyrange, anyrange], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["*"](...args) {
        return sqlFunction("*", [{ args: [anyrange, anyrange], ret: anyrange, isOperator: true }], [this, ...args]);
    }
    ["<="](...args) {
        return sqlFunction("<=", [{ args: [anyrange, anyrange], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<"](...args) {
        return sqlFunction("<", [{ args: [anyrange, anyrange], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["-"](...args) {
        return sqlFunction("-", [{ args: [anyrange, anyrange], ret: anyrange, isOperator: true }], [this, ...args]);
    }
    ["<>"](...args) {
        return sqlFunction("<>", [{ args: [anyrange, anyrange], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["&&"](...args) {
        return sqlFunction("&&", [{ args: [anyrange, anyrange], ret: (default_1$8), isOperator: true }, { args: [anyrange, anymultirange], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["&<"](...args) {
        return sqlFunction("&<", [{ args: [anyrange, anyrange], ret: (default_1$8), isOperator: true }, { args: [anyrange, anymultirange], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["&>"](...args) {
        return sqlFunction("&>", [{ args: [anyrange, anyrange], ret: (default_1$8), isOperator: true }, { args: [anyrange, anymultirange], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["+"](...args) {
        return sqlFunction("+", [{ args: [anyrange, anyrange], ret: anyrange, isOperator: true }], [this, ...args]);
    }
}

class bit$1 extends Any {
    static new(v) { return new bit$1(v); }
    static parse(v) { return v; }
    static typeString() { return "bit"; }
    asAggregate() {
        return undefined;
    }
    bit(...args) {
        return sqlFunction("bit", [{ args: [(bit$1), (default_1$4), (default_1$8)], ret: (bit$1), isOperator: false }], [this, ...args]);
    }
    bitAnd(...args) {
        return sqlFunction("bit_and", [{ args: [(bit$1)], ret: (bit$1), isOperator: false }], [this, ...args]);
    }
    bitCount(...args) {
        return sqlFunction("bit_count", [{ args: [(bit$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    bitLength(...args) {
        return sqlFunction("bit_length", [{ args: [(bit$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    bitOr(...args) {
        return sqlFunction("bit_or", [{ args: [(bit$1)], ret: (bit$1), isOperator: false }], [this, ...args]);
    }
    bitXor(...args) {
        return sqlFunction("bit_xor", [{ args: [(bit$1)], ret: (bit$1), isOperator: false }], [this, ...args]);
    }
    bitand(...args) {
        return sqlFunction("bitand", [{ args: [(bit$1), (bit$1)], ret: (bit$1), isOperator: false }], [this, ...args]);
    }
    bitcmp(...args) {
        return sqlFunction("bitcmp", [{ args: [(bit$1), (bit$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    biteq(...args) {
        return sqlFunction("biteq", [{ args: [(bit$1), (bit$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    bitge(...args) {
        return sqlFunction("bitge", [{ args: [(bit$1), (bit$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    bitgt(...args) {
        return sqlFunction("bitgt", [{ args: [(bit$1), (bit$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    bitle(...args) {
        return sqlFunction("bitle", [{ args: [(bit$1), (bit$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    bitlt(...args) {
        return sqlFunction("bitlt", [{ args: [(bit$1), (bit$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    bitne(...args) {
        return sqlFunction("bitne", [{ args: [(bit$1), (bit$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    bitnot(...args) {
        return sqlFunction("bitnot", [{ args: [(bit$1)], ret: (bit$1), isOperator: false }], [this, ...args]);
    }
    bitor(...args) {
        return sqlFunction("bitor", [{ args: [(bit$1), (bit$1)], ret: (bit$1), isOperator: false }], [this, ...args]);
    }
    bitshiftleft(...args) {
        return sqlFunction("bitshiftleft", [{ args: [(bit$1), (default_1$4)], ret: (bit$1), isOperator: false }], [this, ...args]);
    }
    bitshiftright(...args) {
        return sqlFunction("bitshiftright", [{ args: [(bit$1), (default_1$4)], ret: (bit$1), isOperator: false }], [this, ...args]);
    }
    bitxor(...args) {
        return sqlFunction("bitxor", [{ args: [(bit$1), (bit$1)], ret: (bit$1), isOperator: false }], [this, ...args]);
    }
    getBit(...args) {
        return sqlFunction("get_bit", [{ args: [(bit$1), (default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    int4(...args) {
        return sqlFunction("int4", [{ args: [(bit$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    int8(...args) {
        return sqlFunction("int8", [{ args: [(bit$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    length(...args) {
        return sqlFunction("length", [{ args: [(bit$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    octetLength(...args) {
        return sqlFunction("octet_length", [{ args: [(bit$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    overlay(...args) {
        return sqlFunction("overlay", [{ args: [(bit$1), (bit$1), (default_1$4)], ret: (bit$1), isOperator: false }, { args: [(bit$1), (bit$1), (default_1$4), (default_1$4)], ret: (bit$1), isOperator: false }], [this, ...args]);
    }
    position(...args) {
        return sqlFunction("position", [{ args: [(bit$1), (bit$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    setBit(...args) {
        return sqlFunction("set_bit", [{ args: [(bit$1), (default_1$4), (default_1$4)], ret: (bit$1), isOperator: false }], [this, ...args]);
    }
    substring(...args) {
        return sqlFunction("substring", [{ args: [(bit$1), (default_1$4)], ret: (bit$1), isOperator: false }, { args: [(bit$1), (default_1$4), (default_1$4)], ret: (bit$1), isOperator: false }], [this, ...args]);
    }
    ["&"](...args) {
        return sqlFunction("&", [{ args: [(bit$1), (bit$1)], ret: (bit$1), isOperator: true }], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [{ args: [(bit$1), (bit$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">="](...args) {
        return sqlFunction(">=", [{ args: [(bit$1), (bit$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">"](...args) {
        return sqlFunction(">", [{ args: [(bit$1), (bit$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<="](...args) {
        return sqlFunction("<=", [{ args: [(bit$1), (bit$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<"](...args) {
        return sqlFunction("<", [{ args: [(bit$1), (bit$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<>"](...args) {
        return sqlFunction("<>", [{ args: [(bit$1), (bit$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["|"](...args) {
        return sqlFunction("|", [{ args: [(bit$1), (bit$1)], ret: (bit$1), isOperator: true }], [this, ...args]);
    }
    ["<<"](...args) {
        return sqlFunction("<<", [{ args: [(bit$1), (default_1$4)], ret: (bit$1), isOperator: true }], [this, ...args]);
    }
    [">>"](...args) {
        return sqlFunction(">>", [{ args: [(bit$1), (default_1$4)], ret: (bit$1), isOperator: true }], [this, ...args]);
    }
    ["#"](...args) {
        return sqlFunction("#", [{ args: [(bit$1), (bit$1)], ret: (bit$1), isOperator: true }], [this, ...args]);
    }
}

const typeMap = {
    bool: {
        parse: (value) => {
            // from node-pg-types
            return (value === "TRUE" ||
                value === "t" ||
                value === "true" ||
                value === "y" ||
                value === "yes" ||
                value === "on" ||
                value === "1");
        },
        serialize: (value) => (value ? "true" : "false"),
        serializeFromTypes: ["boolean"],
    },
    int2: {
        parse: Number,
        serialize: (value) => value.toString(),
        serializeFromTypes: ["number"],
    },
    int4: {
        parse: Number,
        serialize: (value) => value.toString(),
        serializeFromTypes: ["number"],
    },
    int8: {
        parse: BigInt,
        serialize: (value) => value.toString(),
        serializeFromTypes: ["bigint"],
    },
    float4: {
        parse: parseFloat,
        serialize: (value) => value.toString(),
        serializeFromTypes: ["number"],
    },
    float8: {
        parse: parseFloat,
        serialize: (value) => value.toString(),
        serializeFromTypes: ["number"],
    },
    numeric: {
        parse: (x) => x,
        serialize: (value) => value.toString(),
        serializeFromTypes: ["number", "bigint", "string"],
    },
    text: {
        parse: (x) => x,
        serialize: (value) => value,
        serializeFromTypes: ["string"],
    },
};

let default_1$8 = class default_1 extends Any {
    static new(v) { return new default_1$8(v); }
    static serializeParamTypes = undefined;
    static parse(v) { return typeMap["bool"].parse(v); }
    static typeString() { return "bool"; }
    asAggregate() {
        return undefined;
    }
    binaryUpgradeSetRecordInitPrivs(...args) {
        return sqlFunction("binary_upgrade_set_record_init_privs", [{ args: [(default_1$8)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    boolAnd(...args) {
        return sqlFunction("bool_and", [{ args: [(default_1$8)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    boolOr(...args) {
        return sqlFunction("bool_or", [{ args: [(default_1$8)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    boolandStatefunc(...args) {
        return sqlFunction("booland_statefunc", [{ args: [(default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    booleq(...args) {
        return sqlFunction("booleq", [{ args: [(default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    boolge(...args) {
        return sqlFunction("boolge", [{ args: [(default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    boolgt(...args) {
        return sqlFunction("boolgt", [{ args: [(default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    boolle(...args) {
        return sqlFunction("boolle", [{ args: [(default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    boollt(...args) {
        return sqlFunction("boollt", [{ args: [(default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    boolne(...args) {
        return sqlFunction("boolne", [{ args: [(default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    boolorStatefunc(...args) {
        return sqlFunction("boolor_statefunc", [{ args: [(default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    btboolcmp(...args) {
        return sqlFunction("btboolcmp", [{ args: [(default_1$8), (default_1$8)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    currentSchemas(...args) {
        return sqlFunction("current_schemas", [{ args: [(default_1$8)], ret: Array$1.of((name$1)), isOperator: false }], [this, ...args]);
    }
    databaseToXml(...args) {
        return sqlFunction("database_to_xml", [{ args: [(default_1$8), (default_1$8), (default_1$1)], ret: (xml$1), isOperator: false }], [this, ...args]);
    }
    databaseToXmlAndXmlschema(...args) {
        return sqlFunction("database_to_xml_and_xmlschema", [{ args: [(default_1$8), (default_1$8), (default_1$1)], ret: (xml$1), isOperator: false }], [this, ...args]);
    }
    databaseToXmlschema(...args) {
        return sqlFunction("database_to_xmlschema", [{ args: [(default_1$8), (default_1$8), (default_1$1)], ret: (xml$1), isOperator: false }], [this, ...args]);
    }
    every(...args) {
        return sqlFunction("every", [{ args: [(default_1$8)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int4(...args) {
        return sqlFunction("int4", [{ args: [(default_1$8)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    pgBackupStop(...args) {
        return sqlFunction("pg_backup_stop", [{ args: [(default_1$8)], ret: Record.of({ lsn: (pg_lsn), labelfile: (default_1$1), spcmapfile: (default_1$1) }), isOperator: false }], [this, ...args]);
    }
    pgLogicalEmitMessage(...args) {
        return sqlFunction("pg_logical_emit_message", [{ args: [(default_1$8), (default_1$1), (bytea), (default_1$8)], ret: (pg_lsn), isOperator: false }, { args: [(default_1$8), (default_1$1), (default_1$1), (default_1$8)], ret: (pg_lsn), isOperator: false }], [this, ...args]);
    }
    pgPromote(...args) {
        return sqlFunction("pg_promote", [{ args: [(default_1$8), (default_1$4)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgReplicationOriginSessionProgress(...args) {
        return sqlFunction("pg_replication_origin_session_progress", [{ args: [(default_1$8)], ret: (pg_lsn), isOperator: false }], [this, ...args]);
    }
    text(...args) {
        return sqlFunction("text", [{ args: [(default_1$8)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [{ args: [(default_1$8), (default_1$8)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">="](...args) {
        return sqlFunction(">=", [{ args: [(default_1$8), (default_1$8)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">"](...args) {
        return sqlFunction(">", [{ args: [(default_1$8), (default_1$8)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<="](...args) {
        return sqlFunction("<=", [{ args: [(default_1$8), (default_1$8)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<"](...args) {
        return sqlFunction("<", [{ args: [(default_1$8), (default_1$8)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<>"](...args) {
        return sqlFunction("<>", [{ args: [(default_1$8), (default_1$8)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
};

class box$1 extends Any {
    static new(v) { return new box$1(v); }
    static parse(v) { return v; }
    static typeString() { return "box"; }
    asAggregate() {
        return undefined;
    }
    area(...args) {
        return sqlFunction("area", [{ args: [(box$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    boundBox(...args) {
        return sqlFunction("bound_box", [{ args: [(box$1), (box$1)], ret: (box$1), isOperator: false }], [this, ...args]);
    }
    boxAbove(...args) {
        return sqlFunction("box_above", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    boxAboveEq(...args) {
        return sqlFunction("box_above_eq", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    boxAdd(...args) {
        return sqlFunction("box_add", [{ args: [(box$1), (point$1)], ret: (box$1), isOperator: false }], [this, ...args]);
    }
    boxBelow(...args) {
        return sqlFunction("box_below", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    boxBelowEq(...args) {
        return sqlFunction("box_below_eq", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    boxCenter(...args) {
        return sqlFunction("box_center", [{ args: [(box$1)], ret: (point$1), isOperator: false }], [this, ...args]);
    }
    boxContainPt(...args) {
        return sqlFunction("box_contain_pt", [{ args: [(box$1), (point$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    boxContained(...args) {
        return sqlFunction("box_contained", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    boxDistance(...args) {
        return sqlFunction("box_distance", [{ args: [(box$1), (box$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    boxDiv(...args) {
        return sqlFunction("box_div", [{ args: [(box$1), (point$1)], ret: (box$1), isOperator: false }], [this, ...args]);
    }
    boxEq(...args) {
        return sqlFunction("box_eq", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    boxGe(...args) {
        return sqlFunction("box_ge", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    boxGt(...args) {
        return sqlFunction("box_gt", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    boxIntersect(...args) {
        return sqlFunction("box_intersect", [{ args: [(box$1), (box$1)], ret: (box$1), isOperator: false }], [this, ...args]);
    }
    boxLe(...args) {
        return sqlFunction("box_le", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    boxLeft(...args) {
        return sqlFunction("box_left", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    boxLt(...args) {
        return sqlFunction("box_lt", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    boxMul(...args) {
        return sqlFunction("box_mul", [{ args: [(box$1), (point$1)], ret: (box$1), isOperator: false }], [this, ...args]);
    }
    boxOverabove(...args) {
        return sqlFunction("box_overabove", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    boxOverbelow(...args) {
        return sqlFunction("box_overbelow", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    boxOverlap(...args) {
        return sqlFunction("box_overlap", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: false }, { args: [(box$1), (box$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    boxOverleft(...args) {
        return sqlFunction("box_overleft", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    boxOverright(...args) {
        return sqlFunction("box_overright", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    boxRight(...args) {
        return sqlFunction("box_right", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    boxSame(...args) {
        return sqlFunction("box_same", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    boxSub(...args) {
        return sqlFunction("box_sub", [{ args: [(box$1), (point$1)], ret: (box$1), isOperator: false }], [this, ...args]);
    }
    center(...args) {
        return sqlFunction("center", [{ args: [(box$1)], ret: (point$1), isOperator: false }], [this, ...args]);
    }
    circle(...args) {
        return sqlFunction("circle", [{ args: [(box$1)], ret: (circle$1), isOperator: false }], [this, ...args]);
    }
    diagonal(...args) {
        return sqlFunction("diagonal", [{ args: [(box$1)], ret: (lseg$1), isOperator: false }], [this, ...args]);
    }
    distBp(...args) {
        return sqlFunction("dist_bp", [{ args: [(box$1), (point$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    distBs(...args) {
        return sqlFunction("dist_bs", [{ args: [(box$1), (lseg$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    height(...args) {
        return sqlFunction("height", [{ args: [(box$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    lseg(...args) {
        return sqlFunction("lseg", [{ args: [(box$1)], ret: (lseg$1), isOperator: false }], [this, ...args]);
    }
    point(...args) {
        return sqlFunction("point", [{ args: [(box$1)], ret: (point$1), isOperator: false }], [this, ...args]);
    }
    polygon(...args) {
        return sqlFunction("polygon", [{ args: [(box$1)], ret: (polygon$1), isOperator: false }], [this, ...args]);
    }
    width(...args) {
        return sqlFunction("width", [{ args: [(box$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    ["|>>"](...args) {
        return sqlFunction("|>>", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">^"](...args) {
        return sqlFunction(">^", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["+"](...args) {
        return sqlFunction("+", [{ args: [(box$1), (point$1)], ret: (box$1), isOperator: true }], [this, ...args]);
    }
    ["<<|"](...args) {
        return sqlFunction("<<|", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<^"](...args) {
        return sqlFunction("<^", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["@>"](...args) {
        return sqlFunction("@>", [{ args: [(box$1), (point$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<->"](...args) {
        return sqlFunction("<->", [{ args: [(box$1), (box$1)], ret: (default_1$6), isOperator: true }, { args: [(box$1), (point$1)], ret: (default_1$6), isOperator: true }, { args: [(box$1), (lseg$1)], ret: (default_1$6), isOperator: true }], [this, ...args]);
    }
    ["/"](...args) {
        return sqlFunction("/", [{ args: [(box$1), (point$1)], ret: (box$1), isOperator: true }], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">="](...args) {
        return sqlFunction(">=", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">"](...args) {
        return sqlFunction(">", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["#"](...args) {
        return sqlFunction("#", [{ args: [(box$1), (box$1)], ret: (box$1), isOperator: true }], [this, ...args]);
    }
    ["<="](...args) {
        return sqlFunction("<=", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<<"](...args) {
        return sqlFunction("<<", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<"](...args) {
        return sqlFunction("<", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["*"](...args) {
        return sqlFunction("*", [{ args: [(box$1), (point$1)], ret: (box$1), isOperator: true }], [this, ...args]);
    }
    ["|&>"](...args) {
        return sqlFunction("|&>", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["&<|"](...args) {
        return sqlFunction("&<|", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["?#"](...args) {
        return sqlFunction("?#", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["&&"](...args) {
        return sqlFunction("&&", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["&<"](...args) {
        return sqlFunction("&<", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["&>"](...args) {
        return sqlFunction("&>", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">>"](...args) {
        return sqlFunction(">>", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["~="](...args) {
        return sqlFunction("~=", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["-"](...args) {
        return sqlFunction("-", [{ args: [(box$1), (point$1)], ret: (box$1), isOperator: true }], [this, ...args]);
    }
}

class bpchar$1 extends Any {
    static new(v) { return new bpchar$1(v); }
    static parse(v) { return v; }
    static typeString() { return "bpchar"; }
    asAggregate() {
        return undefined;
    }
    bpchar(...args) {
        return sqlFunction("bpchar", [{ args: [(bpchar$1), (default_1$4), (default_1$8)], ret: (bpchar$1), isOperator: false }], [this, ...args]);
    }
    bpcharLarger(...args) {
        return sqlFunction("bpchar_larger", [{ args: [(bpchar$1), (bpchar$1)], ret: (bpchar$1), isOperator: false }], [this, ...args]);
    }
    bpcharPatternGe(...args) {
        return sqlFunction("bpchar_pattern_ge", [{ args: [(bpchar$1), (bpchar$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    bpcharPatternGt(...args) {
        return sqlFunction("bpchar_pattern_gt", [{ args: [(bpchar$1), (bpchar$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    bpcharPatternLe(...args) {
        return sqlFunction("bpchar_pattern_le", [{ args: [(bpchar$1), (bpchar$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    bpcharPatternLt(...args) {
        return sqlFunction("bpchar_pattern_lt", [{ args: [(bpchar$1), (bpchar$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    bpcharSmaller(...args) {
        return sqlFunction("bpchar_smaller", [{ args: [(bpchar$1), (bpchar$1)], ret: (bpchar$1), isOperator: false }], [this, ...args]);
    }
    bpcharcmp(...args) {
        return sqlFunction("bpcharcmp", [{ args: [(bpchar$1), (bpchar$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    bpchareq(...args) {
        return sqlFunction("bpchareq", [{ args: [(bpchar$1), (bpchar$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    bpcharge(...args) {
        return sqlFunction("bpcharge", [{ args: [(bpchar$1), (bpchar$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    bpchargt(...args) {
        return sqlFunction("bpchargt", [{ args: [(bpchar$1), (bpchar$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    bpchariclike(...args) {
        return sqlFunction("bpchariclike", [{ args: [(bpchar$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    bpcharicnlike(...args) {
        return sqlFunction("bpcharicnlike", [{ args: [(bpchar$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    bpcharicregexeq(...args) {
        return sqlFunction("bpcharicregexeq", [{ args: [(bpchar$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    bpcharicregexne(...args) {
        return sqlFunction("bpcharicregexne", [{ args: [(bpchar$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    bpcharle(...args) {
        return sqlFunction("bpcharle", [{ args: [(bpchar$1), (bpchar$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    bpcharlike(...args) {
        return sqlFunction("bpcharlike", [{ args: [(bpchar$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    bpcharlt(...args) {
        return sqlFunction("bpcharlt", [{ args: [(bpchar$1), (bpchar$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    bpcharne(...args) {
        return sqlFunction("bpcharne", [{ args: [(bpchar$1), (bpchar$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    bpcharnlike(...args) {
        return sqlFunction("bpcharnlike", [{ args: [(bpchar$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    bpcharregexeq(...args) {
        return sqlFunction("bpcharregexeq", [{ args: [(bpchar$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    bpcharregexne(...args) {
        return sqlFunction("bpcharregexne", [{ args: [(bpchar$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    btbpcharPatternCmp(...args) {
        return sqlFunction("btbpchar_pattern_cmp", [{ args: [(bpchar$1), (bpchar$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    charLength(...args) {
        return sqlFunction("char_length", [{ args: [(bpchar$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    characterLength(...args) {
        return sqlFunction("character_length", [{ args: [(bpchar$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    hashbpchar(...args) {
        return sqlFunction("hashbpchar", [{ args: [(bpchar$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    hashbpcharextended(...args) {
        return sqlFunction("hashbpcharextended", [{ args: [(bpchar$1), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    length(...args) {
        return sqlFunction("length", [{ args: [(bpchar$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    max(...args) {
        return sqlFunction("max", [{ args: [(bpchar$1)], ret: (bpchar$1), isOperator: false }], [this, ...args]);
    }
    name(...args) {
        return sqlFunction("name", [{ args: [(bpchar$1)], ret: (name$1), isOperator: false }], [this, ...args]);
    }
    octetLength(...args) {
        return sqlFunction("octet_length", [{ args: [(bpchar$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    text(...args) {
        return sqlFunction("text", [{ args: [(bpchar$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    ["~>=~"](...args) {
        return sqlFunction("~>=~", [{ args: [(bpchar$1), (bpchar$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["~>~"](...args) {
        return sqlFunction("~>~", [{ args: [(bpchar$1), (bpchar$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["~<=~"](...args) {
        return sqlFunction("~<=~", [{ args: [(bpchar$1), (bpchar$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["~<~"](...args) {
        return sqlFunction("~<~", [{ args: [(bpchar$1), (bpchar$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [{ args: [(bpchar$1), (bpchar$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">="](...args) {
        return sqlFunction(">=", [{ args: [(bpchar$1), (bpchar$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">"](...args) {
        return sqlFunction(">", [{ args: [(bpchar$1), (bpchar$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["~~*"](...args) {
        return sqlFunction("~~*", [{ args: [(bpchar$1), (default_1$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["!~~*"](...args) {
        return sqlFunction("!~~*", [{ args: [(bpchar$1), (default_1$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["~*"](...args) {
        return sqlFunction("~*", [{ args: [(bpchar$1), (default_1$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["!~*"](...args) {
        return sqlFunction("!~*", [{ args: [(bpchar$1), (default_1$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<="](...args) {
        return sqlFunction("<=", [{ args: [(bpchar$1), (bpchar$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["~~"](...args) {
        return sqlFunction("~~", [{ args: [(bpchar$1), (default_1$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<"](...args) {
        return sqlFunction("<", [{ args: [(bpchar$1), (bpchar$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<>"](...args) {
        return sqlFunction("<>", [{ args: [(bpchar$1), (bpchar$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["!~~"](...args) {
        return sqlFunction("!~~", [{ args: [(bpchar$1), (default_1$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["~"](...args) {
        return sqlFunction("~", [{ args: [(bpchar$1), (default_1$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["!~"](...args) {
        return sqlFunction("!~", [{ args: [(bpchar$1), (default_1$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
}

class bytea extends Any {
    static new(v) { return new bytea(v); }
    static parse(v) { return v; }
    static typeString() { return "bytea"; }
    asAggregate() {
        return undefined;
    }
    bitCount(...args) {
        return sqlFunction("bit_count", [{ args: [(bytea)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    bitLength(...args) {
        return sqlFunction("bit_length", [{ args: [(bytea)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    btrim(...args) {
        return sqlFunction("btrim", [{ args: [(bytea), (bytea)], ret: (bytea), isOperator: false }], [this, ...args]);
    }
    byteacat(...args) {
        return sqlFunction("byteacat", [{ args: [(bytea), (bytea)], ret: (bytea), isOperator: false }], [this, ...args]);
    }
    byteacmp(...args) {
        return sqlFunction("byteacmp", [{ args: [(bytea), (bytea)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    byteaeq(...args) {
        return sqlFunction("byteaeq", [{ args: [(bytea), (bytea)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    byteage(...args) {
        return sqlFunction("byteage", [{ args: [(bytea), (bytea)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    byteagt(...args) {
        return sqlFunction("byteagt", [{ args: [(bytea), (bytea)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    byteale(...args) {
        return sqlFunction("byteale", [{ args: [(bytea), (bytea)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    bytealike(...args) {
        return sqlFunction("bytealike", [{ args: [(bytea), (bytea)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    bytealt(...args) {
        return sqlFunction("bytealt", [{ args: [(bytea), (bytea)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    byteane(...args) {
        return sqlFunction("byteane", [{ args: [(bytea), (bytea)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    byteanlike(...args) {
        return sqlFunction("byteanlike", [{ args: [(bytea), (bytea)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    convert(...args) {
        return sqlFunction("convert", [{ args: [(bytea), (name$1), (name$1)], ret: (bytea), isOperator: false }], [this, ...args]);
    }
    convertFrom(...args) {
        return sqlFunction("convert_from", [{ args: [(bytea), (name$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    encode(...args) {
        return sqlFunction("encode", [{ args: [(bytea), (default_1$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    getBit(...args) {
        return sqlFunction("get_bit", [{ args: [(bytea), (default_1$3)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    getByte(...args) {
        return sqlFunction("get_byte", [{ args: [(bytea), (default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    length(...args) {
        return sqlFunction("length", [{ args: [(bytea)], ret: (default_1$4), isOperator: false }, { args: [(bytea), (name$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    like(...args) {
        return sqlFunction("like", [{ args: [(bytea), (bytea)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    likeEscape(...args) {
        return sqlFunction("like_escape", [{ args: [(bytea), (bytea)], ret: (bytea), isOperator: false }], [this, ...args]);
    }
    ltrim(...args) {
        return sqlFunction("ltrim", [{ args: [(bytea), (bytea)], ret: (bytea), isOperator: false }], [this, ...args]);
    }
    md5(...args) {
        return sqlFunction("md5", [{ args: [(bytea)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    notlike(...args) {
        return sqlFunction("notlike", [{ args: [(bytea), (bytea)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    octetLength(...args) {
        return sqlFunction("octet_length", [{ args: [(bytea)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    overlay(...args) {
        return sqlFunction("overlay", [{ args: [(bytea), (bytea), (default_1$4)], ret: (bytea), isOperator: false }, { args: [(bytea), (bytea), (default_1$4), (default_1$4)], ret: (bytea), isOperator: false }], [this, ...args]);
    }
    position(...args) {
        return sqlFunction("position", [{ args: [(bytea), (bytea)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    rtrim(...args) {
        return sqlFunction("rtrim", [{ args: [(bytea), (bytea)], ret: (bytea), isOperator: false }], [this, ...args]);
    }
    setBit(...args) {
        return sqlFunction("set_bit", [{ args: [(bytea), (default_1$3), (default_1$4)], ret: (bytea), isOperator: false }], [this, ...args]);
    }
    setByte(...args) {
        return sqlFunction("set_byte", [{ args: [(bytea), (default_1$4), (default_1$4)], ret: (bytea), isOperator: false }], [this, ...args]);
    }
    sha224(...args) {
        return sqlFunction("sha224", [{ args: [(bytea)], ret: (bytea), isOperator: false }], [this, ...args]);
    }
    sha256(...args) {
        return sqlFunction("sha256", [{ args: [(bytea)], ret: (bytea), isOperator: false }], [this, ...args]);
    }
    sha384(...args) {
        return sqlFunction("sha384", [{ args: [(bytea)], ret: (bytea), isOperator: false }], [this, ...args]);
    }
    sha512(...args) {
        return sqlFunction("sha512", [{ args: [(bytea)], ret: (bytea), isOperator: false }], [this, ...args]);
    }
    stringAgg(...args) {
        return sqlFunction("string_agg", [{ args: [(bytea), (bytea)], ret: (bytea), isOperator: false }], [this, ...args]);
    }
    substr(...args) {
        return sqlFunction("substr", [{ args: [(bytea), (default_1$4)], ret: (bytea), isOperator: false }, { args: [(bytea), (default_1$4), (default_1$4)], ret: (bytea), isOperator: false }], [this, ...args]);
    }
    substring(...args) {
        return sqlFunction("substring", [{ args: [(bytea), (default_1$4)], ret: (bytea), isOperator: false }, { args: [(bytea), (default_1$4), (default_1$4)], ret: (bytea), isOperator: false }], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [{ args: [(bytea), (bytea)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">="](...args) {
        return sqlFunction(">=", [{ args: [(bytea), (bytea)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">"](...args) {
        return sqlFunction(">", [{ args: [(bytea), (bytea)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<="](...args) {
        return sqlFunction("<=", [{ args: [(bytea), (bytea)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["~~"](...args) {
        return sqlFunction("~~", [{ args: [(bytea), (bytea)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<"](...args) {
        return sqlFunction("<", [{ args: [(bytea), (bytea)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<>"](...args) {
        return sqlFunction("<>", [{ args: [(bytea), (bytea)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["!~~"](...args) {
        return sqlFunction("!~~", [{ args: [(bytea), (bytea)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
}

class char$1 extends Any {
    static new(v) { return new char$1(v); }
    static parse(v) { return v; }
    static typeString() { return "char"; }
    asAggregate() {
        return undefined;
    }
    acldefault(...args) {
        return sqlFunction("acldefault", [{ args: [(char$1), (oid$1)], ret: Array$1.of((aclitem)), isOperator: false }], [this, ...args]);
    }
    bpchar(...args) {
        return sqlFunction("bpchar", [{ args: [(char$1)], ret: (bpchar$1), isOperator: false }], [this, ...args]);
    }
    btcharcmp(...args) {
        return sqlFunction("btcharcmp", [{ args: [(char$1), (char$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    chareq(...args) {
        return sqlFunction("chareq", [{ args: [(char$1), (char$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    charge(...args) {
        return sqlFunction("charge", [{ args: [(char$1), (char$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    chargt(...args) {
        return sqlFunction("chargt", [{ args: [(char$1), (char$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    charle(...args) {
        return sqlFunction("charle", [{ args: [(char$1), (char$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    charlt(...args) {
        return sqlFunction("charlt", [{ args: [(char$1), (char$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    charne(...args) {
        return sqlFunction("charne", [{ args: [(char$1), (char$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    hashchar(...args) {
        return sqlFunction("hashchar", [{ args: [(char$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    hashcharextended(...args) {
        return sqlFunction("hashcharextended", [{ args: [(char$1), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    int4(...args) {
        return sqlFunction("int4", [{ args: [(char$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    text(...args) {
        return sqlFunction("text", [{ args: [(char$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [{ args: [(char$1), (char$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">="](...args) {
        return sqlFunction(">=", [{ args: [(char$1), (char$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">"](...args) {
        return sqlFunction(">", [{ args: [(char$1), (char$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<="](...args) {
        return sqlFunction("<=", [{ args: [(char$1), (char$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<"](...args) {
        return sqlFunction("<", [{ args: [(char$1), (char$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<>"](...args) {
        return sqlFunction("<>", [{ args: [(char$1), (char$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
}

class cid extends Any {
    static new(v) { return new cid(v); }
    static parse(v) { return v; }
    static typeString() { return "cid"; }
    asAggregate() {
        return undefined;
    }
    cideq(...args) {
        return sqlFunction("cideq", [{ args: [(cid), (cid)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [{ args: [(cid), (cid)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
}

class cidr$1 extends Any {
    static new(v) { return new cidr$1(v); }
    static parse(v) { return v; }
    static typeString() { return "cidr"; }
    asAggregate() {
        return undefined;
    }
    abbrev(...args) {
        return sqlFunction("abbrev", [{ args: [(cidr$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    setMasklen(...args) {
        return sqlFunction("set_masklen", [{ args: [(cidr$1), (default_1$4)], ret: (cidr$1), isOperator: false }], [this, ...args]);
    }
}

class circle$1 extends Any {
    static new(v) { return new circle$1(v); }
    static parse(v) { return v; }
    static typeString() { return "circle"; }
    asAggregate() {
        return undefined;
    }
    area(...args) {
        return sqlFunction("area", [{ args: [(circle$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    box(...args) {
        return sqlFunction("box", [{ args: [(circle$1)], ret: (box$1), isOperator: false }], [this, ...args]);
    }
    center(...args) {
        return sqlFunction("center", [{ args: [(circle$1)], ret: (point$1), isOperator: false }], [this, ...args]);
    }
    circleAbove(...args) {
        return sqlFunction("circle_above", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    circleAddPt(...args) {
        return sqlFunction("circle_add_pt", [{ args: [(circle$1), (point$1)], ret: (circle$1), isOperator: false }], [this, ...args]);
    }
    circleBelow(...args) {
        return sqlFunction("circle_below", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    circleCenter(...args) {
        return sqlFunction("circle_center", [{ args: [(circle$1)], ret: (point$1), isOperator: false }], [this, ...args]);
    }
    circleContainPt(...args) {
        return sqlFunction("circle_contain_pt", [{ args: [(circle$1), (point$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    circleContained(...args) {
        return sqlFunction("circle_contained", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    circleDistance(...args) {
        return sqlFunction("circle_distance", [{ args: [(circle$1), (circle$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    circleDivPt(...args) {
        return sqlFunction("circle_div_pt", [{ args: [(circle$1), (point$1)], ret: (circle$1), isOperator: false }], [this, ...args]);
    }
    circleEq(...args) {
        return sqlFunction("circle_eq", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    circleGe(...args) {
        return sqlFunction("circle_ge", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    circleGt(...args) {
        return sqlFunction("circle_gt", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    circleLe(...args) {
        return sqlFunction("circle_le", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    circleLeft(...args) {
        return sqlFunction("circle_left", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    circleLt(...args) {
        return sqlFunction("circle_lt", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    circleMulPt(...args) {
        return sqlFunction("circle_mul_pt", [{ args: [(circle$1), (point$1)], ret: (circle$1), isOperator: false }], [this, ...args]);
    }
    circleNe(...args) {
        return sqlFunction("circle_ne", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    circleOverabove(...args) {
        return sqlFunction("circle_overabove", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    circleOverbelow(...args) {
        return sqlFunction("circle_overbelow", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    circleOverlap(...args) {
        return sqlFunction("circle_overlap", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    circleOverleft(...args) {
        return sqlFunction("circle_overleft", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    circleOverright(...args) {
        return sqlFunction("circle_overright", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    circleRight(...args) {
        return sqlFunction("circle_right", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    circleSame(...args) {
        return sqlFunction("circle_same", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    circleSubPt(...args) {
        return sqlFunction("circle_sub_pt", [{ args: [(circle$1), (point$1)], ret: (circle$1), isOperator: false }], [this, ...args]);
    }
    diameter(...args) {
        return sqlFunction("diameter", [{ args: [(circle$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    distCpoint(...args) {
        return sqlFunction("dist_cpoint", [{ args: [(circle$1), (point$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    distCpoly(...args) {
        return sqlFunction("dist_cpoly", [{ args: [(circle$1), (polygon$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    point(...args) {
        return sqlFunction("point", [{ args: [(circle$1)], ret: (point$1), isOperator: false }], [this, ...args]);
    }
    polygon(...args) {
        return sqlFunction("polygon", [{ args: [(circle$1)], ret: (polygon$1), isOperator: false }], [this, ...args]);
    }
    radius(...args) {
        return sqlFunction("radius", [{ args: [(circle$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    ["|>>"](...args) {
        return sqlFunction("|>>", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["+"](...args) {
        return sqlFunction("+", [{ args: [(circle$1), (point$1)], ret: (circle$1), isOperator: true }], [this, ...args]);
    }
    ["<<|"](...args) {
        return sqlFunction("<<|", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["@>"](...args) {
        return sqlFunction("@>", [{ args: [(circle$1), (point$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<->"](...args) {
        return sqlFunction("<->", [{ args: [(circle$1), (circle$1)], ret: (default_1$6), isOperator: true }, { args: [(circle$1), (point$1)], ret: (default_1$6), isOperator: true }, { args: [(circle$1), (polygon$1)], ret: (default_1$6), isOperator: true }], [this, ...args]);
    }
    ["/"](...args) {
        return sqlFunction("/", [{ args: [(circle$1), (point$1)], ret: (circle$1), isOperator: true }], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">="](...args) {
        return sqlFunction(">=", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">"](...args) {
        return sqlFunction(">", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<="](...args) {
        return sqlFunction("<=", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<<"](...args) {
        return sqlFunction("<<", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<"](...args) {
        return sqlFunction("<", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["*"](...args) {
        return sqlFunction("*", [{ args: [(circle$1), (point$1)], ret: (circle$1), isOperator: true }], [this, ...args]);
    }
    ["<>"](...args) {
        return sqlFunction("<>", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["|&>"](...args) {
        return sqlFunction("|&>", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["&<|"](...args) {
        return sqlFunction("&<|", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["&&"](...args) {
        return sqlFunction("&&", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["&<"](...args) {
        return sqlFunction("&<", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["&>"](...args) {
        return sqlFunction("&>", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">>"](...args) {
        return sqlFunction(">>", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["~="](...args) {
        return sqlFunction("~=", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["-"](...args) {
        return sqlFunction("-", [{ args: [(circle$1), (point$1)], ret: (circle$1), isOperator: true }], [this, ...args]);
    }
}

class date$1 extends Any {
    static new(v) { return new date$1(v); }
    static parse(v) { return v; }
    static typeString() { return "date"; }
    asAggregate() {
        return undefined;
    }
    dateCmp(...args) {
        return sqlFunction("date_cmp", [{ args: [(date$1), (date$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    dateCmpTimestamp(...args) {
        return sqlFunction("date_cmp_timestamp", [{ args: [(date$1), (timestamp$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    dateCmpTimestamptz(...args) {
        return sqlFunction("date_cmp_timestamptz", [{ args: [(date$1), (timestamptz$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    dateEq(...args) {
        return sqlFunction("date_eq", [{ args: [(date$1), (date$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    dateEqTimestamp(...args) {
        return sqlFunction("date_eq_timestamp", [{ args: [(date$1), (timestamp$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    dateEqTimestamptz(...args) {
        return sqlFunction("date_eq_timestamptz", [{ args: [(date$1), (timestamptz$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    dateGe(...args) {
        return sqlFunction("date_ge", [{ args: [(date$1), (date$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    dateGeTimestamp(...args) {
        return sqlFunction("date_ge_timestamp", [{ args: [(date$1), (timestamp$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    dateGeTimestamptz(...args) {
        return sqlFunction("date_ge_timestamptz", [{ args: [(date$1), (timestamptz$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    dateGt(...args) {
        return sqlFunction("date_gt", [{ args: [(date$1), (date$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    dateGtTimestamp(...args) {
        return sqlFunction("date_gt_timestamp", [{ args: [(date$1), (timestamp$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    dateGtTimestamptz(...args) {
        return sqlFunction("date_gt_timestamptz", [{ args: [(date$1), (timestamptz$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    dateLarger(...args) {
        return sqlFunction("date_larger", [{ args: [(date$1), (date$1)], ret: (date$1), isOperator: false }], [this, ...args]);
    }
    dateLe(...args) {
        return sqlFunction("date_le", [{ args: [(date$1), (date$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    dateLeTimestamp(...args) {
        return sqlFunction("date_le_timestamp", [{ args: [(date$1), (timestamp$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    dateLeTimestamptz(...args) {
        return sqlFunction("date_le_timestamptz", [{ args: [(date$1), (timestamptz$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    dateLt(...args) {
        return sqlFunction("date_lt", [{ args: [(date$1), (date$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    dateLtTimestamp(...args) {
        return sqlFunction("date_lt_timestamp", [{ args: [(date$1), (timestamp$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    dateLtTimestamptz(...args) {
        return sqlFunction("date_lt_timestamptz", [{ args: [(date$1), (timestamptz$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    dateMi(...args) {
        return sqlFunction("date_mi", [{ args: [(date$1), (date$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    dateMiInterval(...args) {
        return sqlFunction("date_mi_interval", [{ args: [(date$1), (interval$1)], ret: (timestamp$1), isOperator: false }], [this, ...args]);
    }
    dateMii(...args) {
        return sqlFunction("date_mii", [{ args: [(date$1), (default_1$4)], ret: (date$1), isOperator: false }], [this, ...args]);
    }
    dateNe(...args) {
        return sqlFunction("date_ne", [{ args: [(date$1), (date$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    dateNeTimestamp(...args) {
        return sqlFunction("date_ne_timestamp", [{ args: [(date$1), (timestamp$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    dateNeTimestamptz(...args) {
        return sqlFunction("date_ne_timestamptz", [{ args: [(date$1), (timestamptz$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    datePlInterval(...args) {
        return sqlFunction("date_pl_interval", [{ args: [(date$1), (interval$1)], ret: (timestamp$1), isOperator: false }], [this, ...args]);
    }
    datePli(...args) {
        return sqlFunction("date_pli", [{ args: [(date$1), (default_1$4)], ret: (date$1), isOperator: false }], [this, ...args]);
    }
    dateSmaller(...args) {
        return sqlFunction("date_smaller", [{ args: [(date$1), (date$1)], ret: (date$1), isOperator: false }], [this, ...args]);
    }
    daterange(...args) {
        return sqlFunction("daterange", [{ args: [(date$1), (date$1)], ret: (daterange$1), isOperator: false }, { args: [(date$1), (date$1), (default_1$1)], ret: (daterange$1), isOperator: false }], [this, ...args]);
    }
    daterangeSubdiff(...args) {
        return sqlFunction("daterange_subdiff", [{ args: [(date$1), (date$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    datetimePl(...args) {
        return sqlFunction("datetime_pl", [{ args: [(date$1), (time$1)], ret: (timestamp$1), isOperator: false }], [this, ...args]);
    }
    datetimetzPl(...args) {
        return sqlFunction("datetimetz_pl", [{ args: [(date$1), (timetz$1)], ret: (timestamptz$1), isOperator: false }], [this, ...args]);
    }
    inRange(...args) {
        return sqlFunction("in_range", [{ args: [(date$1), (date$1), (interval$1), (default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    isfinite(...args) {
        return sqlFunction("isfinite", [{ args: [(date$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    max(...args) {
        return sqlFunction("max", [{ args: [(date$1)], ret: (date$1), isOperator: false }], [this, ...args]);
    }
    timestamp(...args) {
        return sqlFunction("timestamp", [{ args: [(date$1)], ret: (timestamp$1), isOperator: false }, { args: [(date$1), (time$1)], ret: (timestamp$1), isOperator: false }], [this, ...args]);
    }
    timestamptz(...args) {
        return sqlFunction("timestamptz", [{ args: [(date$1)], ret: (timestamptz$1), isOperator: false }, { args: [(date$1), (time$1)], ret: (timestamptz$1), isOperator: false }, { args: [(date$1), (timetz$1)], ret: (timestamptz$1), isOperator: false }], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [{ args: [(date$1), (date$1)], ret: (default_1$8), isOperator: true }, { args: [(date$1), (timestamp$1)], ret: (default_1$8), isOperator: true }, { args: [(date$1), (timestamptz$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">="](...args) {
        return sqlFunction(">=", [{ args: [(date$1), (date$1)], ret: (default_1$8), isOperator: true }, { args: [(date$1), (timestamp$1)], ret: (default_1$8), isOperator: true }, { args: [(date$1), (timestamptz$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">"](...args) {
        return sqlFunction(">", [{ args: [(date$1), (date$1)], ret: (default_1$8), isOperator: true }, { args: [(date$1), (timestamp$1)], ret: (default_1$8), isOperator: true }, { args: [(date$1), (timestamptz$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<="](...args) {
        return sqlFunction("<=", [{ args: [(date$1), (date$1)], ret: (default_1$8), isOperator: true }, { args: [(date$1), (timestamp$1)], ret: (default_1$8), isOperator: true }, { args: [(date$1), (timestamptz$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<"](...args) {
        return sqlFunction("<", [{ args: [(date$1), (date$1)], ret: (default_1$8), isOperator: true }, { args: [(date$1), (timestamp$1)], ret: (default_1$8), isOperator: true }, { args: [(date$1), (timestamptz$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["-"](...args) {
        return sqlFunction("-", [{ args: [(date$1), (date$1)], ret: (default_1$4), isOperator: true }, { args: [(date$1), (interval$1)], ret: (timestamp$1), isOperator: true }, { args: [(date$1), (default_1$4)], ret: (date$1), isOperator: true }], [this, ...args]);
    }
    ["<>"](...args) {
        return sqlFunction("<>", [{ args: [(date$1), (date$1)], ret: (default_1$8), isOperator: true }, { args: [(date$1), (timestamp$1)], ret: (default_1$8), isOperator: true }, { args: [(date$1), (timestamptz$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["+"](...args) {
        return sqlFunction("+", [{ args: [(date$1), (interval$1)], ret: (timestamp$1), isOperator: true }, { args: [(date$1), (default_1$4)], ret: (date$1), isOperator: true }, { args: [(date$1), (time$1)], ret: (timestamp$1), isOperator: true }, { args: [(date$1), (timetz$1)], ret: (timestamptz$1), isOperator: true }], [this, ...args]);
    }
}

class datemultirange$1 extends Any {
    static new(v) { return new datemultirange$1(v); }
    static parse(v) { return v; }
    static typeString() { return "datemultirange"; }
    asAggregate() {
        return undefined;
    }
}

class daterange$1 extends Any {
    static new(v) { return new daterange$1(v); }
    static parse(v) { return v; }
    static typeString() { return "daterange"; }
    asAggregate() {
        return undefined;
    }
    datemultirange(...args) {
        return sqlFunction("datemultirange", [{ args: [(daterange$1)], ret: (datemultirange$1), isOperator: false }], [this, ...args]);
    }
    daterangeCanonical(...args) {
        return sqlFunction("daterange_canonical", [{ args: [(daterange$1)], ret: (daterange$1), isOperator: false }], [this, ...args]);
    }
}

let default_1$7 = class default_1 extends Any {
    static new(v) { return new default_1$7(v); }
    static serializeParamTypes = undefined;
    static parse(v) { return typeMap["float4"].parse(v); }
    static typeString() { return "float4"; }
    asAggregate() {
        return undefined;
    }
    abs(...args) {
        return sqlFunction("abs", [{ args: [(default_1$7)], ret: (default_1$7), isOperator: false }], [this, ...args]);
    }
    avg(...args) {
        return sqlFunction("avg", [{ args: [(default_1$7)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    btfloat48Cmp(...args) {
        return sqlFunction("btfloat48cmp", [{ args: [(default_1$7), (default_1$6)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    btfloat4Cmp(...args) {
        return sqlFunction("btfloat4cmp", [{ args: [(default_1$7), (default_1$7)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    float48Div(...args) {
        return sqlFunction("float48div", [{ args: [(default_1$7), (default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    float48Eq(...args) {
        return sqlFunction("float48eq", [{ args: [(default_1$7), (default_1$6)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    float48Ge(...args) {
        return sqlFunction("float48ge", [{ args: [(default_1$7), (default_1$6)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    float48Gt(...args) {
        return sqlFunction("float48gt", [{ args: [(default_1$7), (default_1$6)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    float48Le(...args) {
        return sqlFunction("float48le", [{ args: [(default_1$7), (default_1$6)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    float48Lt(...args) {
        return sqlFunction("float48lt", [{ args: [(default_1$7), (default_1$6)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    float48Mi(...args) {
        return sqlFunction("float48mi", [{ args: [(default_1$7), (default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    float48Mul(...args) {
        return sqlFunction("float48mul", [{ args: [(default_1$7), (default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    float48Ne(...args) {
        return sqlFunction("float48ne", [{ args: [(default_1$7), (default_1$6)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    float48Pl(...args) {
        return sqlFunction("float48pl", [{ args: [(default_1$7), (default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    float4Abs(...args) {
        return sqlFunction("float4abs", [{ args: [(default_1$7)], ret: (default_1$7), isOperator: false }], [this, ...args]);
    }
    float4Div(...args) {
        return sqlFunction("float4div", [{ args: [(default_1$7), (default_1$7)], ret: (default_1$7), isOperator: false }], [this, ...args]);
    }
    float4Eq(...args) {
        return sqlFunction("float4eq", [{ args: [(default_1$7), (default_1$7)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    float4Ge(...args) {
        return sqlFunction("float4ge", [{ args: [(default_1$7), (default_1$7)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    float4Gt(...args) {
        return sqlFunction("float4gt", [{ args: [(default_1$7), (default_1$7)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    float4Larger(...args) {
        return sqlFunction("float4larger", [{ args: [(default_1$7), (default_1$7)], ret: (default_1$7), isOperator: false }], [this, ...args]);
    }
    float4Le(...args) {
        return sqlFunction("float4le", [{ args: [(default_1$7), (default_1$7)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    float4Lt(...args) {
        return sqlFunction("float4lt", [{ args: [(default_1$7), (default_1$7)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    float4Mi(...args) {
        return sqlFunction("float4mi", [{ args: [(default_1$7), (default_1$7)], ret: (default_1$7), isOperator: false }], [this, ...args]);
    }
    float4Mul(...args) {
        return sqlFunction("float4mul", [{ args: [(default_1$7), (default_1$7)], ret: (default_1$7), isOperator: false }], [this, ...args]);
    }
    float4Ne(...args) {
        return sqlFunction("float4ne", [{ args: [(default_1$7), (default_1$7)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    float4Pl(...args) {
        return sqlFunction("float4pl", [{ args: [(default_1$7), (default_1$7)], ret: (default_1$7), isOperator: false }], [this, ...args]);
    }
    float4Smaller(...args) {
        return sqlFunction("float4smaller", [{ args: [(default_1$7), (default_1$7)], ret: (default_1$7), isOperator: false }], [this, ...args]);
    }
    float4Um(...args) {
        return sqlFunction("float4um", [{ args: [(default_1$7)], ret: (default_1$7), isOperator: false }], [this, ...args]);
    }
    float4Up(...args) {
        return sqlFunction("float4up", [{ args: [(default_1$7)], ret: (default_1$7), isOperator: false }], [this, ...args]);
    }
    float8(...args) {
        return sqlFunction("float8", [{ args: [(default_1$7)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    flt4MulCash(...args) {
        return sqlFunction("flt4_mul_cash", [{ args: [(default_1$7), (money$1)], ret: (money$1), isOperator: false }], [this, ...args]);
    }
    hashfloat4(...args) {
        return sqlFunction("hashfloat4", [{ args: [(default_1$7)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    hashfloat4Extended(...args) {
        return sqlFunction("hashfloat4extended", [{ args: [(default_1$7), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    inRange(...args) {
        return sqlFunction("in_range", [{ args: [(default_1$7), (default_1$7), (default_1$6), (default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int2(...args) {
        return sqlFunction("int2", [{ args: [(default_1$7)], ret: (default_1$5), isOperator: false }], [this, ...args]);
    }
    int4(...args) {
        return sqlFunction("int4", [{ args: [(default_1$7)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    int8(...args) {
        return sqlFunction("int8", [{ args: [(default_1$7)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    max(...args) {
        return sqlFunction("max", [{ args: [(default_1$7)], ret: (default_1$7), isOperator: false }], [this, ...args]);
    }
    numeric(...args) {
        return sqlFunction("numeric", [{ args: [(default_1$7)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    stddev(...args) {
        return sqlFunction("stddev", [{ args: [(default_1$7)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    stddevPop(...args) {
        return sqlFunction("stddev_pop", [{ args: [(default_1$7)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    stddevSamp(...args) {
        return sqlFunction("stddev_samp", [{ args: [(default_1$7)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    sum(...args) {
        return sqlFunction("sum", [{ args: [(default_1$7)], ret: (default_1$7), isOperator: false }], [this, ...args]);
    }
    toChar(...args) {
        return sqlFunction("to_char", [{ args: [(default_1$7), (default_1$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    varPop(...args) {
        return sqlFunction("var_pop", [{ args: [(default_1$7)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    varSamp(...args) {
        return sqlFunction("var_samp", [{ args: [(default_1$7)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    variance(...args) {
        return sqlFunction("variance", [{ args: [(default_1$7)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    ["/"](...args) {
        return sqlFunction("/", [{ args: [(default_1$7), (default_1$6)], ret: (default_1$6), isOperator: true }, { args: [(default_1$7), (default_1$7)], ret: (default_1$7), isOperator: true }], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [{ args: [(default_1$7), (default_1$6)], ret: (default_1$8), isOperator: true }, { args: [(default_1$7), (default_1$7)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">="](...args) {
        return sqlFunction(">=", [{ args: [(default_1$7), (default_1$6)], ret: (default_1$8), isOperator: true }, { args: [(default_1$7), (default_1$7)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">"](...args) {
        return sqlFunction(">", [{ args: [(default_1$7), (default_1$6)], ret: (default_1$8), isOperator: true }, { args: [(default_1$7), (default_1$7)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<="](...args) {
        return sqlFunction("<=", [{ args: [(default_1$7), (default_1$6)], ret: (default_1$8), isOperator: true }, { args: [(default_1$7), (default_1$7)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<"](...args) {
        return sqlFunction("<", [{ args: [(default_1$7), (default_1$6)], ret: (default_1$8), isOperator: true }, { args: [(default_1$7), (default_1$7)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["-"](...args) {
        return sqlFunction("-", [{ args: [(default_1$7), (default_1$6)], ret: (default_1$6), isOperator: true }, { args: [(default_1$7), (default_1$7)], ret: (default_1$7), isOperator: true }], [this, ...args]);
    }
    ["*"](...args) {
        return sqlFunction("*", [{ args: [(default_1$7), (default_1$6)], ret: (default_1$6), isOperator: true }, { args: [(default_1$7), (default_1$7)], ret: (default_1$7), isOperator: true }, { args: [(default_1$7), (money$1)], ret: (money$1), isOperator: true }], [this, ...args]);
    }
    ["<>"](...args) {
        return sqlFunction("<>", [{ args: [(default_1$7), (default_1$6)], ret: (default_1$8), isOperator: true }, { args: [(default_1$7), (default_1$7)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["+"](...args) {
        return sqlFunction("+", [{ args: [(default_1$7), (default_1$6)], ret: (default_1$6), isOperator: true }, { args: [(default_1$7), (default_1$7)], ret: (default_1$7), isOperator: true }], [this, ...args]);
    }
};

let default_1$6 = class default_1 extends Any {
    static new(v) { return new default_1$6(v); }
    static serializeParamTypes = undefined;
    static parse(v) { return typeMap["float8"].parse(v); }
    static typeString() { return "float8"; }
    asAggregate() {
        return undefined;
    }
    abs(...args) {
        return sqlFunction("abs", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    acos(...args) {
        return sqlFunction("acos", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    acosd(...args) {
        return sqlFunction("acosd", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    acosh(...args) {
        return sqlFunction("acosh", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    asind(...args) {
        return sqlFunction("asind", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    asinh(...args) {
        return sqlFunction("asinh", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    atan(...args) {
        return sqlFunction("atan", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    atan2(...args) {
        return sqlFunction("atan2", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    atan2D(...args) {
        return sqlFunction("atan2d", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    atand(...args) {
        return sqlFunction("atand", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    atanh(...args) {
        return sqlFunction("atanh", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    avg(...args) {
        return sqlFunction("avg", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    btfloat84Cmp(...args) {
        return sqlFunction("btfloat84cmp", [{ args: [(default_1$6), (default_1$7)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    btfloat8Cmp(...args) {
        return sqlFunction("btfloat8cmp", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    cbrt(...args) {
        return sqlFunction("cbrt", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    ceil(...args) {
        return sqlFunction("ceil", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    ceiling(...args) {
        return sqlFunction("ceiling", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    corr(...args) {
        return sqlFunction("corr", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    cos(...args) {
        return sqlFunction("cos", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    cosd(...args) {
        return sqlFunction("cosd", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    cosh(...args) {
        return sqlFunction("cosh", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    cot(...args) {
        return sqlFunction("cot", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    cotd(...args) {
        return sqlFunction("cotd", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    covarPop(...args) {
        return sqlFunction("covar_pop", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    covarSamp(...args) {
        return sqlFunction("covar_samp", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    dcbrt(...args) {
        return sqlFunction("dcbrt", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    degrees(...args) {
        return sqlFunction("degrees", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    dexp(...args) {
        return sqlFunction("dexp", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    dlog1(...args) {
        return sqlFunction("dlog1", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    dlog10(...args) {
        return sqlFunction("dlog10", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    dpow(...args) {
        return sqlFunction("dpow", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    dround(...args) {
        return sqlFunction("dround", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    dsqrt(...args) {
        return sqlFunction("dsqrt", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    dtrunc(...args) {
        return sqlFunction("dtrunc", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    erf(...args) {
        return sqlFunction("erf", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    erfc(...args) {
        return sqlFunction("erfc", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    exp(...args) {
        return sqlFunction("exp", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    float4(...args) {
        return sqlFunction("float4", [{ args: [(default_1$6)], ret: (default_1$7), isOperator: false }], [this, ...args]);
    }
    float84Div(...args) {
        return sqlFunction("float84div", [{ args: [(default_1$6), (default_1$7)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    float84Eq(...args) {
        return sqlFunction("float84eq", [{ args: [(default_1$6), (default_1$7)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    float84Ge(...args) {
        return sqlFunction("float84ge", [{ args: [(default_1$6), (default_1$7)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    float84Gt(...args) {
        return sqlFunction("float84gt", [{ args: [(default_1$6), (default_1$7)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    float84Le(...args) {
        return sqlFunction("float84le", [{ args: [(default_1$6), (default_1$7)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    float84Lt(...args) {
        return sqlFunction("float84lt", [{ args: [(default_1$6), (default_1$7)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    float84Mi(...args) {
        return sqlFunction("float84mi", [{ args: [(default_1$6), (default_1$7)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    float84Mul(...args) {
        return sqlFunction("float84mul", [{ args: [(default_1$6), (default_1$7)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    float84Ne(...args) {
        return sqlFunction("float84ne", [{ args: [(default_1$6), (default_1$7)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    float84Pl(...args) {
        return sqlFunction("float84pl", [{ args: [(default_1$6), (default_1$7)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    float8Abs(...args) {
        return sqlFunction("float8abs", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    float8Div(...args) {
        return sqlFunction("float8div", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    float8Eq(...args) {
        return sqlFunction("float8eq", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    float8Ge(...args) {
        return sqlFunction("float8ge", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    float8Gt(...args) {
        return sqlFunction("float8gt", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    float8Larger(...args) {
        return sqlFunction("float8larger", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    float8Le(...args) {
        return sqlFunction("float8le", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    float8Lt(...args) {
        return sqlFunction("float8lt", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    float8Mi(...args) {
        return sqlFunction("float8mi", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    float8Mul(...args) {
        return sqlFunction("float8mul", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    float8Ne(...args) {
        return sqlFunction("float8ne", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    float8Pl(...args) {
        return sqlFunction("float8pl", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    float8Smaller(...args) {
        return sqlFunction("float8smaller", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    float8Um(...args) {
        return sqlFunction("float8um", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    float8Up(...args) {
        return sqlFunction("float8up", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    floor(...args) {
        return sqlFunction("floor", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    flt8MulCash(...args) {
        return sqlFunction("flt8_mul_cash", [{ args: [(default_1$6), (money$1)], ret: (money$1), isOperator: false }], [this, ...args]);
    }
    hashfloat8(...args) {
        return sqlFunction("hashfloat8", [{ args: [(default_1$6)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    hashfloat8Extended(...args) {
        return sqlFunction("hashfloat8extended", [{ args: [(default_1$6), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    inRange(...args) {
        return sqlFunction("in_range", [{ args: [(default_1$6), (default_1$6), (default_1$6), (default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int2(...args) {
        return sqlFunction("int2", [{ args: [(default_1$6)], ret: (default_1$5), isOperator: false }], [this, ...args]);
    }
    int4(...args) {
        return sqlFunction("int4", [{ args: [(default_1$6)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    int8(...args) {
        return sqlFunction("int8", [{ args: [(default_1$6)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    ln(...args) {
        return sqlFunction("ln", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    log(...args) {
        return sqlFunction("log", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    log10(...args) {
        return sqlFunction("log10", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    max(...args) {
        return sqlFunction("max", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    mulDInterval(...args) {
        return sqlFunction("mul_d_interval", [{ args: [(default_1$6), (interval$1)], ret: (interval$1), isOperator: false }], [this, ...args]);
    }
    numeric(...args) {
        return sqlFunction("numeric", [{ args: [(default_1$6)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    percentileCont(...args) {
        return sqlFunction("percentile_cont", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }, { args: [(default_1$6), (interval$1)], ret: (interval$1), isOperator: false }], [this, ...args]);
    }
    percentileDisc(...args) {
        return sqlFunction("percentile_disc", [({ T }) => ({ args: [(default_1$6), T], ret: T, isOperator: false })], [this, ...args]);
    }
    pgSleep(...args) {
        return sqlFunction("pg_sleep", [{ args: [(default_1$6)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    point(...args) {
        return sqlFunction("point", [{ args: [(default_1$6), (default_1$6)], ret: (point$1), isOperator: false }], [this, ...args]);
    }
    pow(...args) {
        return sqlFunction("pow", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    power(...args) {
        return sqlFunction("power", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    radians(...args) {
        return sqlFunction("radians", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    randomNormal(...args) {
        return sqlFunction("random_normal", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    regrAvgx(...args) {
        return sqlFunction("regr_avgx", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    regrAvgy(...args) {
        return sqlFunction("regr_avgy", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    regrCount(...args) {
        return sqlFunction("regr_count", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    regrIntercept(...args) {
        return sqlFunction("regr_intercept", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    regrR2(...args) {
        return sqlFunction("regr_r2", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    regrSlope(...args) {
        return sqlFunction("regr_slope", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    regrSxx(...args) {
        return sqlFunction("regr_sxx", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    regrSxy(...args) {
        return sqlFunction("regr_sxy", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    regrSyy(...args) {
        return sqlFunction("regr_syy", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    round(...args) {
        return sqlFunction("round", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    setseed(...args) {
        return sqlFunction("setseed", [{ args: [(default_1$6)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    sign(...args) {
        return sqlFunction("sign", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    sind(...args) {
        return sqlFunction("sind", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    sinh(...args) {
        return sqlFunction("sinh", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    sqrt(...args) {
        return sqlFunction("sqrt", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    stddev(...args) {
        return sqlFunction("stddev", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    stddevPop(...args) {
        return sqlFunction("stddev_pop", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    stddevSamp(...args) {
        return sqlFunction("stddev_samp", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    sum(...args) {
        return sqlFunction("sum", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    tan(...args) {
        return sqlFunction("tan", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    tand(...args) {
        return sqlFunction("tand", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    tanh(...args) {
        return sqlFunction("tanh", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    toChar(...args) {
        return sqlFunction("to_char", [{ args: [(default_1$6), (default_1$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    toTimestamp(...args) {
        return sqlFunction("to_timestamp", [{ args: [(default_1$6)], ret: (timestamptz$1), isOperator: false }], [this, ...args]);
    }
    trunc(...args) {
        return sqlFunction("trunc", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    varPop(...args) {
        return sqlFunction("var_pop", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    varSamp(...args) {
        return sqlFunction("var_samp", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    variance(...args) {
        return sqlFunction("variance", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    ["^"](...args) {
        return sqlFunction("^", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: true }], [this, ...args]);
    }
    ["/"](...args) {
        return sqlFunction("/", [{ args: [(default_1$6), (default_1$7)], ret: (default_1$6), isOperator: true }, { args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: true }], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [{ args: [(default_1$6), (default_1$7)], ret: (default_1$8), isOperator: true }, { args: [(default_1$6), (default_1$6)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">="](...args) {
        return sqlFunction(">=", [{ args: [(default_1$6), (default_1$7)], ret: (default_1$8), isOperator: true }, { args: [(default_1$6), (default_1$6)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">"](...args) {
        return sqlFunction(">", [{ args: [(default_1$6), (default_1$7)], ret: (default_1$8), isOperator: true }, { args: [(default_1$6), (default_1$6)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<="](...args) {
        return sqlFunction("<=", [{ args: [(default_1$6), (default_1$7)], ret: (default_1$8), isOperator: true }, { args: [(default_1$6), (default_1$6)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<"](...args) {
        return sqlFunction("<", [{ args: [(default_1$6), (default_1$7)], ret: (default_1$8), isOperator: true }, { args: [(default_1$6), (default_1$6)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["-"](...args) {
        return sqlFunction("-", [{ args: [(default_1$6), (default_1$7)], ret: (default_1$6), isOperator: true }, { args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: true }], [this, ...args]);
    }
    ["*"](...args) {
        return sqlFunction("*", [{ args: [(default_1$6), (default_1$7)], ret: (default_1$6), isOperator: true }, { args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: true }, { args: [(default_1$6), (money$1)], ret: (money$1), isOperator: true }, { args: [(default_1$6), (interval$1)], ret: (interval$1), isOperator: true }], [this, ...args]);
    }
    ["<>"](...args) {
        return sqlFunction("<>", [{ args: [(default_1$6), (default_1$7)], ret: (default_1$8), isOperator: true }, { args: [(default_1$6), (default_1$6)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["+"](...args) {
        return sqlFunction("+", [{ args: [(default_1$6), (default_1$7)], ret: (default_1$6), isOperator: true }, { args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: true }], [this, ...args]);
    }
};

class inet extends Any {
    static new(v) { return new inet(v); }
    static parse(v) { return v; }
    static typeString() { return "inet"; }
    asAggregate() {
        return undefined;
    }
    abbrev(...args) {
        return sqlFunction("abbrev", [{ args: [(inet)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    broadcast(...args) {
        return sqlFunction("broadcast", [{ args: [(inet)], ret: (inet), isOperator: false }], [this, ...args]);
    }
    cidr(...args) {
        return sqlFunction("cidr", [{ args: [(inet)], ret: (cidr$1), isOperator: false }], [this, ...args]);
    }
    family(...args) {
        return sqlFunction("family", [{ args: [(inet)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    hashinet(...args) {
        return sqlFunction("hashinet", [{ args: [(inet)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    hashinetextended(...args) {
        return sqlFunction("hashinetextended", [{ args: [(inet), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    host(...args) {
        return sqlFunction("host", [{ args: [(inet)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    hostmask(...args) {
        return sqlFunction("hostmask", [{ args: [(inet)], ret: (inet), isOperator: false }], [this, ...args]);
    }
    inetMerge(...args) {
        return sqlFunction("inet_merge", [{ args: [(inet), (inet)], ret: (cidr$1), isOperator: false }], [this, ...args]);
    }
    inetSameFamily(...args) {
        return sqlFunction("inet_same_family", [{ args: [(inet), (inet)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    inetand(...args) {
        return sqlFunction("inetand", [{ args: [(inet), (inet)], ret: (inet), isOperator: false }], [this, ...args]);
    }
    inetmi(...args) {
        return sqlFunction("inetmi", [{ args: [(inet), (inet)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    inetmiInt8(...args) {
        return sqlFunction("inetmi_int8", [{ args: [(inet), (default_1$3)], ret: (inet), isOperator: false }], [this, ...args]);
    }
    inetnot(...args) {
        return sqlFunction("inetnot", [{ args: [(inet)], ret: (inet), isOperator: false }], [this, ...args]);
    }
    inetor(...args) {
        return sqlFunction("inetor", [{ args: [(inet), (inet)], ret: (inet), isOperator: false }], [this, ...args]);
    }
    inetpl(...args) {
        return sqlFunction("inetpl", [{ args: [(inet), (default_1$3)], ret: (inet), isOperator: false }], [this, ...args]);
    }
    masklen(...args) {
        return sqlFunction("masklen", [{ args: [(inet)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    max(...args) {
        return sqlFunction("max", [{ args: [(inet)], ret: (inet), isOperator: false }], [this, ...args]);
    }
    netmask(...args) {
        return sqlFunction("netmask", [{ args: [(inet)], ret: (inet), isOperator: false }], [this, ...args]);
    }
    network(...args) {
        return sqlFunction("network", [{ args: [(inet)], ret: (cidr$1), isOperator: false }], [this, ...args]);
    }
    networkCmp(...args) {
        return sqlFunction("network_cmp", [{ args: [(inet), (inet)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    networkEq(...args) {
        return sqlFunction("network_eq", [{ args: [(inet), (inet)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    networkGe(...args) {
        return sqlFunction("network_ge", [{ args: [(inet), (inet)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    networkGt(...args) {
        return sqlFunction("network_gt", [{ args: [(inet), (inet)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    networkLarger(...args) {
        return sqlFunction("network_larger", [{ args: [(inet), (inet)], ret: (inet), isOperator: false }], [this, ...args]);
    }
    networkLe(...args) {
        return sqlFunction("network_le", [{ args: [(inet), (inet)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    networkLt(...args) {
        return sqlFunction("network_lt", [{ args: [(inet), (inet)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    networkNe(...args) {
        return sqlFunction("network_ne", [{ args: [(inet), (inet)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    networkOverlap(...args) {
        return sqlFunction("network_overlap", [{ args: [(inet), (inet)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    networkSmaller(...args) {
        return sqlFunction("network_smaller", [{ args: [(inet), (inet)], ret: (inet), isOperator: false }], [this, ...args]);
    }
    networkSub(...args) {
        return sqlFunction("network_sub", [{ args: [(inet), (inet)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    networkSubeq(...args) {
        return sqlFunction("network_subeq", [{ args: [(inet), (inet)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    networkSup(...args) {
        return sqlFunction("network_sup", [{ args: [(inet), (inet)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    networkSupeq(...args) {
        return sqlFunction("network_supeq", [{ args: [(inet), (inet)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    setMasklen(...args) {
        return sqlFunction("set_masklen", [{ args: [(inet), (default_1$4)], ret: (inet), isOperator: false }], [this, ...args]);
    }
    text(...args) {
        return sqlFunction("text", [{ args: [(inet)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    ["&"](...args) {
        return sqlFunction("&", [{ args: [(inet), (inet)], ret: (inet), isOperator: true }], [this, ...args]);
    }
    ["-"](...args) {
        return sqlFunction("-", [{ args: [(inet), (inet)], ret: (default_1$3), isOperator: true }, { args: [(inet), (default_1$3)], ret: (inet), isOperator: true }], [this, ...args]);
    }
    ["|"](...args) {
        return sqlFunction("|", [{ args: [(inet), (inet)], ret: (inet), isOperator: true }], [this, ...args]);
    }
    ["+"](...args) {
        return sqlFunction("+", [{ args: [(inet), (default_1$3)], ret: (inet), isOperator: true }], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [{ args: [(inet), (inet)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">="](...args) {
        return sqlFunction(">=", [{ args: [(inet), (inet)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">"](...args) {
        return sqlFunction(">", [{ args: [(inet), (inet)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<="](...args) {
        return sqlFunction("<=", [{ args: [(inet), (inet)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<"](...args) {
        return sqlFunction("<", [{ args: [(inet), (inet)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<>"](...args) {
        return sqlFunction("<>", [{ args: [(inet), (inet)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["&&"](...args) {
        return sqlFunction("&&", [{ args: [(inet), (inet)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<<"](...args) {
        return sqlFunction("<<", [{ args: [(inet), (inet)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<<="](...args) {
        return sqlFunction("<<=", [{ args: [(inet), (inet)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">>"](...args) {
        return sqlFunction(">>", [{ args: [(inet), (inet)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">>="](...args) {
        return sqlFunction(">>=", [{ args: [(inet), (inet)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
}

let default_1$5 = class default_1 extends Any {
    static new(v) { return new default_1$5(v); }
    static serializeParamTypes = undefined;
    static parse(v) { return typeMap["int2"].parse(v); }
    static typeString() { return "int2"; }
    asAggregate() {
        return undefined;
    }
    abs(...args) {
        return sqlFunction("abs", [{ args: [(default_1$5)], ret: (default_1$5), isOperator: false }], [this, ...args]);
    }
    avg(...args) {
        return sqlFunction("avg", [{ args: [(default_1$5)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    bitAnd(...args) {
        return sqlFunction("bit_and", [{ args: [(default_1$5)], ret: (default_1$5), isOperator: false }], [this, ...args]);
    }
    bitOr(...args) {
        return sqlFunction("bit_or", [{ args: [(default_1$5)], ret: (default_1$5), isOperator: false }], [this, ...args]);
    }
    bitXor(...args) {
        return sqlFunction("bit_xor", [{ args: [(default_1$5)], ret: (default_1$5), isOperator: false }], [this, ...args]);
    }
    btint24Cmp(...args) {
        return sqlFunction("btint24cmp", [{ args: [(default_1$5), (default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    btint28Cmp(...args) {
        return sqlFunction("btint28cmp", [{ args: [(default_1$5), (default_1$3)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    btint2Cmp(...args) {
        return sqlFunction("btint2cmp", [{ args: [(default_1$5), (default_1$5)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    float4(...args) {
        return sqlFunction("float4", [{ args: [(default_1$5)], ret: (default_1$7), isOperator: false }], [this, ...args]);
    }
    float8(...args) {
        return sqlFunction("float8", [{ args: [(default_1$5)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    hashint2(...args) {
        return sqlFunction("hashint2", [{ args: [(default_1$5)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    hashint2Extended(...args) {
        return sqlFunction("hashint2extended", [{ args: [(default_1$5), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    inRange(...args) {
        return sqlFunction("in_range", [{ args: [(default_1$5), (default_1$5), (default_1$5), (default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }, { args: [(default_1$5), (default_1$5), (default_1$4), (default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }, { args: [(default_1$5), (default_1$5), (default_1$3), (default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int24Div(...args) {
        return sqlFunction("int24div", [{ args: [(default_1$5), (default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    int24Eq(...args) {
        return sqlFunction("int24eq", [{ args: [(default_1$5), (default_1$4)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int24Ge(...args) {
        return sqlFunction("int24ge", [{ args: [(default_1$5), (default_1$4)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int24Gt(...args) {
        return sqlFunction("int24gt", [{ args: [(default_1$5), (default_1$4)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int24Le(...args) {
        return sqlFunction("int24le", [{ args: [(default_1$5), (default_1$4)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int24Lt(...args) {
        return sqlFunction("int24lt", [{ args: [(default_1$5), (default_1$4)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int24Mi(...args) {
        return sqlFunction("int24mi", [{ args: [(default_1$5), (default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    int24Mul(...args) {
        return sqlFunction("int24mul", [{ args: [(default_1$5), (default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    int24Ne(...args) {
        return sqlFunction("int24ne", [{ args: [(default_1$5), (default_1$4)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int24Pl(...args) {
        return sqlFunction("int24pl", [{ args: [(default_1$5), (default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    int28Div(...args) {
        return sqlFunction("int28div", [{ args: [(default_1$5), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    int28Eq(...args) {
        return sqlFunction("int28eq", [{ args: [(default_1$5), (default_1$3)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int28Ge(...args) {
        return sqlFunction("int28ge", [{ args: [(default_1$5), (default_1$3)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int28Gt(...args) {
        return sqlFunction("int28gt", [{ args: [(default_1$5), (default_1$3)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int28Le(...args) {
        return sqlFunction("int28le", [{ args: [(default_1$5), (default_1$3)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int28Lt(...args) {
        return sqlFunction("int28lt", [{ args: [(default_1$5), (default_1$3)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int28Mi(...args) {
        return sqlFunction("int28mi", [{ args: [(default_1$5), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    int28Mul(...args) {
        return sqlFunction("int28mul", [{ args: [(default_1$5), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    int28Ne(...args) {
        return sqlFunction("int28ne", [{ args: [(default_1$5), (default_1$3)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int28Pl(...args) {
        return sqlFunction("int28pl", [{ args: [(default_1$5), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    int2MulCash(...args) {
        return sqlFunction("int2_mul_cash", [{ args: [(default_1$5), (money$1)], ret: (money$1), isOperator: false }], [this, ...args]);
    }
    int2Abs(...args) {
        return sqlFunction("int2abs", [{ args: [(default_1$5)], ret: (default_1$5), isOperator: false }], [this, ...args]);
    }
    int2And(...args) {
        return sqlFunction("int2and", [{ args: [(default_1$5), (default_1$5)], ret: (default_1$5), isOperator: false }], [this, ...args]);
    }
    int2Div(...args) {
        return sqlFunction("int2div", [{ args: [(default_1$5), (default_1$5)], ret: (default_1$5), isOperator: false }], [this, ...args]);
    }
    int2Eq(...args) {
        return sqlFunction("int2eq", [{ args: [(default_1$5), (default_1$5)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int2Ge(...args) {
        return sqlFunction("int2ge", [{ args: [(default_1$5), (default_1$5)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int2Gt(...args) {
        return sqlFunction("int2gt", [{ args: [(default_1$5), (default_1$5)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int2Larger(...args) {
        return sqlFunction("int2larger", [{ args: [(default_1$5), (default_1$5)], ret: (default_1$5), isOperator: false }], [this, ...args]);
    }
    int2Le(...args) {
        return sqlFunction("int2le", [{ args: [(default_1$5), (default_1$5)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int2Lt(...args) {
        return sqlFunction("int2lt", [{ args: [(default_1$5), (default_1$5)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int2Mi(...args) {
        return sqlFunction("int2mi", [{ args: [(default_1$5), (default_1$5)], ret: (default_1$5), isOperator: false }], [this, ...args]);
    }
    int2Mod(...args) {
        return sqlFunction("int2mod", [{ args: [(default_1$5), (default_1$5)], ret: (default_1$5), isOperator: false }], [this, ...args]);
    }
    int2Mul(...args) {
        return sqlFunction("int2mul", [{ args: [(default_1$5), (default_1$5)], ret: (default_1$5), isOperator: false }], [this, ...args]);
    }
    int2Ne(...args) {
        return sqlFunction("int2ne", [{ args: [(default_1$5), (default_1$5)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int2Not(...args) {
        return sqlFunction("int2not", [{ args: [(default_1$5)], ret: (default_1$5), isOperator: false }], [this, ...args]);
    }
    int2Or(...args) {
        return sqlFunction("int2or", [{ args: [(default_1$5), (default_1$5)], ret: (default_1$5), isOperator: false }], [this, ...args]);
    }
    int2Pl(...args) {
        return sqlFunction("int2pl", [{ args: [(default_1$5), (default_1$5)], ret: (default_1$5), isOperator: false }], [this, ...args]);
    }
    int2Shl(...args) {
        return sqlFunction("int2shl", [{ args: [(default_1$5), (default_1$4)], ret: (default_1$5), isOperator: false }], [this, ...args]);
    }
    int2Shr(...args) {
        return sqlFunction("int2shr", [{ args: [(default_1$5), (default_1$4)], ret: (default_1$5), isOperator: false }], [this, ...args]);
    }
    int2Smaller(...args) {
        return sqlFunction("int2smaller", [{ args: [(default_1$5), (default_1$5)], ret: (default_1$5), isOperator: false }], [this, ...args]);
    }
    int2Um(...args) {
        return sqlFunction("int2um", [{ args: [(default_1$5)], ret: (default_1$5), isOperator: false }], [this, ...args]);
    }
    int2Up(...args) {
        return sqlFunction("int2up", [{ args: [(default_1$5)], ret: (default_1$5), isOperator: false }], [this, ...args]);
    }
    int2Xor(...args) {
        return sqlFunction("int2xor", [{ args: [(default_1$5), (default_1$5)], ret: (default_1$5), isOperator: false }], [this, ...args]);
    }
    int4(...args) {
        return sqlFunction("int4", [{ args: [(default_1$5)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    int8(...args) {
        return sqlFunction("int8", [{ args: [(default_1$5)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    max(...args) {
        return sqlFunction("max", [{ args: [(default_1$5)], ret: (default_1$5), isOperator: false }], [this, ...args]);
    }
    mod(...args) {
        return sqlFunction("mod", [{ args: [(default_1$5), (default_1$5)], ret: (default_1$5), isOperator: false }], [this, ...args]);
    }
    numeric(...args) {
        return sqlFunction("numeric", [{ args: [(default_1$5)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    stddev(...args) {
        return sqlFunction("stddev", [{ args: [(default_1$5)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    stddevPop(...args) {
        return sqlFunction("stddev_pop", [{ args: [(default_1$5)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    stddevSamp(...args) {
        return sqlFunction("stddev_samp", [{ args: [(default_1$5)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    sum(...args) {
        return sqlFunction("sum", [{ args: [(default_1$5)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    varPop(...args) {
        return sqlFunction("var_pop", [{ args: [(default_1$5)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    varSamp(...args) {
        return sqlFunction("var_samp", [{ args: [(default_1$5)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    variance(...args) {
        return sqlFunction("variance", [{ args: [(default_1$5)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    ["/"](...args) {
        return sqlFunction("/", [{ args: [(default_1$5), (default_1$4)], ret: (default_1$4), isOperator: true }, { args: [(default_1$5), (default_1$3)], ret: (default_1$3), isOperator: true }, { args: [(default_1$5), (default_1$5)], ret: (default_1$5), isOperator: true }], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [{ args: [(default_1$5), (default_1$4)], ret: (default_1$8), isOperator: true }, { args: [(default_1$5), (default_1$3)], ret: (default_1$8), isOperator: true }, { args: [(default_1$5), (default_1$5)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">="](...args) {
        return sqlFunction(">=", [{ args: [(default_1$5), (default_1$4)], ret: (default_1$8), isOperator: true }, { args: [(default_1$5), (default_1$3)], ret: (default_1$8), isOperator: true }, { args: [(default_1$5), (default_1$5)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">"](...args) {
        return sqlFunction(">", [{ args: [(default_1$5), (default_1$4)], ret: (default_1$8), isOperator: true }, { args: [(default_1$5), (default_1$3)], ret: (default_1$8), isOperator: true }, { args: [(default_1$5), (default_1$5)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<="](...args) {
        return sqlFunction("<=", [{ args: [(default_1$5), (default_1$4)], ret: (default_1$8), isOperator: true }, { args: [(default_1$5), (default_1$3)], ret: (default_1$8), isOperator: true }, { args: [(default_1$5), (default_1$5)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<"](...args) {
        return sqlFunction("<", [{ args: [(default_1$5), (default_1$4)], ret: (default_1$8), isOperator: true }, { args: [(default_1$5), (default_1$3)], ret: (default_1$8), isOperator: true }, { args: [(default_1$5), (default_1$5)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["-"](...args) {
        return sqlFunction("-", [{ args: [(default_1$5), (default_1$4)], ret: (default_1$4), isOperator: true }, { args: [(default_1$5), (default_1$3)], ret: (default_1$3), isOperator: true }, { args: [(default_1$5), (default_1$5)], ret: (default_1$5), isOperator: true }], [this, ...args]);
    }
    ["*"](...args) {
        return sqlFunction("*", [{ args: [(default_1$5), (default_1$4)], ret: (default_1$4), isOperator: true }, { args: [(default_1$5), (default_1$3)], ret: (default_1$3), isOperator: true }, { args: [(default_1$5), (money$1)], ret: (money$1), isOperator: true }, { args: [(default_1$5), (default_1$5)], ret: (default_1$5), isOperator: true }], [this, ...args]);
    }
    ["<>"](...args) {
        return sqlFunction("<>", [{ args: [(default_1$5), (default_1$4)], ret: (default_1$8), isOperator: true }, { args: [(default_1$5), (default_1$3)], ret: (default_1$8), isOperator: true }, { args: [(default_1$5), (default_1$5)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["+"](...args) {
        return sqlFunction("+", [{ args: [(default_1$5), (default_1$4)], ret: (default_1$4), isOperator: true }, { args: [(default_1$5), (default_1$3)], ret: (default_1$3), isOperator: true }, { args: [(default_1$5), (default_1$5)], ret: (default_1$5), isOperator: true }], [this, ...args]);
    }
    ["&"](...args) {
        return sqlFunction("&", [{ args: [(default_1$5), (default_1$5)], ret: (default_1$5), isOperator: true }], [this, ...args]);
    }
    ["%"](...args) {
        return sqlFunction("%", [{ args: [(default_1$5), (default_1$5)], ret: (default_1$5), isOperator: true }], [this, ...args]);
    }
    ["|"](...args) {
        return sqlFunction("|", [{ args: [(default_1$5), (default_1$5)], ret: (default_1$5), isOperator: true }], [this, ...args]);
    }
    ["<<"](...args) {
        return sqlFunction("<<", [{ args: [(default_1$5), (default_1$4)], ret: (default_1$5), isOperator: true }], [this, ...args]);
    }
    [">>"](...args) {
        return sqlFunction(">>", [{ args: [(default_1$5), (default_1$4)], ret: (default_1$5), isOperator: true }], [this, ...args]);
    }
    ["#"](...args) {
        return sqlFunction("#", [{ args: [(default_1$5), (default_1$5)], ret: (default_1$5), isOperator: true }], [this, ...args]);
    }
};

class int2vector extends Any {
    static new(v) { return new int2vector(v); }
    static parse(v) { return v; }
    static typeString() { return "int2vector"; }
    asAggregate() {
        return undefined;
    }
}

let default_1$4 = class default_1 extends Any {
    static new(v) { return new default_1$4(v); }
    static serializeParamTypes = undefined;
    static parse(v) { return typeMap["int4"].parse(v); }
    static typeString() { return "int4"; }
    asAggregate() {
        return undefined;
    }
    abs(...args) {
        return sqlFunction("abs", [{ args: [(default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    avg(...args) {
        return sqlFunction("avg", [{ args: [(default_1$4)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    bit(...args) {
        return sqlFunction("bit", [{ args: [(default_1$4), (default_1$4)], ret: (bit$1), isOperator: false }], [this, ...args]);
    }
    bitAnd(...args) {
        return sqlFunction("bit_and", [{ args: [(default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    bitOr(...args) {
        return sqlFunction("bit_or", [{ args: [(default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    bitXor(...args) {
        return sqlFunction("bit_xor", [{ args: [(default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    bool(...args) {
        return sqlFunction("bool", [{ args: [(default_1$4)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    btint42Cmp(...args) {
        return sqlFunction("btint42cmp", [{ args: [(default_1$4), (default_1$5)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    btint48Cmp(...args) {
        return sqlFunction("btint48cmp", [{ args: [(default_1$4), (default_1$3)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    btint4Cmp(...args) {
        return sqlFunction("btint4cmp", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    char(...args) {
        return sqlFunction("char", [{ args: [(default_1$4)], ret: (char$1), isOperator: false }], [this, ...args]);
    }
    chr(...args) {
        return sqlFunction("chr", [{ args: [(default_1$4)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    float4(...args) {
        return sqlFunction("float4", [{ args: [(default_1$4)], ret: (default_1$7), isOperator: false }], [this, ...args]);
    }
    float8(...args) {
        return sqlFunction("float8", [{ args: [(default_1$4)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    gcd(...args) {
        return sqlFunction("gcd", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    generateSeries(...args) {
        return sqlFunction("generate_series", [{ args: [(default_1$4), (default_1$4)], ret: Setof.ofSchema({}), isOperator: false }, { args: [(default_1$4), (default_1$4), (default_1$4)], ret: Setof.ofSchema({}), isOperator: false }], [this, ...args]);
    }
    hashint4(...args) {
        return sqlFunction("hashint4", [{ args: [(default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    hashint4Extended(...args) {
        return sqlFunction("hashint4extended", [{ args: [(default_1$4), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    inRange(...args) {
        return sqlFunction("in_range", [{ args: [(default_1$4), (default_1$4), (default_1$5), (default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }, { args: [(default_1$4), (default_1$4), (default_1$4), (default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }, { args: [(default_1$4), (default_1$4), (default_1$3), (default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int2(...args) {
        return sqlFunction("int2", [{ args: [(default_1$4)], ret: (default_1$5), isOperator: false }], [this, ...args]);
    }
    int42Div(...args) {
        return sqlFunction("int42div", [{ args: [(default_1$4), (default_1$5)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    int42Eq(...args) {
        return sqlFunction("int42eq", [{ args: [(default_1$4), (default_1$5)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int42Ge(...args) {
        return sqlFunction("int42ge", [{ args: [(default_1$4), (default_1$5)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int42Gt(...args) {
        return sqlFunction("int42gt", [{ args: [(default_1$4), (default_1$5)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int42Le(...args) {
        return sqlFunction("int42le", [{ args: [(default_1$4), (default_1$5)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int42Lt(...args) {
        return sqlFunction("int42lt", [{ args: [(default_1$4), (default_1$5)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int42Mi(...args) {
        return sqlFunction("int42mi", [{ args: [(default_1$4), (default_1$5)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    int42Mul(...args) {
        return sqlFunction("int42mul", [{ args: [(default_1$4), (default_1$5)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    int42Ne(...args) {
        return sqlFunction("int42ne", [{ args: [(default_1$4), (default_1$5)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int42Pl(...args) {
        return sqlFunction("int42pl", [{ args: [(default_1$4), (default_1$5)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    int48Div(...args) {
        return sqlFunction("int48div", [{ args: [(default_1$4), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    int48Eq(...args) {
        return sqlFunction("int48eq", [{ args: [(default_1$4), (default_1$3)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int48Ge(...args) {
        return sqlFunction("int48ge", [{ args: [(default_1$4), (default_1$3)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int48Gt(...args) {
        return sqlFunction("int48gt", [{ args: [(default_1$4), (default_1$3)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int48Le(...args) {
        return sqlFunction("int48le", [{ args: [(default_1$4), (default_1$3)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int48Lt(...args) {
        return sqlFunction("int48lt", [{ args: [(default_1$4), (default_1$3)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int48Mi(...args) {
        return sqlFunction("int48mi", [{ args: [(default_1$4), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    int48Mul(...args) {
        return sqlFunction("int48mul", [{ args: [(default_1$4), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    int48Ne(...args) {
        return sqlFunction("int48ne", [{ args: [(default_1$4), (default_1$3)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int48Pl(...args) {
        return sqlFunction("int48pl", [{ args: [(default_1$4), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    int4MulCash(...args) {
        return sqlFunction("int4_mul_cash", [{ args: [(default_1$4), (money$1)], ret: (money$1), isOperator: false }], [this, ...args]);
    }
    int4Abs(...args) {
        return sqlFunction("int4abs", [{ args: [(default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    int4And(...args) {
        return sqlFunction("int4and", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    int4Div(...args) {
        return sqlFunction("int4div", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    int4Eq(...args) {
        return sqlFunction("int4eq", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int4Ge(...args) {
        return sqlFunction("int4ge", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int4Gt(...args) {
        return sqlFunction("int4gt", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int4Inc(...args) {
        return sqlFunction("int4inc", [{ args: [(default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    int4Larger(...args) {
        return sqlFunction("int4larger", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    int4Le(...args) {
        return sqlFunction("int4le", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int4Lt(...args) {
        return sqlFunction("int4lt", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int4Mi(...args) {
        return sqlFunction("int4mi", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    int4Mod(...args) {
        return sqlFunction("int4mod", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    int4Mul(...args) {
        return sqlFunction("int4mul", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    int4Ne(...args) {
        return sqlFunction("int4ne", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int4Not(...args) {
        return sqlFunction("int4not", [{ args: [(default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    int4Or(...args) {
        return sqlFunction("int4or", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    int4Pl(...args) {
        return sqlFunction("int4pl", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    int4Range(...args) {
        return sqlFunction("int4range", [{ args: [(default_1$4), (default_1$4)], ret: (int4range), isOperator: false }, { args: [(default_1$4), (default_1$4), (default_1$1)], ret: (int4range), isOperator: false }], [this, ...args]);
    }
    int4RangeSubdiff(...args) {
        return sqlFunction("int4range_subdiff", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    int4Shl(...args) {
        return sqlFunction("int4shl", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    int4Shr(...args) {
        return sqlFunction("int4shr", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    int4Smaller(...args) {
        return sqlFunction("int4smaller", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    int4Um(...args) {
        return sqlFunction("int4um", [{ args: [(default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    int4Up(...args) {
        return sqlFunction("int4up", [{ args: [(default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    int4Xor(...args) {
        return sqlFunction("int4xor", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    int8(...args) {
        return sqlFunction("int8", [{ args: [(default_1$4)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    integerPlDate(...args) {
        return sqlFunction("integer_pl_date", [{ args: [(default_1$4), (date$1)], ret: (date$1), isOperator: false }], [this, ...args]);
    }
    lcm(...args) {
        return sqlFunction("lcm", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    loClose(...args) {
        return sqlFunction("lo_close", [{ args: [(default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    loCreat(...args) {
        return sqlFunction("lo_creat", [{ args: [(default_1$4)], ret: (oid$1), isOperator: false }], [this, ...args]);
    }
    loLseek(...args) {
        return sqlFunction("lo_lseek", [{ args: [(default_1$4), (default_1$4), (default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    loLseek64(...args) {
        return sqlFunction("lo_lseek64", [{ args: [(default_1$4), (default_1$3), (default_1$4)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    loTell(...args) {
        return sqlFunction("lo_tell", [{ args: [(default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    loTell64(...args) {
        return sqlFunction("lo_tell64", [{ args: [(default_1$4)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    loTruncate(...args) {
        return sqlFunction("lo_truncate", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    loTruncate64(...args) {
        return sqlFunction("lo_truncate64", [{ args: [(default_1$4), (default_1$3)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    loread(...args) {
        return sqlFunction("loread", [{ args: [(default_1$4), (default_1$4)], ret: (bytea), isOperator: false }], [this, ...args]);
    }
    lowrite(...args) {
        return sqlFunction("lowrite", [{ args: [(default_1$4), (bytea)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    makeDate(...args) {
        return sqlFunction("make_date", [{ args: [(default_1$4), (default_1$4), (default_1$4)], ret: (date$1), isOperator: false }], [this, ...args]);
    }
    makeInterval(...args) {
        return sqlFunction("make_interval", [{ args: [(default_1$4), (default_1$4), (default_1$4), (default_1$4), (default_1$4), (default_1$4), (default_1$6)], ret: (interval$1), isOperator: false }], [this, ...args]);
    }
    makeTime(...args) {
        return sqlFunction("make_time", [{ args: [(default_1$4), (default_1$4), (default_1$6)], ret: (time$1), isOperator: false }], [this, ...args]);
    }
    makeTimestamp(...args) {
        return sqlFunction("make_timestamp", [{ args: [(default_1$4), (default_1$4), (default_1$4), (default_1$4), (default_1$4), (default_1$6)], ret: (timestamp$1), isOperator: false }], [this, ...args]);
    }
    makeTimestamptz(...args) {
        return sqlFunction("make_timestamptz", [{ args: [(default_1$4), (default_1$4), (default_1$4), (default_1$4), (default_1$4), (default_1$6)], ret: (timestamptz$1), isOperator: false }, { args: [(default_1$4), (default_1$4), (default_1$4), (default_1$4), (default_1$4), (default_1$6), (default_1$1)], ret: (timestamptz$1), isOperator: false }], [this, ...args]);
    }
    max(...args) {
        return sqlFunction("max", [{ args: [(default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    mod(...args) {
        return sqlFunction("mod", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    money(...args) {
        return sqlFunction("money", [{ args: [(default_1$4)], ret: (money$1), isOperator: false }], [this, ...args]);
    }
    ntile(...args) {
        return sqlFunction("ntile", [{ args: [(default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    numeric(...args) {
        return sqlFunction("numeric", [{ args: [(default_1$4)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    pgAdvisoryLock(...args) {
        return sqlFunction("pg_advisory_lock", [{ args: [(default_1$4), (default_1$4)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    pgAdvisoryLockShared(...args) {
        return sqlFunction("pg_advisory_lock_shared", [{ args: [(default_1$4), (default_1$4)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    pgAdvisoryUnlock(...args) {
        return sqlFunction("pg_advisory_unlock", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgAdvisoryUnlockShared(...args) {
        return sqlFunction("pg_advisory_unlock_shared", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgAdvisoryXactLock(...args) {
        return sqlFunction("pg_advisory_xact_lock", [{ args: [(default_1$4), (default_1$4)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    pgAdvisoryXactLockShared(...args) {
        return sqlFunction("pg_advisory_xact_lock_shared", [{ args: [(default_1$4), (default_1$4)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    pgBlockingPids(...args) {
        return sqlFunction("pg_blocking_pids", [{ args: [(default_1$4)], ret: Array$1.of((default_1$4)), isOperator: false }], [this, ...args]);
    }
    pgCancelBackend(...args) {
        return sqlFunction("pg_cancel_backend", [{ args: [(default_1$4)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgEncodingMaxLength(...args) {
        return sqlFunction("pg_encoding_max_length", [{ args: [(default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    pgEncodingToChar(...args) {
        return sqlFunction("pg_encoding_to_char", [{ args: [(default_1$4)], ret: (name$1), isOperator: false }], [this, ...args]);
    }
    pgIsolationTestSessionIsBlocked(...args) {
        return sqlFunction("pg_isolation_test_session_is_blocked", [{ args: [(default_1$4), Array$1.of((default_1$4))], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgLogBackendMemoryContexts(...args) {
        return sqlFunction("pg_log_backend_memory_contexts", [{ args: [(default_1$4)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgSafeSnapshotBlockingPids(...args) {
        return sqlFunction("pg_safe_snapshot_blocking_pids", [{ args: [(default_1$4)], ret: Array$1.of((default_1$4)), isOperator: false }], [this, ...args]);
    }
    pgStatGetActivity(...args) {
        return sqlFunction("pg_stat_get_activity", [{ args: [(default_1$4)], ret: Setof.ofSchema({ datid: (oid$1), pid: (default_1$4), usesysid: (oid$1), application_name: (default_1$1), state: (default_1$1), query: (default_1$1), wait_event_type: (default_1$1), wait_event: (default_1$1), xact_start: (timestamptz$1), query_start: (timestamptz$1), backend_start: (timestamptz$1), state_change: (timestamptz$1), client_addr: (inet), client_hostname: (default_1$1), client_port: (default_1$4), backend_xid: (xid$1), backend_xmin: (xid$1), backend_type: (default_1$1), ssl: (default_1$8), sslversion: (default_1$1), sslcipher: (default_1$1), sslbits: (default_1$4), ssl_client_dn: (default_1$1), ssl_client_serial: (default_1$2), ssl_issuer_dn: (default_1$1), gss_auth: (default_1$8), gss_princ: (default_1$1), gss_enc: (default_1$8), gss_delegation: (default_1$8), leader_pid: (default_1$4), query_id: (default_1$3) }), isOperator: false }], [this, ...args]);
    }
    pgStatGetBackendActivity(...args) {
        return sqlFunction("pg_stat_get_backend_activity", [{ args: [(default_1$4)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    pgStatGetBackendActivityStart(...args) {
        return sqlFunction("pg_stat_get_backend_activity_start", [{ args: [(default_1$4)], ret: (timestamptz$1), isOperator: false }], [this, ...args]);
    }
    pgStatGetBackendClientAddr(...args) {
        return sqlFunction("pg_stat_get_backend_client_addr", [{ args: [(default_1$4)], ret: (inet), isOperator: false }], [this, ...args]);
    }
    pgStatGetBackendClientPort(...args) {
        return sqlFunction("pg_stat_get_backend_client_port", [{ args: [(default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    pgStatGetBackendDbid(...args) {
        return sqlFunction("pg_stat_get_backend_dbid", [{ args: [(default_1$4)], ret: (oid$1), isOperator: false }], [this, ...args]);
    }
    pgStatGetBackendPid(...args) {
        return sqlFunction("pg_stat_get_backend_pid", [{ args: [(default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    pgStatGetBackendStart(...args) {
        return sqlFunction("pg_stat_get_backend_start", [{ args: [(default_1$4)], ret: (timestamptz$1), isOperator: false }], [this, ...args]);
    }
    pgStatGetBackendSubxact(...args) {
        return sqlFunction("pg_stat_get_backend_subxact", [{ args: [(default_1$4)], ret: Record.of({ subxact_count: (default_1$4), subxact_overflowed: (default_1$8) }), isOperator: false }], [this, ...args]);
    }
    pgStatGetBackendUserid(...args) {
        return sqlFunction("pg_stat_get_backend_userid", [{ args: [(default_1$4)], ret: (oid$1), isOperator: false }], [this, ...args]);
    }
    pgStatGetBackendWaitEvent(...args) {
        return sqlFunction("pg_stat_get_backend_wait_event", [{ args: [(default_1$4)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    pgStatGetBackendWaitEventType(...args) {
        return sqlFunction("pg_stat_get_backend_wait_event_type", [{ args: [(default_1$4)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    pgStatGetBackendXactStart(...args) {
        return sqlFunction("pg_stat_get_backend_xact_start", [{ args: [(default_1$4)], ret: (timestamptz$1), isOperator: false }], [this, ...args]);
    }
    pgTerminateBackend(...args) {
        return sqlFunction("pg_terminate_backend", [{ args: [(default_1$4), (default_1$3)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgTryAdvisoryLock(...args) {
        return sqlFunction("pg_try_advisory_lock", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgTryAdvisoryLockShared(...args) {
        return sqlFunction("pg_try_advisory_lock_shared", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgTryAdvisoryXactLock(...args) {
        return sqlFunction("pg_try_advisory_xact_lock", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgTryAdvisoryXactLockShared(...args) {
        return sqlFunction("pg_try_advisory_xact_lock_shared", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    polygon(...args) {
        return sqlFunction("polygon", [{ args: [(default_1$4), (circle$1)], ret: (polygon$1), isOperator: false }], [this, ...args]);
    }
    random(...args) {
        return sqlFunction("random", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    stddev(...args) {
        return sqlFunction("stddev", [{ args: [(default_1$4)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    stddevPop(...args) {
        return sqlFunction("stddev_pop", [{ args: [(default_1$4)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    stddevSamp(...args) {
        return sqlFunction("stddev_samp", [{ args: [(default_1$4)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    sum(...args) {
        return sqlFunction("sum", [{ args: [(default_1$4)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    toChar(...args) {
        return sqlFunction("to_char", [{ args: [(default_1$4), (default_1$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    toHex(...args) {
        return sqlFunction("to_hex", [{ args: [(default_1$4)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    toOct(...args) {
        return sqlFunction("to_oct", [{ args: [(default_1$4)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    varPop(...args) {
        return sqlFunction("var_pop", [{ args: [(default_1$4)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    varSamp(...args) {
        return sqlFunction("var_samp", [{ args: [(default_1$4)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    variance(...args) {
        return sqlFunction("variance", [{ args: [(default_1$4)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    ["/"](...args) {
        return sqlFunction("/", [{ args: [(default_1$4), (default_1$5)], ret: (default_1$4), isOperator: true }, { args: [(default_1$4), (default_1$3)], ret: (default_1$3), isOperator: true }, { args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: true }], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [{ args: [(default_1$4), (default_1$5)], ret: (default_1$8), isOperator: true }, { args: [(default_1$4), (default_1$3)], ret: (default_1$8), isOperator: true }, { args: [(default_1$4), (default_1$4)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">="](...args) {
        return sqlFunction(">=", [{ args: [(default_1$4), (default_1$5)], ret: (default_1$8), isOperator: true }, { args: [(default_1$4), (default_1$3)], ret: (default_1$8), isOperator: true }, { args: [(default_1$4), (default_1$4)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">"](...args) {
        return sqlFunction(">", [{ args: [(default_1$4), (default_1$5)], ret: (default_1$8), isOperator: true }, { args: [(default_1$4), (default_1$3)], ret: (default_1$8), isOperator: true }, { args: [(default_1$4), (default_1$4)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<="](...args) {
        return sqlFunction("<=", [{ args: [(default_1$4), (default_1$5)], ret: (default_1$8), isOperator: true }, { args: [(default_1$4), (default_1$3)], ret: (default_1$8), isOperator: true }, { args: [(default_1$4), (default_1$4)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<"](...args) {
        return sqlFunction("<", [{ args: [(default_1$4), (default_1$5)], ret: (default_1$8), isOperator: true }, { args: [(default_1$4), (default_1$3)], ret: (default_1$8), isOperator: true }, { args: [(default_1$4), (default_1$4)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["-"](...args) {
        return sqlFunction("-", [{ args: [(default_1$4), (default_1$5)], ret: (default_1$4), isOperator: true }, { args: [(default_1$4), (default_1$3)], ret: (default_1$3), isOperator: true }, { args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: true }], [this, ...args]);
    }
    ["*"](...args) {
        return sqlFunction("*", [{ args: [(default_1$4), (default_1$5)], ret: (default_1$4), isOperator: true }, { args: [(default_1$4), (default_1$3)], ret: (default_1$3), isOperator: true }, { args: [(default_1$4), (money$1)], ret: (money$1), isOperator: true }, { args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: true }], [this, ...args]);
    }
    ["<>"](...args) {
        return sqlFunction("<>", [{ args: [(default_1$4), (default_1$5)], ret: (default_1$8), isOperator: true }, { args: [(default_1$4), (default_1$3)], ret: (default_1$8), isOperator: true }, { args: [(default_1$4), (default_1$4)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["+"](...args) {
        return sqlFunction("+", [{ args: [(default_1$4), (default_1$5)], ret: (default_1$4), isOperator: true }, { args: [(default_1$4), (default_1$3)], ret: (default_1$3), isOperator: true }, { args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: true }, { args: [(default_1$4), (date$1)], ret: (date$1), isOperator: true }], [this, ...args]);
    }
    ["&"](...args) {
        return sqlFunction("&", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: true }], [this, ...args]);
    }
    ["%"](...args) {
        return sqlFunction("%", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: true }], [this, ...args]);
    }
    ["|"](...args) {
        return sqlFunction("|", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: true }], [this, ...args]);
    }
    ["<<"](...args) {
        return sqlFunction("<<", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: true }], [this, ...args]);
    }
    [">>"](...args) {
        return sqlFunction(">>", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: true }], [this, ...args]);
    }
    ["#"](...args) {
        return sqlFunction("#", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: true }], [this, ...args]);
    }
};

class int4multirange extends Any {
    static new(v) { return new int4multirange(v); }
    static parse(v) { return v; }
    static typeString() { return "int4multirange"; }
    asAggregate() {
        return undefined;
    }
}

class int4range extends Any {
    static new(v) { return new int4range(v); }
    static parse(v) { return v; }
    static typeString() { return "int4range"; }
    asAggregate() {
        return undefined;
    }
    int4Multirange(...args) {
        return sqlFunction("int4multirange", [{ args: [(int4range)], ret: (int4multirange), isOperator: false }], [this, ...args]);
    }
    int4RangeCanonical(...args) {
        return sqlFunction("int4range_canonical", [{ args: [(int4range)], ret: (int4range), isOperator: false }], [this, ...args]);
    }
}

let default_1$3 = class default_1 extends Any {
    static new(v) { return new default_1$3(v); }
    static serializeParamTypes = undefined;
    static parse(v) { return typeMap["int8"].parse(v); }
    static typeString() { return "int8"; }
    asAggregate() {
        return undefined;
    }
    abs(...args) {
        return sqlFunction("abs", [{ args: [(default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    avg(...args) {
        return sqlFunction("avg", [{ args: [(default_1$3)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    bit(...args) {
        return sqlFunction("bit", [{ args: [(default_1$3), (default_1$4)], ret: (bit$1), isOperator: false }], [this, ...args]);
    }
    bitAnd(...args) {
        return sqlFunction("bit_and", [{ args: [(default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    bitOr(...args) {
        return sqlFunction("bit_or", [{ args: [(default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    bitXor(...args) {
        return sqlFunction("bit_xor", [{ args: [(default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    btint82Cmp(...args) {
        return sqlFunction("btint82cmp", [{ args: [(default_1$3), (default_1$5)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    btint84Cmp(...args) {
        return sqlFunction("btint84cmp", [{ args: [(default_1$3), (default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    btint8Cmp(...args) {
        return sqlFunction("btint8cmp", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    factorial(...args) {
        return sqlFunction("factorial", [{ args: [(default_1$3)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    float4(...args) {
        return sqlFunction("float4", [{ args: [(default_1$3)], ret: (default_1$7), isOperator: false }], [this, ...args]);
    }
    float8(...args) {
        return sqlFunction("float8", [{ args: [(default_1$3)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    gcd(...args) {
        return sqlFunction("gcd", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    generateSeries(...args) {
        return sqlFunction("generate_series", [{ args: [(default_1$3), (default_1$3)], ret: Setof.ofSchema({}), isOperator: false }, { args: [(default_1$3), (default_1$3), (default_1$3)], ret: Setof.ofSchema({}), isOperator: false }], [this, ...args]);
    }
    hashint8(...args) {
        return sqlFunction("hashint8", [{ args: [(default_1$3)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    hashint8Extended(...args) {
        return sqlFunction("hashint8extended", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    inRange(...args) {
        return sqlFunction("in_range", [{ args: [(default_1$3), (default_1$3), (default_1$3), (default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int2(...args) {
        return sqlFunction("int2", [{ args: [(default_1$3)], ret: (default_1$5), isOperator: false }], [this, ...args]);
    }
    int2Sum(...args) {
        return sqlFunction("int2_sum", [{ args: [(default_1$3), (default_1$5)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    int4(...args) {
        return sqlFunction("int4", [{ args: [(default_1$3)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    int4Sum(...args) {
        return sqlFunction("int4_sum", [{ args: [(default_1$3), (default_1$4)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    int82Div(...args) {
        return sqlFunction("int82div", [{ args: [(default_1$3), (default_1$5)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    int82Eq(...args) {
        return sqlFunction("int82eq", [{ args: [(default_1$3), (default_1$5)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int82Ge(...args) {
        return sqlFunction("int82ge", [{ args: [(default_1$3), (default_1$5)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int82Gt(...args) {
        return sqlFunction("int82gt", [{ args: [(default_1$3), (default_1$5)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int82Le(...args) {
        return sqlFunction("int82le", [{ args: [(default_1$3), (default_1$5)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int82Lt(...args) {
        return sqlFunction("int82lt", [{ args: [(default_1$3), (default_1$5)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int82Mi(...args) {
        return sqlFunction("int82mi", [{ args: [(default_1$3), (default_1$5)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    int82Mul(...args) {
        return sqlFunction("int82mul", [{ args: [(default_1$3), (default_1$5)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    int82Ne(...args) {
        return sqlFunction("int82ne", [{ args: [(default_1$3), (default_1$5)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int82Pl(...args) {
        return sqlFunction("int82pl", [{ args: [(default_1$3), (default_1$5)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    int84Div(...args) {
        return sqlFunction("int84div", [{ args: [(default_1$3), (default_1$4)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    int84Eq(...args) {
        return sqlFunction("int84eq", [{ args: [(default_1$3), (default_1$4)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int84Ge(...args) {
        return sqlFunction("int84ge", [{ args: [(default_1$3), (default_1$4)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int84Gt(...args) {
        return sqlFunction("int84gt", [{ args: [(default_1$3), (default_1$4)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int84Le(...args) {
        return sqlFunction("int84le", [{ args: [(default_1$3), (default_1$4)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int84Lt(...args) {
        return sqlFunction("int84lt", [{ args: [(default_1$3), (default_1$4)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int84Mi(...args) {
        return sqlFunction("int84mi", [{ args: [(default_1$3), (default_1$4)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    int84Mul(...args) {
        return sqlFunction("int84mul", [{ args: [(default_1$3), (default_1$4)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    int84Ne(...args) {
        return sqlFunction("int84ne", [{ args: [(default_1$3), (default_1$4)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int84Pl(...args) {
        return sqlFunction("int84pl", [{ args: [(default_1$3), (default_1$4)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    int8MulCash(...args) {
        return sqlFunction("int8_mul_cash", [{ args: [(default_1$3), (money$1)], ret: (money$1), isOperator: false }], [this, ...args]);
    }
    int8Abs(...args) {
        return sqlFunction("int8abs", [{ args: [(default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    int8And(...args) {
        return sqlFunction("int8and", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    int8Dec(...args) {
        return sqlFunction("int8dec", [{ args: [(default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    int8DecAny(...args) {
        return sqlFunction("int8dec_any", [{ args: [(default_1$3), (Any)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    int8Div(...args) {
        return sqlFunction("int8div", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    int8Eq(...args) {
        return sqlFunction("int8eq", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int8Ge(...args) {
        return sqlFunction("int8ge", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int8Gt(...args) {
        return sqlFunction("int8gt", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int8Inc(...args) {
        return sqlFunction("int8inc", [{ args: [(default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    int8IncAny(...args) {
        return sqlFunction("int8inc_any", [{ args: [(default_1$3), (Any)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    int8IncFloat8Float8(...args) {
        return sqlFunction("int8inc_float8_float8", [{ args: [(default_1$3), (default_1$6), (default_1$6)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    int8Larger(...args) {
        return sqlFunction("int8larger", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    int8Le(...args) {
        return sqlFunction("int8le", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int8Lt(...args) {
        return sqlFunction("int8lt", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int8Mi(...args) {
        return sqlFunction("int8mi", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    int8Mod(...args) {
        return sqlFunction("int8mod", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    int8Mul(...args) {
        return sqlFunction("int8mul", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    int8Ne(...args) {
        return sqlFunction("int8ne", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int8Not(...args) {
        return sqlFunction("int8not", [{ args: [(default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    int8Or(...args) {
        return sqlFunction("int8or", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    int8Pl(...args) {
        return sqlFunction("int8pl", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    int8PlInet(...args) {
        return sqlFunction("int8pl_inet", [{ args: [(default_1$3), (inet)], ret: (inet), isOperator: false }], [this, ...args]);
    }
    int8Range(...args) {
        return sqlFunction("int8range", [{ args: [(default_1$3), (default_1$3)], ret: (int8range), isOperator: false }, { args: [(default_1$3), (default_1$3), (default_1$1)], ret: (int8range), isOperator: false }], [this, ...args]);
    }
    int8RangeSubdiff(...args) {
        return sqlFunction("int8range_subdiff", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    int8Shl(...args) {
        return sqlFunction("int8shl", [{ args: [(default_1$3), (default_1$4)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    int8Shr(...args) {
        return sqlFunction("int8shr", [{ args: [(default_1$3), (default_1$4)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    int8Smaller(...args) {
        return sqlFunction("int8smaller", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    int8Um(...args) {
        return sqlFunction("int8um", [{ args: [(default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    int8Up(...args) {
        return sqlFunction("int8up", [{ args: [(default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    int8Xor(...args) {
        return sqlFunction("int8xor", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    lcm(...args) {
        return sqlFunction("lcm", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    max(...args) {
        return sqlFunction("max", [{ args: [(default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    mod(...args) {
        return sqlFunction("mod", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    money(...args) {
        return sqlFunction("money", [{ args: [(default_1$3)], ret: (money$1), isOperator: false }], [this, ...args]);
    }
    numeric(...args) {
        return sqlFunction("numeric", [{ args: [(default_1$3)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    oid(...args) {
        return sqlFunction("oid", [{ args: [(default_1$3)], ret: (oid$1), isOperator: false }], [this, ...args]);
    }
    pgAdvisoryLock(...args) {
        return sqlFunction("pg_advisory_lock", [{ args: [(default_1$3)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    pgAdvisoryLockShared(...args) {
        return sqlFunction("pg_advisory_lock_shared", [{ args: [(default_1$3)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    pgAdvisoryUnlock(...args) {
        return sqlFunction("pg_advisory_unlock", [{ args: [(default_1$3)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgAdvisoryUnlockShared(...args) {
        return sqlFunction("pg_advisory_unlock_shared", [{ args: [(default_1$3)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgAdvisoryXactLock(...args) {
        return sqlFunction("pg_advisory_xact_lock", [{ args: [(default_1$3)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    pgAdvisoryXactLockShared(...args) {
        return sqlFunction("pg_advisory_xact_lock_shared", [{ args: [(default_1$3)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    pgSizePretty(...args) {
        return sqlFunction("pg_size_pretty", [{ args: [(default_1$3)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    pgTryAdvisoryLock(...args) {
        return sqlFunction("pg_try_advisory_lock", [{ args: [(default_1$3)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgTryAdvisoryLockShared(...args) {
        return sqlFunction("pg_try_advisory_lock_shared", [{ args: [(default_1$3)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgTryAdvisoryXactLock(...args) {
        return sqlFunction("pg_try_advisory_xact_lock", [{ args: [(default_1$3)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgTryAdvisoryXactLockShared(...args) {
        return sqlFunction("pg_try_advisory_xact_lock_shared", [{ args: [(default_1$3)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgWalSummaryContents(...args) {
        return sqlFunction("pg_wal_summary_contents", [{ args: [(default_1$3), (pg_lsn), (pg_lsn)], ret: Setof.ofSchema({ relfilenode: (oid$1), reltablespace: (oid$1), reldatabase: (oid$1), relforknumber: (default_1$5), relblocknumber: (default_1$3), is_limit_block: (default_1$8) }), isOperator: false }], [this, ...args]);
    }
    random(...args) {
        return sqlFunction("random", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    stddev(...args) {
        return sqlFunction("stddev", [{ args: [(default_1$3)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    stddevPop(...args) {
        return sqlFunction("stddev_pop", [{ args: [(default_1$3)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    stddevSamp(...args) {
        return sqlFunction("stddev_samp", [{ args: [(default_1$3)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    sum(...args) {
        return sqlFunction("sum", [{ args: [(default_1$3)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    toChar(...args) {
        return sqlFunction("to_char", [{ args: [(default_1$3), (default_1$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    toHex(...args) {
        return sqlFunction("to_hex", [{ args: [(default_1$3)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    toOct(...args) {
        return sqlFunction("to_oct", [{ args: [(default_1$3)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    txidStatus(...args) {
        return sqlFunction("txid_status", [{ args: [(default_1$3)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    txidVisibleInSnapshot(...args) {
        return sqlFunction("txid_visible_in_snapshot", [{ args: [(default_1$3), (txid_snapshot)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    varPop(...args) {
        return sqlFunction("var_pop", [{ args: [(default_1$3)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    varSamp(...args) {
        return sqlFunction("var_samp", [{ args: [(default_1$3)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    variance(...args) {
        return sqlFunction("variance", [{ args: [(default_1$3)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    ["/"](...args) {
        return sqlFunction("/", [{ args: [(default_1$3), (default_1$5)], ret: (default_1$3), isOperator: true }, { args: [(default_1$3), (default_1$4)], ret: (default_1$3), isOperator: true }, { args: [(default_1$3), (default_1$3)], ret: (default_1$3), isOperator: true }], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [{ args: [(default_1$3), (default_1$5)], ret: (default_1$8), isOperator: true }, { args: [(default_1$3), (default_1$4)], ret: (default_1$8), isOperator: true }, { args: [(default_1$3), (default_1$3)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">="](...args) {
        return sqlFunction(">=", [{ args: [(default_1$3), (default_1$5)], ret: (default_1$8), isOperator: true }, { args: [(default_1$3), (default_1$4)], ret: (default_1$8), isOperator: true }, { args: [(default_1$3), (default_1$3)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">"](...args) {
        return sqlFunction(">", [{ args: [(default_1$3), (default_1$5)], ret: (default_1$8), isOperator: true }, { args: [(default_1$3), (default_1$4)], ret: (default_1$8), isOperator: true }, { args: [(default_1$3), (default_1$3)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<="](...args) {
        return sqlFunction("<=", [{ args: [(default_1$3), (default_1$5)], ret: (default_1$8), isOperator: true }, { args: [(default_1$3), (default_1$4)], ret: (default_1$8), isOperator: true }, { args: [(default_1$3), (default_1$3)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<"](...args) {
        return sqlFunction("<", [{ args: [(default_1$3), (default_1$5)], ret: (default_1$8), isOperator: true }, { args: [(default_1$3), (default_1$4)], ret: (default_1$8), isOperator: true }, { args: [(default_1$3), (default_1$3)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["-"](...args) {
        return sqlFunction("-", [{ args: [(default_1$3), (default_1$5)], ret: (default_1$3), isOperator: true }, { args: [(default_1$3), (default_1$4)], ret: (default_1$3), isOperator: true }, { args: [(default_1$3), (default_1$3)], ret: (default_1$3), isOperator: true }], [this, ...args]);
    }
    ["*"](...args) {
        return sqlFunction("*", [{ args: [(default_1$3), (default_1$5)], ret: (default_1$3), isOperator: true }, { args: [(default_1$3), (default_1$4)], ret: (default_1$3), isOperator: true }, { args: [(default_1$3), (money$1)], ret: (money$1), isOperator: true }, { args: [(default_1$3), (default_1$3)], ret: (default_1$3), isOperator: true }], [this, ...args]);
    }
    ["<>"](...args) {
        return sqlFunction("<>", [{ args: [(default_1$3), (default_1$5)], ret: (default_1$8), isOperator: true }, { args: [(default_1$3), (default_1$4)], ret: (default_1$8), isOperator: true }, { args: [(default_1$3), (default_1$3)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["+"](...args) {
        return sqlFunction("+", [{ args: [(default_1$3), (default_1$5)], ret: (default_1$3), isOperator: true }, { args: [(default_1$3), (default_1$4)], ret: (default_1$3), isOperator: true }, { args: [(default_1$3), (default_1$3)], ret: (default_1$3), isOperator: true }, { args: [(default_1$3), (inet)], ret: (inet), isOperator: true }], [this, ...args]);
    }
    ["&"](...args) {
        return sqlFunction("&", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$3), isOperator: true }], [this, ...args]);
    }
    ["%"](...args) {
        return sqlFunction("%", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$3), isOperator: true }], [this, ...args]);
    }
    ["|"](...args) {
        return sqlFunction("|", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$3), isOperator: true }], [this, ...args]);
    }
    ["<<"](...args) {
        return sqlFunction("<<", [{ args: [(default_1$3), (default_1$4)], ret: (default_1$3), isOperator: true }], [this, ...args]);
    }
    [">>"](...args) {
        return sqlFunction(">>", [{ args: [(default_1$3), (default_1$4)], ret: (default_1$3), isOperator: true }], [this, ...args]);
    }
    ["#"](...args) {
        return sqlFunction("#", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$3), isOperator: true }], [this, ...args]);
    }
};

class int8multirange extends Any {
    static new(v) { return new int8multirange(v); }
    static parse(v) { return v; }
    static typeString() { return "int8multirange"; }
    asAggregate() {
        return undefined;
    }
}

class int8range extends Any {
    static new(v) { return new int8range(v); }
    static parse(v) { return v; }
    static typeString() { return "int8range"; }
    asAggregate() {
        return undefined;
    }
    int8Multirange(...args) {
        return sqlFunction("int8multirange", [{ args: [(int8range)], ret: (int8multirange), isOperator: false }], [this, ...args]);
    }
    int8RangeCanonical(...args) {
        return sqlFunction("int8range_canonical", [{ args: [(int8range)], ret: (int8range), isOperator: false }], [this, ...args]);
    }
}

class interval$1 extends Any {
    static new(v) { return new interval$1(v); }
    static parse(v) { return v; }
    static typeString() { return "interval"; }
    asAggregate() {
        return undefined;
    }
    avg(...args) {
        return sqlFunction("avg", [{ args: [(interval$1)], ret: (interval$1), isOperator: false }], [this, ...args]);
    }
    inRange(...args) {
        return sqlFunction("in_range", [{ args: [(interval$1), (interval$1), (interval$1), (default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    interval(...args) {
        return sqlFunction("interval", [{ args: [(interval$1), (default_1$4)], ret: (interval$1), isOperator: false }], [this, ...args]);
    }
    intervalCmp(...args) {
        return sqlFunction("interval_cmp", [{ args: [(interval$1), (interval$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    intervalDiv(...args) {
        return sqlFunction("interval_div", [{ args: [(interval$1), (default_1$6)], ret: (interval$1), isOperator: false }], [this, ...args]);
    }
    intervalEq(...args) {
        return sqlFunction("interval_eq", [{ args: [(interval$1), (interval$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    intervalGe(...args) {
        return sqlFunction("interval_ge", [{ args: [(interval$1), (interval$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    intervalGt(...args) {
        return sqlFunction("interval_gt", [{ args: [(interval$1), (interval$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    intervalHash(...args) {
        return sqlFunction("interval_hash", [{ args: [(interval$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    intervalHashExtended(...args) {
        return sqlFunction("interval_hash_extended", [{ args: [(interval$1), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    intervalLarger(...args) {
        return sqlFunction("interval_larger", [{ args: [(interval$1), (interval$1)], ret: (interval$1), isOperator: false }], [this, ...args]);
    }
    intervalLe(...args) {
        return sqlFunction("interval_le", [{ args: [(interval$1), (interval$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    intervalLt(...args) {
        return sqlFunction("interval_lt", [{ args: [(interval$1), (interval$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    intervalMi(...args) {
        return sqlFunction("interval_mi", [{ args: [(interval$1), (interval$1)], ret: (interval$1), isOperator: false }], [this, ...args]);
    }
    intervalMul(...args) {
        return sqlFunction("interval_mul", [{ args: [(interval$1), (default_1$6)], ret: (interval$1), isOperator: false }], [this, ...args]);
    }
    intervalNe(...args) {
        return sqlFunction("interval_ne", [{ args: [(interval$1), (interval$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    intervalPl(...args) {
        return sqlFunction("interval_pl", [{ args: [(interval$1), (interval$1)], ret: (interval$1), isOperator: false }], [this, ...args]);
    }
    intervalPlDate(...args) {
        return sqlFunction("interval_pl_date", [{ args: [(interval$1), (date$1)], ret: (timestamp$1), isOperator: false }], [this, ...args]);
    }
    intervalPlTime(...args) {
        return sqlFunction("interval_pl_time", [{ args: [(interval$1), (time$1)], ret: (time$1), isOperator: false }], [this, ...args]);
    }
    intervalPlTimestamp(...args) {
        return sqlFunction("interval_pl_timestamp", [{ args: [(interval$1), (timestamp$1)], ret: (timestamp$1), isOperator: false }], [this, ...args]);
    }
    intervalPlTimestamptz(...args) {
        return sqlFunction("interval_pl_timestamptz", [{ args: [(interval$1), (timestamptz$1)], ret: (timestamptz$1), isOperator: false }], [this, ...args]);
    }
    intervalPlTimetz(...args) {
        return sqlFunction("interval_pl_timetz", [{ args: [(interval$1), (timetz$1)], ret: (timetz$1), isOperator: false }], [this, ...args]);
    }
    intervalSmaller(...args) {
        return sqlFunction("interval_smaller", [{ args: [(interval$1), (interval$1)], ret: (interval$1), isOperator: false }], [this, ...args]);
    }
    intervalUm(...args) {
        return sqlFunction("interval_um", [{ args: [(interval$1)], ret: (interval$1), isOperator: false }], [this, ...args]);
    }
    isfinite(...args) {
        return sqlFunction("isfinite", [{ args: [(interval$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    justifyDays(...args) {
        return sqlFunction("justify_days", [{ args: [(interval$1)], ret: (interval$1), isOperator: false }], [this, ...args]);
    }
    justifyHours(...args) {
        return sqlFunction("justify_hours", [{ args: [(interval$1)], ret: (interval$1), isOperator: false }], [this, ...args]);
    }
    justifyInterval(...args) {
        return sqlFunction("justify_interval", [{ args: [(interval$1)], ret: (interval$1), isOperator: false }], [this, ...args]);
    }
    max(...args) {
        return sqlFunction("max", [{ args: [(interval$1)], ret: (interval$1), isOperator: false }], [this, ...args]);
    }
    pgSleepFor(...args) {
        return sqlFunction("pg_sleep_for", [{ args: [(interval$1)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    sum(...args) {
        return sqlFunction("sum", [{ args: [(interval$1)], ret: (interval$1), isOperator: false }], [this, ...args]);
    }
    time(...args) {
        return sqlFunction("time", [{ args: [(interval$1)], ret: (time$1), isOperator: false }], [this, ...args]);
    }
    timezone(...args) {
        return sqlFunction("timezone", [{ args: [(interval$1), (timestamptz$1)], ret: (timestamp$1), isOperator: false }, { args: [(interval$1), (timestamp$1)], ret: (timestamptz$1), isOperator: false }, { args: [(interval$1), (timetz$1)], ret: (timetz$1), isOperator: false }], [this, ...args]);
    }
    toChar(...args) {
        return sqlFunction("to_char", [{ args: [(interval$1), (default_1$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    ["/"](...args) {
        return sqlFunction("/", [{ args: [(interval$1), (default_1$6)], ret: (interval$1), isOperator: true }], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [{ args: [(interval$1), (interval$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">="](...args) {
        return sqlFunction(">=", [{ args: [(interval$1), (interval$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">"](...args) {
        return sqlFunction(">", [{ args: [(interval$1), (interval$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<="](...args) {
        return sqlFunction("<=", [{ args: [(interval$1), (interval$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<"](...args) {
        return sqlFunction("<", [{ args: [(interval$1), (interval$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["-"](...args) {
        return sqlFunction("-", [{ args: [(interval$1), (interval$1)], ret: (interval$1), isOperator: true }], [this, ...args]);
    }
    ["*"](...args) {
        return sqlFunction("*", [{ args: [(interval$1), (default_1$6)], ret: (interval$1), isOperator: true }], [this, ...args]);
    }
    ["<>"](...args) {
        return sqlFunction("<>", [{ args: [(interval$1), (interval$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["+"](...args) {
        return sqlFunction("+", [{ args: [(interval$1), (interval$1)], ret: (interval$1), isOperator: true }, { args: [(interval$1), (date$1)], ret: (timestamp$1), isOperator: true }, { args: [(interval$1), (time$1)], ret: (time$1), isOperator: true }, { args: [(interval$1), (timestamp$1)], ret: (timestamp$1), isOperator: true }, { args: [(interval$1), (timestamptz$1)], ret: (timestamptz$1), isOperator: true }, { args: [(interval$1), (timetz$1)], ret: (timetz$1), isOperator: true }], [this, ...args]);
    }
}

class json extends Any {
    static new(v) { return new json(v); }
    static parse(v) { return v; }
    static typeString() { return "json"; }
    asAggregate() {
        return undefined;
    }
    jsonArrayElement(...args) {
        return sqlFunction("json_array_element", [{ args: [(json), (default_1$4)], ret: (json), isOperator: false }], [this, ...args]);
    }
    jsonArrayElementText(...args) {
        return sqlFunction("json_array_element_text", [{ args: [(json), (default_1$4)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    jsonArrayElements(...args) {
        return sqlFunction("json_array_elements", [{ args: [(json)], ret: Setof.ofSchema({ value: (json) }), isOperator: false }], [this, ...args]);
    }
    jsonArrayElementsText(...args) {
        return sqlFunction("json_array_elements_text", [{ args: [(json)], ret: Setof.ofSchema({ value: (default_1$1) }), isOperator: false }], [this, ...args]);
    }
    jsonArrayLength(...args) {
        return sqlFunction("json_array_length", [{ args: [(json)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    jsonEach(...args) {
        return sqlFunction("json_each", [{ args: [(json)], ret: Setof.ofSchema({ key: (default_1$1), value: (json) }), isOperator: false }], [this, ...args]);
    }
    jsonEachText(...args) {
        return sqlFunction("json_each_text", [{ args: [(json)], ret: Setof.ofSchema({ key: (default_1$1), value: (default_1$1) }), isOperator: false }], [this, ...args]);
    }
    jsonExtractPath(...args) {
        return sqlFunction("json_extract_path", [{ args: [(json), Array$1.of((default_1$1))], ret: (json), isOperator: false }], [this, ...args]);
    }
    jsonExtractPathText(...args) {
        return sqlFunction("json_extract_path_text", [{ args: [(json), Array$1.of((default_1$1))], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    jsonObjectField(...args) {
        return sqlFunction("json_object_field", [{ args: [(json), (default_1$1)], ret: (json), isOperator: false }], [this, ...args]);
    }
    jsonObjectFieldText(...args) {
        return sqlFunction("json_object_field_text", [{ args: [(json), (default_1$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    jsonObjectKeys(...args) {
        return sqlFunction("json_object_keys", [{ args: [(json)], ret: Setof.ofSchema({}), isOperator: false }], [this, ...args]);
    }
    jsonStripNulls(...args) {
        return sqlFunction("json_strip_nulls", [{ args: [(json)], ret: (json), isOperator: false }], [this, ...args]);
    }
    jsonToRecord(...args) {
        return sqlFunction("json_to_record", [({ R }) => ({ args: [(json)], ret: Record.of(R), isOperator: false })], [this, ...args]);
    }
    jsonToRecordset(...args) {
        return sqlFunction("json_to_recordset", [{ args: [(json)], ret: Setof.ofSchema({}), isOperator: false }], [this, ...args]);
    }
    jsonToTsvector(...args) {
        return sqlFunction("json_to_tsvector", [{ args: [(json), (jsonb)], ret: (tsvector), isOperator: false }], [this, ...args]);
    }
    jsonTypeof(...args) {
        return sqlFunction("json_typeof", [{ args: [(json)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    toTsvector(...args) {
        return sqlFunction("to_tsvector", [{ args: [(json)], ret: (tsvector), isOperator: false }], [this, ...args]);
    }
    tsHeadline(...args) {
        return sqlFunction("ts_headline", [{ args: [(json), (tsquery)], ret: (json), isOperator: false }, { args: [(json), (tsquery), (default_1$1)], ret: (json), isOperator: false }], [this, ...args]);
    }
    ["->"](...args) {
        return sqlFunction("->", [{ args: [(json), (default_1$4)], ret: (json), isOperator: true }, { args: [(json), (default_1$1)], ret: (json), isOperator: true }], [this, ...args]);
    }
    ["->>"](...args) {
        return sqlFunction("->>", [{ args: [(json), (default_1$4)], ret: (default_1$1), isOperator: true }, { args: [(json), (default_1$1)], ret: (default_1$1), isOperator: true }], [this, ...args]);
    }
    ["#>"](...args) {
        return sqlFunction("#>", [{ args: [(json), Array$1.of((default_1$1))], ret: (json), isOperator: true }], [this, ...args]);
    }
    ["#>>"](...args) {
        return sqlFunction("#>>", [{ args: [(json), Array$1.of((default_1$1))], ret: (default_1$1), isOperator: true }], [this, ...args]);
    }
}

class jsonb extends Any {
    static new(v) { return new jsonb(v); }
    static parse(v) { return v; }
    static typeString() { return "jsonb"; }
    asAggregate() {
        return undefined;
    }
    bool(...args) {
        return sqlFunction("bool", [{ args: [(jsonb)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    float4(...args) {
        return sqlFunction("float4", [{ args: [(jsonb)], ret: (default_1$7), isOperator: false }], [this, ...args]);
    }
    float8(...args) {
        return sqlFunction("float8", [{ args: [(jsonb)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    int2(...args) {
        return sqlFunction("int2", [{ args: [(jsonb)], ret: (default_1$5), isOperator: false }], [this, ...args]);
    }
    int4(...args) {
        return sqlFunction("int4", [{ args: [(jsonb)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    int8(...args) {
        return sqlFunction("int8", [{ args: [(jsonb)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    jsonbArrayElement(...args) {
        return sqlFunction("jsonb_array_element", [{ args: [(jsonb), (default_1$4)], ret: (jsonb), isOperator: false }], [this, ...args]);
    }
    jsonbArrayElementText(...args) {
        return sqlFunction("jsonb_array_element_text", [{ args: [(jsonb), (default_1$4)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    jsonbArrayElements(...args) {
        return sqlFunction("jsonb_array_elements", [{ args: [(jsonb)], ret: Setof.ofSchema({ value: (jsonb) }), isOperator: false }], [this, ...args]);
    }
    jsonbArrayElementsText(...args) {
        return sqlFunction("jsonb_array_elements_text", [{ args: [(jsonb)], ret: Setof.ofSchema({ value: (default_1$1) }), isOperator: false }], [this, ...args]);
    }
    jsonbArrayLength(...args) {
        return sqlFunction("jsonb_array_length", [{ args: [(jsonb)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    jsonbCmp(...args) {
        return sqlFunction("jsonb_cmp", [{ args: [(jsonb), (jsonb)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    jsonbConcat(...args) {
        return sqlFunction("jsonb_concat", [{ args: [(jsonb), (jsonb)], ret: (jsonb), isOperator: false }], [this, ...args]);
    }
    jsonbContained(...args) {
        return sqlFunction("jsonb_contained", [{ args: [(jsonb), (jsonb)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    jsonbContains(...args) {
        return sqlFunction("jsonb_contains", [{ args: [(jsonb), (jsonb)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    jsonbDelete(...args) {
        return sqlFunction("jsonb_delete", [{ args: [(jsonb), Array$1.of((default_1$1))], ret: (jsonb), isOperator: false }, { args: [(jsonb), (default_1$4)], ret: (jsonb), isOperator: false }, { args: [(jsonb), (default_1$1)], ret: (jsonb), isOperator: false }], [this, ...args]);
    }
    jsonbDeletePath(...args) {
        return sqlFunction("jsonb_delete_path", [{ args: [(jsonb), Array$1.of((default_1$1))], ret: (jsonb), isOperator: false }], [this, ...args]);
    }
    jsonbEach(...args) {
        return sqlFunction("jsonb_each", [{ args: [(jsonb)], ret: Setof.ofSchema({ key: (default_1$1), value: (jsonb) }), isOperator: false }], [this, ...args]);
    }
    jsonbEachText(...args) {
        return sqlFunction("jsonb_each_text", [{ args: [(jsonb)], ret: Setof.ofSchema({ key: (default_1$1), value: (default_1$1) }), isOperator: false }], [this, ...args]);
    }
    jsonbEq(...args) {
        return sqlFunction("jsonb_eq", [{ args: [(jsonb), (jsonb)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    jsonbExists(...args) {
        return sqlFunction("jsonb_exists", [{ args: [(jsonb), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    jsonbExistsAll(...args) {
        return sqlFunction("jsonb_exists_all", [{ args: [(jsonb), Array$1.of((default_1$1))], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    jsonbExistsAny(...args) {
        return sqlFunction("jsonb_exists_any", [{ args: [(jsonb), Array$1.of((default_1$1))], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    jsonbExtractPath(...args) {
        return sqlFunction("jsonb_extract_path", [{ args: [(jsonb), Array$1.of((default_1$1))], ret: (jsonb), isOperator: false }], [this, ...args]);
    }
    jsonbExtractPathText(...args) {
        return sqlFunction("jsonb_extract_path_text", [{ args: [(jsonb), Array$1.of((default_1$1))], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    jsonbGe(...args) {
        return sqlFunction("jsonb_ge", [{ args: [(jsonb), (jsonb)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    jsonbGt(...args) {
        return sqlFunction("jsonb_gt", [{ args: [(jsonb), (jsonb)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    jsonbHash(...args) {
        return sqlFunction("jsonb_hash", [{ args: [(jsonb)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    jsonbHashExtended(...args) {
        return sqlFunction("jsonb_hash_extended", [{ args: [(jsonb), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    jsonbInsert(...args) {
        return sqlFunction("jsonb_insert", [{ args: [(jsonb), Array$1.of((default_1$1)), (jsonb), (default_1$8)], ret: (jsonb), isOperator: false }], [this, ...args]);
    }
    jsonbLe(...args) {
        return sqlFunction("jsonb_le", [{ args: [(jsonb), (jsonb)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    jsonbLt(...args) {
        return sqlFunction("jsonb_lt", [{ args: [(jsonb), (jsonb)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    jsonbNe(...args) {
        return sqlFunction("jsonb_ne", [{ args: [(jsonb), (jsonb)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    jsonbObjectField(...args) {
        return sqlFunction("jsonb_object_field", [{ args: [(jsonb), (default_1$1)], ret: (jsonb), isOperator: false }], [this, ...args]);
    }
    jsonbObjectFieldText(...args) {
        return sqlFunction("jsonb_object_field_text", [{ args: [(jsonb), (default_1$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    jsonbObjectKeys(...args) {
        return sqlFunction("jsonb_object_keys", [{ args: [(jsonb)], ret: Setof.ofSchema({}), isOperator: false }], [this, ...args]);
    }
    jsonbPathExists(...args) {
        return sqlFunction("jsonb_path_exists", [{ args: [(jsonb), (jsonpath), (jsonb), (default_1$8)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    jsonbPathExistsOpr(...args) {
        return sqlFunction("jsonb_path_exists_opr", [{ args: [(jsonb), (jsonpath)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    jsonbPathExistsTz(...args) {
        return sqlFunction("jsonb_path_exists_tz", [{ args: [(jsonb), (jsonpath), (jsonb), (default_1$8)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    jsonbPathMatch(...args) {
        return sqlFunction("jsonb_path_match", [{ args: [(jsonb), (jsonpath), (jsonb), (default_1$8)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    jsonbPathMatchOpr(...args) {
        return sqlFunction("jsonb_path_match_opr", [{ args: [(jsonb), (jsonpath)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    jsonbPathMatchTz(...args) {
        return sqlFunction("jsonb_path_match_tz", [{ args: [(jsonb), (jsonpath), (jsonb), (default_1$8)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    jsonbPathQuery(...args) {
        return sqlFunction("jsonb_path_query", [{ args: [(jsonb), (jsonpath), (jsonb), (default_1$8)], ret: Setof.ofSchema({}), isOperator: false }], [this, ...args]);
    }
    jsonbPathQueryArray(...args) {
        return sqlFunction("jsonb_path_query_array", [{ args: [(jsonb), (jsonpath), (jsonb), (default_1$8)], ret: (jsonb), isOperator: false }], [this, ...args]);
    }
    jsonbPathQueryArrayTz(...args) {
        return sqlFunction("jsonb_path_query_array_tz", [{ args: [(jsonb), (jsonpath), (jsonb), (default_1$8)], ret: (jsonb), isOperator: false }], [this, ...args]);
    }
    jsonbPathQueryFirst(...args) {
        return sqlFunction("jsonb_path_query_first", [{ args: [(jsonb), (jsonpath), (jsonb), (default_1$8)], ret: (jsonb), isOperator: false }], [this, ...args]);
    }
    jsonbPathQueryFirstTz(...args) {
        return sqlFunction("jsonb_path_query_first_tz", [{ args: [(jsonb), (jsonpath), (jsonb), (default_1$8)], ret: (jsonb), isOperator: false }], [this, ...args]);
    }
    jsonbPathQueryTz(...args) {
        return sqlFunction("jsonb_path_query_tz", [{ args: [(jsonb), (jsonpath), (jsonb), (default_1$8)], ret: Setof.ofSchema({}), isOperator: false }], [this, ...args]);
    }
    jsonbPretty(...args) {
        return sqlFunction("jsonb_pretty", [{ args: [(jsonb)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    jsonbSet(...args) {
        return sqlFunction("jsonb_set", [{ args: [(jsonb), Array$1.of((default_1$1)), (jsonb), (default_1$8)], ret: (jsonb), isOperator: false }], [this, ...args]);
    }
    jsonbSetLax(...args) {
        return sqlFunction("jsonb_set_lax", [{ args: [(jsonb), Array$1.of((default_1$1)), (jsonb), (default_1$8), (default_1$1)], ret: (jsonb), isOperator: false }], [this, ...args]);
    }
    jsonbStripNulls(...args) {
        return sqlFunction("jsonb_strip_nulls", [{ args: [(jsonb)], ret: (jsonb), isOperator: false }], [this, ...args]);
    }
    jsonbToRecord(...args) {
        return sqlFunction("jsonb_to_record", [({ R }) => ({ args: [(jsonb)], ret: Record.of(R), isOperator: false })], [this, ...args]);
    }
    jsonbToRecordset(...args) {
        return sqlFunction("jsonb_to_recordset", [{ args: [(jsonb)], ret: Setof.ofSchema({}), isOperator: false }], [this, ...args]);
    }
    jsonbToTsvector(...args) {
        return sqlFunction("jsonb_to_tsvector", [{ args: [(jsonb), (jsonb)], ret: (tsvector), isOperator: false }], [this, ...args]);
    }
    jsonbTypeof(...args) {
        return sqlFunction("jsonb_typeof", [{ args: [(jsonb)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    numeric(...args) {
        return sqlFunction("numeric", [{ args: [(jsonb)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    toTsvector(...args) {
        return sqlFunction("to_tsvector", [{ args: [(jsonb)], ret: (tsvector), isOperator: false }], [this, ...args]);
    }
    tsHeadline(...args) {
        return sqlFunction("ts_headline", [{ args: [(jsonb), (tsquery)], ret: (jsonb), isOperator: false }, { args: [(jsonb), (tsquery), (default_1$1)], ret: (jsonb), isOperator: false }], [this, ...args]);
    }
    ["->"](...args) {
        return sqlFunction("->", [{ args: [(jsonb), (default_1$4)], ret: (jsonb), isOperator: true }, { args: [(jsonb), (default_1$1)], ret: (jsonb), isOperator: true }], [this, ...args]);
    }
    ["->>"](...args) {
        return sqlFunction("->>", [{ args: [(jsonb), (default_1$4)], ret: (default_1$1), isOperator: true }, { args: [(jsonb), (default_1$1)], ret: (default_1$1), isOperator: true }], [this, ...args]);
    }
    ["@>"](...args) {
        return sqlFunction("@>", [{ args: [(jsonb), (jsonb)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["-"](...args) {
        return sqlFunction("-", [{ args: [(jsonb), Array$1.of((default_1$1))], ret: (jsonb), isOperator: true }, { args: [(jsonb), (default_1$4)], ret: (jsonb), isOperator: true }, { args: [(jsonb), (default_1$1)], ret: (jsonb), isOperator: true }], [this, ...args]);
    }
    ["#-"](...args) {
        return sqlFunction("#-", [{ args: [(jsonb), Array$1.of((default_1$1))], ret: (jsonb), isOperator: true }], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [{ args: [(jsonb), (jsonb)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["?"](...args) {
        return sqlFunction("?", [{ args: [(jsonb), (default_1$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["?&"](...args) {
        return sqlFunction("?&", [{ args: [(jsonb), Array$1.of((default_1$1))], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["?|"](...args) {
        return sqlFunction("?|", [{ args: [(jsonb), Array$1.of((default_1$1))], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["#>"](...args) {
        return sqlFunction("#>", [{ args: [(jsonb), Array$1.of((default_1$1))], ret: (jsonb), isOperator: true }], [this, ...args]);
    }
    ["#>>"](...args) {
        return sqlFunction("#>>", [{ args: [(jsonb), Array$1.of((default_1$1))], ret: (default_1$1), isOperator: true }], [this, ...args]);
    }
    [">="](...args) {
        return sqlFunction(">=", [{ args: [(jsonb), (jsonb)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">"](...args) {
        return sqlFunction(">", [{ args: [(jsonb), (jsonb)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<="](...args) {
        return sqlFunction("<=", [{ args: [(jsonb), (jsonb)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<"](...args) {
        return sqlFunction("<", [{ args: [(jsonb), (jsonb)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<>"](...args) {
        return sqlFunction("<>", [{ args: [(jsonb), (jsonb)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["@?"](...args) {
        return sqlFunction("@?", [{ args: [(jsonb), (jsonpath)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["@@"](...args) {
        return sqlFunction("@@", [{ args: [(jsonb), (jsonpath)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
}

class jsonpath extends Any {
    static new(v) { return new jsonpath(v); }
    static parse(v) { return v; }
    static typeString() { return "jsonpath"; }
    asAggregate() {
        return undefined;
    }
}

class language_handler extends Any {
    static new(v) { return new language_handler(v); }
    static parse(v) { return v; }
    static typeString() { return "language_handler"; }
    asAggregate() {
        return undefined;
    }
}

class line$1 extends Any {
    static new(v) { return new line$1(v); }
    static parse(v) { return v; }
    static typeString() { return "line"; }
    asAggregate() {
        return undefined;
    }
    closeLs(...args) {
        return sqlFunction("close_ls", [{ args: [(line$1), (lseg$1)], ret: (point$1), isOperator: false }], [this, ...args]);
    }
    distLp(...args) {
        return sqlFunction("dist_lp", [{ args: [(line$1), (point$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    distLs(...args) {
        return sqlFunction("dist_ls", [{ args: [(line$1), (lseg$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    interLb(...args) {
        return sqlFunction("inter_lb", [{ args: [(line$1), (box$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    ishorizontal(...args) {
        return sqlFunction("ishorizontal", [{ args: [(line$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    isparallel(...args) {
        return sqlFunction("isparallel", [{ args: [(line$1), (line$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    isperp(...args) {
        return sqlFunction("isperp", [{ args: [(line$1), (line$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    isvertical(...args) {
        return sqlFunction("isvertical", [{ args: [(line$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    lineDistance(...args) {
        return sqlFunction("line_distance", [{ args: [(line$1), (line$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    lineEq(...args) {
        return sqlFunction("line_eq", [{ args: [(line$1), (line$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    lineHorizontal(...args) {
        return sqlFunction("line_horizontal", [{ args: [(line$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    lineInterpt(...args) {
        return sqlFunction("line_interpt", [{ args: [(line$1), (line$1)], ret: (point$1), isOperator: false }], [this, ...args]);
    }
    lineIntersect(...args) {
        return sqlFunction("line_intersect", [{ args: [(line$1), (line$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    lineParallel(...args) {
        return sqlFunction("line_parallel", [{ args: [(line$1), (line$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    linePerp(...args) {
        return sqlFunction("line_perp", [{ args: [(line$1), (line$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    lineVertical(...args) {
        return sqlFunction("line_vertical", [{ args: [(line$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    ["##"](...args) {
        return sqlFunction("##", [{ args: [(line$1), (lseg$1)], ret: (point$1), isOperator: true }], [this, ...args]);
    }
    ["<->"](...args) {
        return sqlFunction("<->", [{ args: [(line$1), (point$1)], ret: (default_1$6), isOperator: true }, { args: [(line$1), (lseg$1)], ret: (default_1$6), isOperator: true }, { args: [(line$1), (line$1)], ret: (default_1$6), isOperator: true }], [this, ...args]);
    }
    ["?#"](...args) {
        return sqlFunction("?#", [{ args: [(line$1), (box$1)], ret: (default_1$8), isOperator: true }, { args: [(line$1), (line$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [{ args: [(line$1), (line$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["#"](...args) {
        return sqlFunction("#", [{ args: [(line$1), (line$1)], ret: (point$1), isOperator: true }], [this, ...args]);
    }
    ["?||"](...args) {
        return sqlFunction("?||", [{ args: [(line$1), (line$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["?-|"](...args) {
        return sqlFunction("?-|", [{ args: [(line$1), (line$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
}

class lseg$1 extends Any {
    static new(v) { return new lseg$1(v); }
    static parse(v) { return v; }
    static typeString() { return "lseg"; }
    asAggregate() {
        return undefined;
    }
    closeLseg(...args) {
        return sqlFunction("close_lseg", [{ args: [(lseg$1), (lseg$1)], ret: (point$1), isOperator: false }], [this, ...args]);
    }
    closeSb(...args) {
        return sqlFunction("close_sb", [{ args: [(lseg$1), (box$1)], ret: (point$1), isOperator: false }], [this, ...args]);
    }
    distSb(...args) {
        return sqlFunction("dist_sb", [{ args: [(lseg$1), (box$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    distSl(...args) {
        return sqlFunction("dist_sl", [{ args: [(lseg$1), (line$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    distSp(...args) {
        return sqlFunction("dist_sp", [{ args: [(lseg$1), (point$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    interSb(...args) {
        return sqlFunction("inter_sb", [{ args: [(lseg$1), (box$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    interSl(...args) {
        return sqlFunction("inter_sl", [{ args: [(lseg$1), (line$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    ishorizontal(...args) {
        return sqlFunction("ishorizontal", [{ args: [(lseg$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    isparallel(...args) {
        return sqlFunction("isparallel", [{ args: [(lseg$1), (lseg$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    isperp(...args) {
        return sqlFunction("isperp", [{ args: [(lseg$1), (lseg$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    isvertical(...args) {
        return sqlFunction("isvertical", [{ args: [(lseg$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    length(...args) {
        return sqlFunction("length", [{ args: [(lseg$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    lsegCenter(...args) {
        return sqlFunction("lseg_center", [{ args: [(lseg$1)], ret: (point$1), isOperator: false }], [this, ...args]);
    }
    lsegDistance(...args) {
        return sqlFunction("lseg_distance", [{ args: [(lseg$1), (lseg$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    lsegEq(...args) {
        return sqlFunction("lseg_eq", [{ args: [(lseg$1), (lseg$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    lsegGe(...args) {
        return sqlFunction("lseg_ge", [{ args: [(lseg$1), (lseg$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    lsegGt(...args) {
        return sqlFunction("lseg_gt", [{ args: [(lseg$1), (lseg$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    lsegHorizontal(...args) {
        return sqlFunction("lseg_horizontal", [{ args: [(lseg$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    lsegInterpt(...args) {
        return sqlFunction("lseg_interpt", [{ args: [(lseg$1), (lseg$1)], ret: (point$1), isOperator: false }], [this, ...args]);
    }
    lsegIntersect(...args) {
        return sqlFunction("lseg_intersect", [{ args: [(lseg$1), (lseg$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    lsegLe(...args) {
        return sqlFunction("lseg_le", [{ args: [(lseg$1), (lseg$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    lsegLength(...args) {
        return sqlFunction("lseg_length", [{ args: [(lseg$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    lsegLt(...args) {
        return sqlFunction("lseg_lt", [{ args: [(lseg$1), (lseg$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    lsegNe(...args) {
        return sqlFunction("lseg_ne", [{ args: [(lseg$1), (lseg$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    lsegParallel(...args) {
        return sqlFunction("lseg_parallel", [{ args: [(lseg$1), (lseg$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    lsegPerp(...args) {
        return sqlFunction("lseg_perp", [{ args: [(lseg$1), (lseg$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    lsegVertical(...args) {
        return sqlFunction("lseg_vertical", [{ args: [(lseg$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    onSb(...args) {
        return sqlFunction("on_sb", [{ args: [(lseg$1), (box$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    onSl(...args) {
        return sqlFunction("on_sl", [{ args: [(lseg$1), (line$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    point(...args) {
        return sqlFunction("point", [{ args: [(lseg$1)], ret: (point$1), isOperator: false }], [this, ...args]);
    }
    ["##"](...args) {
        return sqlFunction("##", [{ args: [(lseg$1), (lseg$1)], ret: (point$1), isOperator: true }, { args: [(lseg$1), (box$1)], ret: (point$1), isOperator: true }], [this, ...args]);
    }
    ["<->"](...args) {
        return sqlFunction("<->", [{ args: [(lseg$1), (box$1)], ret: (default_1$6), isOperator: true }, { args: [(lseg$1), (line$1)], ret: (default_1$6), isOperator: true }, { args: [(lseg$1), (point$1)], ret: (default_1$6), isOperator: true }, { args: [(lseg$1), (lseg$1)], ret: (default_1$6), isOperator: true }], [this, ...args]);
    }
    ["?#"](...args) {
        return sqlFunction("?#", [{ args: [(lseg$1), (box$1)], ret: (default_1$8), isOperator: true }, { args: [(lseg$1), (line$1)], ret: (default_1$8), isOperator: true }, { args: [(lseg$1), (lseg$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [{ args: [(lseg$1), (lseg$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">="](...args) {
        return sqlFunction(">=", [{ args: [(lseg$1), (lseg$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">"](...args) {
        return sqlFunction(">", [{ args: [(lseg$1), (lseg$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["#"](...args) {
        return sqlFunction("#", [{ args: [(lseg$1), (lseg$1)], ret: (point$1), isOperator: true }], [this, ...args]);
    }
    ["<="](...args) {
        return sqlFunction("<=", [{ args: [(lseg$1), (lseg$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<"](...args) {
        return sqlFunction("<", [{ args: [(lseg$1), (lseg$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<>"](...args) {
        return sqlFunction("<>", [{ args: [(lseg$1), (lseg$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["?||"](...args) {
        return sqlFunction("?||", [{ args: [(lseg$1), (lseg$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["?-|"](...args) {
        return sqlFunction("?-|", [{ args: [(lseg$1), (lseg$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
}

class macaddr$1 extends Any {
    static new(v) { return new macaddr$1(v); }
    static parse(v) { return v; }
    static typeString() { return "macaddr"; }
    asAggregate() {
        return undefined;
    }
    hashmacaddr(...args) {
        return sqlFunction("hashmacaddr", [{ args: [(macaddr$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    hashmacaddrextended(...args) {
        return sqlFunction("hashmacaddrextended", [{ args: [(macaddr$1), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    macaddr8(...args) {
        return sqlFunction("macaddr8", [{ args: [(macaddr$1)], ret: (macaddr8$1), isOperator: false }], [this, ...args]);
    }
    macaddrAnd(...args) {
        return sqlFunction("macaddr_and", [{ args: [(macaddr$1), (macaddr$1)], ret: (macaddr$1), isOperator: false }], [this, ...args]);
    }
    macaddrCmp(...args) {
        return sqlFunction("macaddr_cmp", [{ args: [(macaddr$1), (macaddr$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    macaddrEq(...args) {
        return sqlFunction("macaddr_eq", [{ args: [(macaddr$1), (macaddr$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    macaddrGe(...args) {
        return sqlFunction("macaddr_ge", [{ args: [(macaddr$1), (macaddr$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    macaddrGt(...args) {
        return sqlFunction("macaddr_gt", [{ args: [(macaddr$1), (macaddr$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    macaddrLe(...args) {
        return sqlFunction("macaddr_le", [{ args: [(macaddr$1), (macaddr$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    macaddrLt(...args) {
        return sqlFunction("macaddr_lt", [{ args: [(macaddr$1), (macaddr$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    macaddrNe(...args) {
        return sqlFunction("macaddr_ne", [{ args: [(macaddr$1), (macaddr$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    macaddrNot(...args) {
        return sqlFunction("macaddr_not", [{ args: [(macaddr$1)], ret: (macaddr$1), isOperator: false }], [this, ...args]);
    }
    macaddrOr(...args) {
        return sqlFunction("macaddr_or", [{ args: [(macaddr$1), (macaddr$1)], ret: (macaddr$1), isOperator: false }], [this, ...args]);
    }
    trunc(...args) {
        return sqlFunction("trunc", [{ args: [(macaddr$1)], ret: (macaddr$1), isOperator: false }], [this, ...args]);
    }
    ["&"](...args) {
        return sqlFunction("&", [{ args: [(macaddr$1), (macaddr$1)], ret: (macaddr$1), isOperator: true }], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [{ args: [(macaddr$1), (macaddr$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">="](...args) {
        return sqlFunction(">=", [{ args: [(macaddr$1), (macaddr$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">"](...args) {
        return sqlFunction(">", [{ args: [(macaddr$1), (macaddr$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<="](...args) {
        return sqlFunction("<=", [{ args: [(macaddr$1), (macaddr$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<"](...args) {
        return sqlFunction("<", [{ args: [(macaddr$1), (macaddr$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<>"](...args) {
        return sqlFunction("<>", [{ args: [(macaddr$1), (macaddr$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["|"](...args) {
        return sqlFunction("|", [{ args: [(macaddr$1), (macaddr$1)], ret: (macaddr$1), isOperator: true }], [this, ...args]);
    }
}

class macaddr8$1 extends Any {
    static new(v) { return new macaddr8$1(v); }
    static parse(v) { return v; }
    static typeString() { return "macaddr8"; }
    asAggregate() {
        return undefined;
    }
    hashmacaddr8(...args) {
        return sqlFunction("hashmacaddr8", [{ args: [(macaddr8$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    hashmacaddr8Extended(...args) {
        return sqlFunction("hashmacaddr8extended", [{ args: [(macaddr8$1), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    macaddr(...args) {
        return sqlFunction("macaddr", [{ args: [(macaddr8$1)], ret: (macaddr$1), isOperator: false }], [this, ...args]);
    }
    macaddr8And(...args) {
        return sqlFunction("macaddr8_and", [{ args: [(macaddr8$1), (macaddr8$1)], ret: (macaddr8$1), isOperator: false }], [this, ...args]);
    }
    macaddr8Cmp(...args) {
        return sqlFunction("macaddr8_cmp", [{ args: [(macaddr8$1), (macaddr8$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    macaddr8Eq(...args) {
        return sqlFunction("macaddr8_eq", [{ args: [(macaddr8$1), (macaddr8$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    macaddr8Ge(...args) {
        return sqlFunction("macaddr8_ge", [{ args: [(macaddr8$1), (macaddr8$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    macaddr8Gt(...args) {
        return sqlFunction("macaddr8_gt", [{ args: [(macaddr8$1), (macaddr8$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    macaddr8Le(...args) {
        return sqlFunction("macaddr8_le", [{ args: [(macaddr8$1), (macaddr8$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    macaddr8Lt(...args) {
        return sqlFunction("macaddr8_lt", [{ args: [(macaddr8$1), (macaddr8$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    macaddr8Ne(...args) {
        return sqlFunction("macaddr8_ne", [{ args: [(macaddr8$1), (macaddr8$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    macaddr8Not(...args) {
        return sqlFunction("macaddr8_not", [{ args: [(macaddr8$1)], ret: (macaddr8$1), isOperator: false }], [this, ...args]);
    }
    macaddr8Or(...args) {
        return sqlFunction("macaddr8_or", [{ args: [(macaddr8$1), (macaddr8$1)], ret: (macaddr8$1), isOperator: false }], [this, ...args]);
    }
    macaddr8Set7Bit(...args) {
        return sqlFunction("macaddr8_set7bit", [{ args: [(macaddr8$1)], ret: (macaddr8$1), isOperator: false }], [this, ...args]);
    }
    trunc(...args) {
        return sqlFunction("trunc", [{ args: [(macaddr8$1)], ret: (macaddr8$1), isOperator: false }], [this, ...args]);
    }
    ["&"](...args) {
        return sqlFunction("&", [{ args: [(macaddr8$1), (macaddr8$1)], ret: (macaddr8$1), isOperator: true }], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [{ args: [(macaddr8$1), (macaddr8$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">="](...args) {
        return sqlFunction(">=", [{ args: [(macaddr8$1), (macaddr8$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">"](...args) {
        return sqlFunction(">", [{ args: [(macaddr8$1), (macaddr8$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<="](...args) {
        return sqlFunction("<=", [{ args: [(macaddr8$1), (macaddr8$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<"](...args) {
        return sqlFunction("<", [{ args: [(macaddr8$1), (macaddr8$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<>"](...args) {
        return sqlFunction("<>", [{ args: [(macaddr8$1), (macaddr8$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["|"](...args) {
        return sqlFunction("|", [{ args: [(macaddr8$1), (macaddr8$1)], ret: (macaddr8$1), isOperator: true }], [this, ...args]);
    }
}

class money$1 extends Any {
    static new(v) { return new money$1(v); }
    static parse(v) { return v; }
    static typeString() { return "money"; }
    asAggregate() {
        return undefined;
    }
    cashCmp(...args) {
        return sqlFunction("cash_cmp", [{ args: [(money$1), (money$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    cashDivCash(...args) {
        return sqlFunction("cash_div_cash", [{ args: [(money$1), (money$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    cashDivFlt4(...args) {
        return sqlFunction("cash_div_flt4", [{ args: [(money$1), (default_1$7)], ret: (money$1), isOperator: false }], [this, ...args]);
    }
    cashDivFlt8(...args) {
        return sqlFunction("cash_div_flt8", [{ args: [(money$1), (default_1$6)], ret: (money$1), isOperator: false }], [this, ...args]);
    }
    cashDivInt2(...args) {
        return sqlFunction("cash_div_int2", [{ args: [(money$1), (default_1$5)], ret: (money$1), isOperator: false }], [this, ...args]);
    }
    cashDivInt4(...args) {
        return sqlFunction("cash_div_int4", [{ args: [(money$1), (default_1$4)], ret: (money$1), isOperator: false }], [this, ...args]);
    }
    cashDivInt8(...args) {
        return sqlFunction("cash_div_int8", [{ args: [(money$1), (default_1$3)], ret: (money$1), isOperator: false }], [this, ...args]);
    }
    cashEq(...args) {
        return sqlFunction("cash_eq", [{ args: [(money$1), (money$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    cashGe(...args) {
        return sqlFunction("cash_ge", [{ args: [(money$1), (money$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    cashGt(...args) {
        return sqlFunction("cash_gt", [{ args: [(money$1), (money$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    cashLe(...args) {
        return sqlFunction("cash_le", [{ args: [(money$1), (money$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    cashLt(...args) {
        return sqlFunction("cash_lt", [{ args: [(money$1), (money$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    cashMi(...args) {
        return sqlFunction("cash_mi", [{ args: [(money$1), (money$1)], ret: (money$1), isOperator: false }], [this, ...args]);
    }
    cashMulFlt4(...args) {
        return sqlFunction("cash_mul_flt4", [{ args: [(money$1), (default_1$7)], ret: (money$1), isOperator: false }], [this, ...args]);
    }
    cashMulFlt8(...args) {
        return sqlFunction("cash_mul_flt8", [{ args: [(money$1), (default_1$6)], ret: (money$1), isOperator: false }], [this, ...args]);
    }
    cashMulInt2(...args) {
        return sqlFunction("cash_mul_int2", [{ args: [(money$1), (default_1$5)], ret: (money$1), isOperator: false }], [this, ...args]);
    }
    cashMulInt4(...args) {
        return sqlFunction("cash_mul_int4", [{ args: [(money$1), (default_1$4)], ret: (money$1), isOperator: false }], [this, ...args]);
    }
    cashMulInt8(...args) {
        return sqlFunction("cash_mul_int8", [{ args: [(money$1), (default_1$3)], ret: (money$1), isOperator: false }], [this, ...args]);
    }
    cashNe(...args) {
        return sqlFunction("cash_ne", [{ args: [(money$1), (money$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    cashPl(...args) {
        return sqlFunction("cash_pl", [{ args: [(money$1), (money$1)], ret: (money$1), isOperator: false }], [this, ...args]);
    }
    cashWords(...args) {
        return sqlFunction("cash_words", [{ args: [(money$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    cashlarger(...args) {
        return sqlFunction("cashlarger", [{ args: [(money$1), (money$1)], ret: (money$1), isOperator: false }], [this, ...args]);
    }
    cashsmaller(...args) {
        return sqlFunction("cashsmaller", [{ args: [(money$1), (money$1)], ret: (money$1), isOperator: false }], [this, ...args]);
    }
    max(...args) {
        return sqlFunction("max", [{ args: [(money$1)], ret: (money$1), isOperator: false }], [this, ...args]);
    }
    numeric(...args) {
        return sqlFunction("numeric", [{ args: [(money$1)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    sum(...args) {
        return sqlFunction("sum", [{ args: [(money$1)], ret: (money$1), isOperator: false }], [this, ...args]);
    }
    ["/"](...args) {
        return sqlFunction("/", [{ args: [(money$1), (money$1)], ret: (default_1$6), isOperator: true }, { args: [(money$1), (default_1$7)], ret: (money$1), isOperator: true }, { args: [(money$1), (default_1$6)], ret: (money$1), isOperator: true }, { args: [(money$1), (default_1$5)], ret: (money$1), isOperator: true }, { args: [(money$1), (default_1$4)], ret: (money$1), isOperator: true }, { args: [(money$1), (default_1$3)], ret: (money$1), isOperator: true }], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [{ args: [(money$1), (money$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">="](...args) {
        return sqlFunction(">=", [{ args: [(money$1), (money$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">"](...args) {
        return sqlFunction(">", [{ args: [(money$1), (money$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<="](...args) {
        return sqlFunction("<=", [{ args: [(money$1), (money$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<"](...args) {
        return sqlFunction("<", [{ args: [(money$1), (money$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["-"](...args) {
        return sqlFunction("-", [{ args: [(money$1), (money$1)], ret: (money$1), isOperator: true }], [this, ...args]);
    }
    ["*"](...args) {
        return sqlFunction("*", [{ args: [(money$1), (default_1$7)], ret: (money$1), isOperator: true }, { args: [(money$1), (default_1$6)], ret: (money$1), isOperator: true }, { args: [(money$1), (default_1$5)], ret: (money$1), isOperator: true }, { args: [(money$1), (default_1$4)], ret: (money$1), isOperator: true }, { args: [(money$1), (default_1$3)], ret: (money$1), isOperator: true }], [this, ...args]);
    }
    ["<>"](...args) {
        return sqlFunction("<>", [{ args: [(money$1), (money$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["+"](...args) {
        return sqlFunction("+", [{ args: [(money$1), (money$1)], ret: (money$1), isOperator: true }], [this, ...args]);
    }
}

class name$1 extends Any {
    static new(v) { return new name$1(v); }
    static parse(v) { return v; }
    static typeString() { return "name"; }
    asAggregate() {
        return undefined;
    }
    binaryUpgradeLogicalSlotHasCaughtUp(...args) {
        return sqlFunction("binary_upgrade_logical_slot_has_caught_up", [{ args: [(name$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    bpchar(...args) {
        return sqlFunction("bpchar", [{ args: [(name$1)], ret: (bpchar$1), isOperator: false }], [this, ...args]);
    }
    btnamecmp(...args) {
        return sqlFunction("btnamecmp", [{ args: [(name$1), (name$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    btnametextcmp(...args) {
        return sqlFunction("btnametextcmp", [{ args: [(name$1), (default_1$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    hasAnyColumnPrivilege(...args) {
        return sqlFunction("has_any_column_privilege", [{ args: [(name$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(name$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    hasColumnPrivilege(...args) {
        return sqlFunction("has_column_privilege", [{ args: [(name$1), (oid$1), (default_1$5), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(name$1), (oid$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(name$1), (default_1$1), (default_1$5), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(name$1), (default_1$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    hasDatabasePrivilege(...args) {
        return sqlFunction("has_database_privilege", [{ args: [(name$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(name$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    hasForeignDataWrapperPrivilege(...args) {
        return sqlFunction("has_foreign_data_wrapper_privilege", [{ args: [(name$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(name$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    hasFunctionPrivilege(...args) {
        return sqlFunction("has_function_privilege", [{ args: [(name$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(name$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    hasLanguagePrivilege(...args) {
        return sqlFunction("has_language_privilege", [{ args: [(name$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(name$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    hasParameterPrivilege(...args) {
        return sqlFunction("has_parameter_privilege", [{ args: [(name$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    hasSchemaPrivilege(...args) {
        return sqlFunction("has_schema_privilege", [{ args: [(name$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(name$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    hasSequencePrivilege(...args) {
        return sqlFunction("has_sequence_privilege", [{ args: [(name$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(name$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    hasServerPrivilege(...args) {
        return sqlFunction("has_server_privilege", [{ args: [(name$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(name$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    hasTablePrivilege(...args) {
        return sqlFunction("has_table_privilege", [{ args: [(name$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(name$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    hasTablespacePrivilege(...args) {
        return sqlFunction("has_tablespace_privilege", [{ args: [(name$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(name$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    hasTypePrivilege(...args) {
        return sqlFunction("has_type_privilege", [{ args: [(name$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(name$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    hashname(...args) {
        return sqlFunction("hashname", [{ args: [(name$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    hashnameextended(...args) {
        return sqlFunction("hashnameextended", [{ args: [(name$1), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    like(...args) {
        return sqlFunction("like", [{ args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    nameconcatoid(...args) {
        return sqlFunction("nameconcatoid", [{ args: [(name$1), (oid$1)], ret: (name$1), isOperator: false }], [this, ...args]);
    }
    nameeq(...args) {
        return sqlFunction("nameeq", [{ args: [(name$1), (name$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    nameeqtext(...args) {
        return sqlFunction("nameeqtext", [{ args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    namege(...args) {
        return sqlFunction("namege", [{ args: [(name$1), (name$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    namegetext(...args) {
        return sqlFunction("namegetext", [{ args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    namegt(...args) {
        return sqlFunction("namegt", [{ args: [(name$1), (name$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    namegttext(...args) {
        return sqlFunction("namegttext", [{ args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    nameiclike(...args) {
        return sqlFunction("nameiclike", [{ args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    nameicnlike(...args) {
        return sqlFunction("nameicnlike", [{ args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    nameicregexeq(...args) {
        return sqlFunction("nameicregexeq", [{ args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    nameicregexne(...args) {
        return sqlFunction("nameicregexne", [{ args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    namele(...args) {
        return sqlFunction("namele", [{ args: [(name$1), (name$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    nameletext(...args) {
        return sqlFunction("nameletext", [{ args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    namelike(...args) {
        return sqlFunction("namelike", [{ args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    namelt(...args) {
        return sqlFunction("namelt", [{ args: [(name$1), (name$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    namelttext(...args) {
        return sqlFunction("namelttext", [{ args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    namene(...args) {
        return sqlFunction("namene", [{ args: [(name$1), (name$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    namenetext(...args) {
        return sqlFunction("namenetext", [{ args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    namenlike(...args) {
        return sqlFunction("namenlike", [{ args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    nameregexeq(...args) {
        return sqlFunction("nameregexeq", [{ args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    nameregexne(...args) {
        return sqlFunction("nameregexne", [{ args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    notlike(...args) {
        return sqlFunction("notlike", [{ args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgCharToEncoding(...args) {
        return sqlFunction("pg_char_to_encoding", [{ args: [(name$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    pgCopyLogicalReplicationSlot(...args) {
        return sqlFunction("pg_copy_logical_replication_slot", [{ args: [(name$1), (name$1)], ret: Record.of({ slot_name: (name$1), lsn: (pg_lsn) }), isOperator: false }, { args: [(name$1), (name$1), (default_1$8)], ret: Record.of({ slot_name: (name$1), lsn: (pg_lsn) }), isOperator: false }, { args: [(name$1), (name$1), (default_1$8), (name$1)], ret: Record.of({ slot_name: (name$1), lsn: (pg_lsn) }), isOperator: false }], [this, ...args]);
    }
    pgCopyPhysicalReplicationSlot(...args) {
        return sqlFunction("pg_copy_physical_replication_slot", [{ args: [(name$1), (name$1)], ret: Record.of({ slot_name: (name$1), lsn: (pg_lsn) }), isOperator: false }, { args: [(name$1), (name$1), (default_1$8)], ret: Record.of({ slot_name: (name$1), lsn: (pg_lsn) }), isOperator: false }], [this, ...args]);
    }
    pgCreateLogicalReplicationSlot(...args) {
        return sqlFunction("pg_create_logical_replication_slot", [{ args: [(name$1), (name$1), (default_1$8), (default_1$8), (default_1$8)], ret: Record.of({ slot_name: (name$1), lsn: (pg_lsn) }), isOperator: false }], [this, ...args]);
    }
    pgCreatePhysicalReplicationSlot(...args) {
        return sqlFunction("pg_create_physical_replication_slot", [{ args: [(name$1), (default_1$8), (default_1$8)], ret: Record.of({ slot_name: (name$1), lsn: (pg_lsn) }), isOperator: false }], [this, ...args]);
    }
    pgDatabaseSize(...args) {
        return sqlFunction("pg_database_size", [{ args: [(name$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgDropReplicationSlot(...args) {
        return sqlFunction("pg_drop_replication_slot", [{ args: [(name$1)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    pgExtensionUpdatePaths(...args) {
        return sqlFunction("pg_extension_update_paths", [{ args: [(name$1)], ret: Setof.ofSchema({ source: (default_1$1), target: (default_1$1), path: (default_1$1) }), isOperator: false }], [this, ...args]);
    }
    pgHasRole(...args) {
        return sqlFunction("pg_has_role", [{ args: [(name$1), (name$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(name$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgLogicalSlotGetBinaryChanges(...args) {
        return sqlFunction("pg_logical_slot_get_binary_changes", [{ args: [(name$1), (pg_lsn), (default_1$4), Array$1.of((default_1$1))], ret: Setof.ofSchema({ lsn: (pg_lsn), xid: (xid$1), data: (bytea) }), isOperator: false }], [this, ...args]);
    }
    pgLogicalSlotGetChanges(...args) {
        return sqlFunction("pg_logical_slot_get_changes", [{ args: [(name$1), (pg_lsn), (default_1$4), Array$1.of((default_1$1))], ret: Setof.ofSchema({ lsn: (pg_lsn), xid: (xid$1), data: (default_1$1) }), isOperator: false }], [this, ...args]);
    }
    pgLogicalSlotPeekBinaryChanges(...args) {
        return sqlFunction("pg_logical_slot_peek_binary_changes", [{ args: [(name$1), (pg_lsn), (default_1$4), Array$1.of((default_1$1))], ret: Setof.ofSchema({ lsn: (pg_lsn), xid: (xid$1), data: (bytea) }), isOperator: false }], [this, ...args]);
    }
    pgLogicalSlotPeekChanges(...args) {
        return sqlFunction("pg_logical_slot_peek_changes", [{ args: [(name$1), (pg_lsn), (default_1$4), Array$1.of((default_1$1))], ret: Setof.ofSchema({ lsn: (pg_lsn), xid: (xid$1), data: (default_1$1) }), isOperator: false }], [this, ...args]);
    }
    pgReplicationSlotAdvance(...args) {
        return sqlFunction("pg_replication_slot_advance", [{ args: [(name$1), (pg_lsn)], ret: Record.of({ slot_name: (name$1), end_lsn: (pg_lsn) }), isOperator: false }], [this, ...args]);
    }
    pgTablespaceSize(...args) {
        return sqlFunction("pg_tablespace_size", [{ args: [(name$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    schemaToXml(...args) {
        return sqlFunction("schema_to_xml", [{ args: [(name$1), (default_1$8), (default_1$8), (default_1$1)], ret: (xml$1), isOperator: false }], [this, ...args]);
    }
    schemaToXmlAndXmlschema(...args) {
        return sqlFunction("schema_to_xml_and_xmlschema", [{ args: [(name$1), (default_1$8), (default_1$8), (default_1$1)], ret: (xml$1), isOperator: false }], [this, ...args]);
    }
    schemaToXmlschema(...args) {
        return sqlFunction("schema_to_xmlschema", [{ args: [(name$1), (default_1$8), (default_1$8), (default_1$1)], ret: (xml$1), isOperator: false }], [this, ...args]);
    }
    text(...args) {
        return sqlFunction("text", [{ args: [(name$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    varchar(...args) {
        return sqlFunction("varchar", [{ args: [(name$1)], ret: (varchar$1), isOperator: false }], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [{ args: [(name$1), (name$1)], ret: (default_1$8), isOperator: true }, { args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">="](...args) {
        return sqlFunction(">=", [{ args: [(name$1), (name$1)], ret: (default_1$8), isOperator: true }, { args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">"](...args) {
        return sqlFunction(">", [{ args: [(name$1), (name$1)], ret: (default_1$8), isOperator: true }, { args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["~~*"](...args) {
        return sqlFunction("~~*", [{ args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["!~~*"](...args) {
        return sqlFunction("!~~*", [{ args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["~*"](...args) {
        return sqlFunction("~*", [{ args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["!~*"](...args) {
        return sqlFunction("!~*", [{ args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<="](...args) {
        return sqlFunction("<=", [{ args: [(name$1), (name$1)], ret: (default_1$8), isOperator: true }, { args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["~~"](...args) {
        return sqlFunction("~~", [{ args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<"](...args) {
        return sqlFunction("<", [{ args: [(name$1), (name$1)], ret: (default_1$8), isOperator: true }, { args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<>"](...args) {
        return sqlFunction("<>", [{ args: [(name$1), (name$1)], ret: (default_1$8), isOperator: true }, { args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["!~~"](...args) {
        return sqlFunction("!~~", [{ args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["~"](...args) {
        return sqlFunction("~", [{ args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["!~"](...args) {
        return sqlFunction("!~", [{ args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
}

let default_1$2 = class default_1 extends Any {
    static new(v) { return new default_1$2(v); }
    static serializeParamTypes = undefined;
    static parse(v) { return typeMap["numeric"].parse(v); }
    static typeString() { return "numeric"; }
    asAggregate() {
        return undefined;
    }
    abs(...args) {
        return sqlFunction("abs", [{ args: [(default_1$2)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    avg(...args) {
        return sqlFunction("avg", [{ args: [(default_1$2)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    ceil(...args) {
        return sqlFunction("ceil", [{ args: [(default_1$2)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    ceiling(...args) {
        return sqlFunction("ceiling", [{ args: [(default_1$2)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    div(...args) {
        return sqlFunction("div", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    exp(...args) {
        return sqlFunction("exp", [{ args: [(default_1$2)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    float4(...args) {
        return sqlFunction("float4", [{ args: [(default_1$2)], ret: (default_1$7), isOperator: false }], [this, ...args]);
    }
    float8(...args) {
        return sqlFunction("float8", [{ args: [(default_1$2)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    floor(...args) {
        return sqlFunction("floor", [{ args: [(default_1$2)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    gcd(...args) {
        return sqlFunction("gcd", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    generateSeries(...args) {
        return sqlFunction("generate_series", [{ args: [(default_1$2), (default_1$2)], ret: Setof.ofSchema({}), isOperator: false }, { args: [(default_1$2), (default_1$2), (default_1$2)], ret: Setof.ofSchema({}), isOperator: false }], [this, ...args]);
    }
    hashNumeric(...args) {
        return sqlFunction("hash_numeric", [{ args: [(default_1$2)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    hashNumericExtended(...args) {
        return sqlFunction("hash_numeric_extended", [{ args: [(default_1$2), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    inRange(...args) {
        return sqlFunction("in_range", [{ args: [(default_1$2), (default_1$2), (default_1$2), (default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    int2(...args) {
        return sqlFunction("int2", [{ args: [(default_1$2)], ret: (default_1$5), isOperator: false }], [this, ...args]);
    }
    int4(...args) {
        return sqlFunction("int4", [{ args: [(default_1$2)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    int8(...args) {
        return sqlFunction("int8", [{ args: [(default_1$2)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    int8Sum(...args) {
        return sqlFunction("int8_sum", [{ args: [(default_1$2), (default_1$3)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    lcm(...args) {
        return sqlFunction("lcm", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    ln(...args) {
        return sqlFunction("ln", [{ args: [(default_1$2)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    log(...args) {
        return sqlFunction("log", [{ args: [(default_1$2)], ret: (default_1$2), isOperator: false }, { args: [(default_1$2), (default_1$2)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    log10(...args) {
        return sqlFunction("log10", [{ args: [(default_1$2)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    max(...args) {
        return sqlFunction("max", [{ args: [(default_1$2)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    minScale(...args) {
        return sqlFunction("min_scale", [{ args: [(default_1$2)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    mod(...args) {
        return sqlFunction("mod", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    money(...args) {
        return sqlFunction("money", [{ args: [(default_1$2)], ret: (money$1), isOperator: false }], [this, ...args]);
    }
    numeric(...args) {
        return sqlFunction("numeric", [{ args: [(default_1$2), (default_1$4)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    numericAbs(...args) {
        return sqlFunction("numeric_abs", [{ args: [(default_1$2)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    numericAdd(...args) {
        return sqlFunction("numeric_add", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    numericCmp(...args) {
        return sqlFunction("numeric_cmp", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    numericDiv(...args) {
        return sqlFunction("numeric_div", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    numericDivTrunc(...args) {
        return sqlFunction("numeric_div_trunc", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    numericEq(...args) {
        return sqlFunction("numeric_eq", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    numericExp(...args) {
        return sqlFunction("numeric_exp", [{ args: [(default_1$2)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    numericGe(...args) {
        return sqlFunction("numeric_ge", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    numericGt(...args) {
        return sqlFunction("numeric_gt", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    numericInc(...args) {
        return sqlFunction("numeric_inc", [{ args: [(default_1$2)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    numericLarger(...args) {
        return sqlFunction("numeric_larger", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    numericLe(...args) {
        return sqlFunction("numeric_le", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    numericLn(...args) {
        return sqlFunction("numeric_ln", [{ args: [(default_1$2)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    numericLog(...args) {
        return sqlFunction("numeric_log", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    numericLt(...args) {
        return sqlFunction("numeric_lt", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    numericMod(...args) {
        return sqlFunction("numeric_mod", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    numericMul(...args) {
        return sqlFunction("numeric_mul", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    numericNe(...args) {
        return sqlFunction("numeric_ne", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    numericPlPgLsn(...args) {
        return sqlFunction("numeric_pl_pg_lsn", [{ args: [(default_1$2), (pg_lsn)], ret: (pg_lsn), isOperator: false }], [this, ...args]);
    }
    numericPower(...args) {
        return sqlFunction("numeric_power", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    numericSmaller(...args) {
        return sqlFunction("numeric_smaller", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    numericSqrt(...args) {
        return sqlFunction("numeric_sqrt", [{ args: [(default_1$2)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    numericSub(...args) {
        return sqlFunction("numeric_sub", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    numericUminus(...args) {
        return sqlFunction("numeric_uminus", [{ args: [(default_1$2)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    numericUplus(...args) {
        return sqlFunction("numeric_uplus", [{ args: [(default_1$2)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    numrange(...args) {
        return sqlFunction("numrange", [{ args: [(default_1$2), (default_1$2)], ret: (numrange$1), isOperator: false }, { args: [(default_1$2), (default_1$2), (default_1$1)], ret: (numrange$1), isOperator: false }], [this, ...args]);
    }
    numrangeSubdiff(...args) {
        return sqlFunction("numrange_subdiff", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    pgLsn(...args) {
        return sqlFunction("pg_lsn", [{ args: [(default_1$2)], ret: (pg_lsn), isOperator: false }], [this, ...args]);
    }
    pgSizePretty(...args) {
        return sqlFunction("pg_size_pretty", [{ args: [(default_1$2)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    pow(...args) {
        return sqlFunction("pow", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    power(...args) {
        return sqlFunction("power", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    random(...args) {
        return sqlFunction("random", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    round(...args) {
        return sqlFunction("round", [{ args: [(default_1$2)], ret: (default_1$2), isOperator: false }, { args: [(default_1$2), (default_1$4)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    scale(...args) {
        return sqlFunction("scale", [{ args: [(default_1$2)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    sign(...args) {
        return sqlFunction("sign", [{ args: [(default_1$2)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    sqrt(...args) {
        return sqlFunction("sqrt", [{ args: [(default_1$2)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    stddev(...args) {
        return sqlFunction("stddev", [{ args: [(default_1$2)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    stddevPop(...args) {
        return sqlFunction("stddev_pop", [{ args: [(default_1$2)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    stddevSamp(...args) {
        return sqlFunction("stddev_samp", [{ args: [(default_1$2)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    sum(...args) {
        return sqlFunction("sum", [{ args: [(default_1$2)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    toChar(...args) {
        return sqlFunction("to_char", [{ args: [(default_1$2), (default_1$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    trimScale(...args) {
        return sqlFunction("trim_scale", [{ args: [(default_1$2)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    trunc(...args) {
        return sqlFunction("trunc", [{ args: [(default_1$2)], ret: (default_1$2), isOperator: false }, { args: [(default_1$2), (default_1$4)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    varPop(...args) {
        return sqlFunction("var_pop", [{ args: [(default_1$2)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    varSamp(...args) {
        return sqlFunction("var_samp", [{ args: [(default_1$2)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    variance(...args) {
        return sqlFunction("variance", [{ args: [(default_1$2)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    ["+"](...args) {
        return sqlFunction("+", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$2), isOperator: true }, { args: [(default_1$2), (pg_lsn)], ret: (pg_lsn), isOperator: true }], [this, ...args]);
    }
    ["/"](...args) {
        return sqlFunction("/", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$2), isOperator: true }], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">="](...args) {
        return sqlFunction(">=", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">"](...args) {
        return sqlFunction(">", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<="](...args) {
        return sqlFunction("<=", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<"](...args) {
        return sqlFunction("<", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["%"](...args) {
        return sqlFunction("%", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$2), isOperator: true }], [this, ...args]);
    }
    ["*"](...args) {
        return sqlFunction("*", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$2), isOperator: true }], [this, ...args]);
    }
    ["<>"](...args) {
        return sqlFunction("<>", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["^"](...args) {
        return sqlFunction("^", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$2), isOperator: true }], [this, ...args]);
    }
    ["-"](...args) {
        return sqlFunction("-", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$2), isOperator: true }], [this, ...args]);
    }
};

class nummultirange$1 extends Any {
    static new(v) { return new nummultirange$1(v); }
    static parse(v) { return v; }
    static typeString() { return "nummultirange"; }
    asAggregate() {
        return undefined;
    }
}

class numrange$1 extends Any {
    static new(v) { return new numrange$1(v); }
    static parse(v) { return v; }
    static typeString() { return "numrange"; }
    asAggregate() {
        return undefined;
    }
    nummultirange(...args) {
        return sqlFunction("nummultirange", [{ args: [(numrange$1)], ret: (nummultirange$1), isOperator: false }], [this, ...args]);
    }
}

class oid$1 extends Any {
    static new(v) { return new oid$1(v); }
    static parse(v) { return v; }
    static typeString() { return "oid"; }
    asAggregate() {
        return undefined;
    }
    amvalidate(...args) {
        return sqlFunction("amvalidate", [{ args: [(oid$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    binaryUpgradeSetMissingValue(...args) {
        return sqlFunction("binary_upgrade_set_missing_value", [{ args: [(oid$1), (default_1$1), (default_1$1)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    binaryUpgradeSetNextArrayPgTypeOid(...args) {
        return sqlFunction("binary_upgrade_set_next_array_pg_type_oid", [{ args: [(oid$1)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    binaryUpgradeSetNextHeapPgClassOid(...args) {
        return sqlFunction("binary_upgrade_set_next_heap_pg_class_oid", [{ args: [(oid$1)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    binaryUpgradeSetNextHeapRelfilenode(...args) {
        return sqlFunction("binary_upgrade_set_next_heap_relfilenode", [{ args: [(oid$1)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    binaryUpgradeSetNextIndexPgClassOid(...args) {
        return sqlFunction("binary_upgrade_set_next_index_pg_class_oid", [{ args: [(oid$1)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    binaryUpgradeSetNextIndexRelfilenode(...args) {
        return sqlFunction("binary_upgrade_set_next_index_relfilenode", [{ args: [(oid$1)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    binaryUpgradeSetNextMultirangeArrayPgTypeOid(...args) {
        return sqlFunction("binary_upgrade_set_next_multirange_array_pg_type_oid", [{ args: [(oid$1)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    binaryUpgradeSetNextMultirangePgTypeOid(...args) {
        return sqlFunction("binary_upgrade_set_next_multirange_pg_type_oid", [{ args: [(oid$1)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    binaryUpgradeSetNextPgAuthidOid(...args) {
        return sqlFunction("binary_upgrade_set_next_pg_authid_oid", [{ args: [(oid$1)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    binaryUpgradeSetNextPgEnumOid(...args) {
        return sqlFunction("binary_upgrade_set_next_pg_enum_oid", [{ args: [(oid$1)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    binaryUpgradeSetNextPgTablespaceOid(...args) {
        return sqlFunction("binary_upgrade_set_next_pg_tablespace_oid", [{ args: [(oid$1)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    binaryUpgradeSetNextPgTypeOid(...args) {
        return sqlFunction("binary_upgrade_set_next_pg_type_oid", [{ args: [(oid$1)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    binaryUpgradeSetNextToastPgClassOid(...args) {
        return sqlFunction("binary_upgrade_set_next_toast_pg_class_oid", [{ args: [(oid$1)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    binaryUpgradeSetNextToastRelfilenode(...args) {
        return sqlFunction("binary_upgrade_set_next_toast_relfilenode", [{ args: [(oid$1)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    btequalimage(...args) {
        return sqlFunction("btequalimage", [{ args: [(oid$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    btoidcmp(...args) {
        return sqlFunction("btoidcmp", [{ args: [(oid$1), (oid$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    btvarstrequalimage(...args) {
        return sqlFunction("btvarstrequalimage", [{ args: [(oid$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    colDescription(...args) {
        return sqlFunction("col_description", [{ args: [(oid$1), (default_1$4)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    fmgrCValidator(...args) {
        return sqlFunction("fmgr_c_validator", [{ args: [(oid$1)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    fmgrInternalValidator(...args) {
        return sqlFunction("fmgr_internal_validator", [{ args: [(oid$1)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    fmgrSqlValidator(...args) {
        return sqlFunction("fmgr_sql_validator", [{ args: [(oid$1)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    formatType(...args) {
        return sqlFunction("format_type", [{ args: [(oid$1), (default_1$4)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    hasAnyColumnPrivilege(...args) {
        return sqlFunction("has_any_column_privilege", [{ args: [(oid$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    hasColumnPrivilege(...args) {
        return sqlFunction("has_column_privilege", [{ args: [(oid$1), (default_1$5), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (oid$1), (default_1$5), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (oid$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1), (default_1$5), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    hasDatabasePrivilege(...args) {
        return sqlFunction("has_database_privilege", [{ args: [(oid$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    hasForeignDataWrapperPrivilege(...args) {
        return sqlFunction("has_foreign_data_wrapper_privilege", [{ args: [(oid$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    hasFunctionPrivilege(...args) {
        return sqlFunction("has_function_privilege", [{ args: [(oid$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    hasLanguagePrivilege(...args) {
        return sqlFunction("has_language_privilege", [{ args: [(oid$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    hasParameterPrivilege(...args) {
        return sqlFunction("has_parameter_privilege", [{ args: [(oid$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    hasSchemaPrivilege(...args) {
        return sqlFunction("has_schema_privilege", [{ args: [(oid$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    hasSequencePrivilege(...args) {
        return sqlFunction("has_sequence_privilege", [{ args: [(oid$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    hasServerPrivilege(...args) {
        return sqlFunction("has_server_privilege", [{ args: [(oid$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    hasTablePrivilege(...args) {
        return sqlFunction("has_table_privilege", [{ args: [(oid$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    hasTablespacePrivilege(...args) {
        return sqlFunction("has_tablespace_privilege", [{ args: [(oid$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    hasTypePrivilege(...args) {
        return sqlFunction("has_type_privilege", [{ args: [(oid$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    hashoid(...args) {
        return sqlFunction("hashoid", [{ args: [(oid$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    hashoidextended(...args) {
        return sqlFunction("hashoidextended", [{ args: [(oid$1), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    int8(...args) {
        return sqlFunction("int8", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    loCreate(...args) {
        return sqlFunction("lo_create", [{ args: [(oid$1)], ret: (oid$1), isOperator: false }], [this, ...args]);
    }
    loExport(...args) {
        return sqlFunction("lo_export", [{ args: [(oid$1), (default_1$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    loFromBytea(...args) {
        return sqlFunction("lo_from_bytea", [{ args: [(oid$1), (bytea)], ret: (oid$1), isOperator: false }], [this, ...args]);
    }
    loGet(...args) {
        return sqlFunction("lo_get", [{ args: [(oid$1)], ret: (bytea), isOperator: false }, { args: [(oid$1), (default_1$3), (default_1$4)], ret: (bytea), isOperator: false }], [this, ...args]);
    }
    loOpen(...args) {
        return sqlFunction("lo_open", [{ args: [(oid$1), (default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    loPut(...args) {
        return sqlFunction("lo_put", [{ args: [(oid$1), (default_1$3), (bytea)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    loUnlink(...args) {
        return sqlFunction("lo_unlink", [{ args: [(oid$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    makeaclitem(...args) {
        return sqlFunction("makeaclitem", [{ args: [(oid$1), (oid$1), (default_1$1), (default_1$8)], ret: (aclitem), isOperator: false }], [this, ...args]);
    }
    max(...args) {
        return sqlFunction("max", [{ args: [(oid$1)], ret: (oid$1), isOperator: false }], [this, ...args]);
    }
    objDescription(...args) {
        return sqlFunction("obj_description", [{ args: [(oid$1)], ret: (default_1$1), isOperator: false }, { args: [(oid$1), (name$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    oideq(...args) {
        return sqlFunction("oideq", [{ args: [(oid$1), (oid$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    oidge(...args) {
        return sqlFunction("oidge", [{ args: [(oid$1), (oid$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    oidgt(...args) {
        return sqlFunction("oidgt", [{ args: [(oid$1), (oid$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    oidlarger(...args) {
        return sqlFunction("oidlarger", [{ args: [(oid$1), (oid$1)], ret: (oid$1), isOperator: false }], [this, ...args]);
    }
    oidle(...args) {
        return sqlFunction("oidle", [{ args: [(oid$1), (oid$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    oidlt(...args) {
        return sqlFunction("oidlt", [{ args: [(oid$1), (oid$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    oidne(...args) {
        return sqlFunction("oidne", [{ args: [(oid$1), (oid$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    oidsmaller(...args) {
        return sqlFunction("oidsmaller", [{ args: [(oid$1), (oid$1)], ret: (oid$1), isOperator: false }], [this, ...args]);
    }
    pgCollationActualVersion(...args) {
        return sqlFunction("pg_collation_actual_version", [{ args: [(oid$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    pgCollationIsVisible(...args) {
        return sqlFunction("pg_collation_is_visible", [{ args: [(oid$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgConversionIsVisible(...args) {
        return sqlFunction("pg_conversion_is_visible", [{ args: [(oid$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgDatabaseCollationActualVersion(...args) {
        return sqlFunction("pg_database_collation_actual_version", [{ args: [(oid$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    pgDatabaseSize(...args) {
        return sqlFunction("pg_database_size", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgDescribeObject(...args) {
        return sqlFunction("pg_describe_object", [{ args: [(oid$1), (oid$1), (default_1$4)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    pgFilenodeRelation(...args) {
        return sqlFunction("pg_filenode_relation", [{ args: [(oid$1), (oid$1)], ret: (regclass$1), isOperator: false }], [this, ...args]);
    }
    pgFunctionIsVisible(...args) {
        return sqlFunction("pg_function_is_visible", [{ args: [(oid$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgGetConstraintdef(...args) {
        return sqlFunction("pg_get_constraintdef", [{ args: [(oid$1)], ret: (default_1$1), isOperator: false }, { args: [(oid$1), (default_1$8)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    pgGetFunctionArgDefault(...args) {
        return sqlFunction("pg_get_function_arg_default", [{ args: [(oid$1), (default_1$4)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    pgGetFunctionArguments(...args) {
        return sqlFunction("pg_get_function_arguments", [{ args: [(oid$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    pgGetFunctionIdentityArguments(...args) {
        return sqlFunction("pg_get_function_identity_arguments", [{ args: [(oid$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    pgGetFunctionResult(...args) {
        return sqlFunction("pg_get_function_result", [{ args: [(oid$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    pgGetFunctionSqlbody(...args) {
        return sqlFunction("pg_get_function_sqlbody", [{ args: [(oid$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    pgGetFunctiondef(...args) {
        return sqlFunction("pg_get_functiondef", [{ args: [(oid$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    pgGetIndexdef(...args) {
        return sqlFunction("pg_get_indexdef", [{ args: [(oid$1)], ret: (default_1$1), isOperator: false }, { args: [(oid$1), (default_1$4), (default_1$8)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    pgGetPartitionConstraintdef(...args) {
        return sqlFunction("pg_get_partition_constraintdef", [{ args: [(oid$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    pgGetPartkeydef(...args) {
        return sqlFunction("pg_get_partkeydef", [{ args: [(oid$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    pgGetRuledef(...args) {
        return sqlFunction("pg_get_ruledef", [{ args: [(oid$1)], ret: (default_1$1), isOperator: false }, { args: [(oid$1), (default_1$8)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    pgGetStatisticsobjdef(...args) {
        return sqlFunction("pg_get_statisticsobjdef", [{ args: [(oid$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    pgGetStatisticsobjdefColumns(...args) {
        return sqlFunction("pg_get_statisticsobjdef_columns", [{ args: [(oid$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    pgGetStatisticsobjdefExpressions(...args) {
        return sqlFunction("pg_get_statisticsobjdef_expressions", [{ args: [(oid$1)], ret: Array$1.of((default_1$1)), isOperator: false }], [this, ...args]);
    }
    pgGetTriggerdef(...args) {
        return sqlFunction("pg_get_triggerdef", [{ args: [(oid$1)], ret: (default_1$1), isOperator: false }, { args: [(oid$1), (default_1$8)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    pgGetUserbyid(...args) {
        return sqlFunction("pg_get_userbyid", [{ args: [(oid$1)], ret: (name$1), isOperator: false }], [this, ...args]);
    }
    pgGetViewdef(...args) {
        return sqlFunction("pg_get_viewdef", [{ args: [(oid$1)], ret: (default_1$1), isOperator: false }, { args: [(oid$1), (default_1$8)], ret: (default_1$1), isOperator: false }, { args: [(oid$1), (default_1$4)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    pgHasRole(...args) {
        return sqlFunction("pg_has_role", [{ args: [(oid$1), (name$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgIdentifyObject(...args) {
        return sqlFunction("pg_identify_object", [{ args: [(oid$1), (oid$1), (default_1$4)], ret: Record.of({ type: (default_1$1), schema: (default_1$1), name: (default_1$1), identity: (default_1$1) }), isOperator: false }], [this, ...args]);
    }
    pgIdentifyObjectAsAddress(...args) {
        return sqlFunction("pg_identify_object_as_address", [{ args: [(oid$1), (oid$1), (default_1$4)], ret: Record.of({ type: (default_1$1), object_names: Array$1.of((default_1$1)), object_args: Array$1.of((default_1$1)) }), isOperator: false }], [this, ...args]);
    }
    pgIndexamHasProperty(...args) {
        return sqlFunction("pg_indexam_has_property", [{ args: [(oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgIndexamProgressPhasename(...args) {
        return sqlFunction("pg_indexam_progress_phasename", [{ args: [(oid$1), (default_1$3)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    pgIsOtherTempSchema(...args) {
        return sqlFunction("pg_is_other_temp_schema", [{ args: [(oid$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgLsTmpdir(...args) {
        return sqlFunction("pg_ls_tmpdir", [{ args: [(oid$1)], ret: Setof.ofSchema({ name: (default_1$1), size: (default_1$3), modification: (timestamptz$1) }), isOperator: false }], [this, ...args]);
    }
    pgOpclassIsVisible(...args) {
        return sqlFunction("pg_opclass_is_visible", [{ args: [(oid$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgOperatorIsVisible(...args) {
        return sqlFunction("pg_operator_is_visible", [{ args: [(oid$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgOpfamilyIsVisible(...args) {
        return sqlFunction("pg_opfamily_is_visible", [{ args: [(oid$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgSequenceParameters(...args) {
        return sqlFunction("pg_sequence_parameters", [{ args: [(oid$1)], ret: Record.of({ start_value: (default_1$3), minimum_value: (default_1$3), maximum_value: (default_1$3), increment: (default_1$3), cycle_option: (default_1$8), cache_size: (default_1$3), data_type: (oid$1) }), isOperator: false }], [this, ...args]);
    }
    pgStatGetAnalyzeCount(...args) {
        return sqlFunction("pg_stat_get_analyze_count", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetAutoanalyzeCount(...args) {
        return sqlFunction("pg_stat_get_autoanalyze_count", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetAutovacuumCount(...args) {
        return sqlFunction("pg_stat_get_autovacuum_count", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetBlocksFetched(...args) {
        return sqlFunction("pg_stat_get_blocks_fetched", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetBlocksHit(...args) {
        return sqlFunction("pg_stat_get_blocks_hit", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetDbActiveTime(...args) {
        return sqlFunction("pg_stat_get_db_active_time", [{ args: [(oid$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    pgStatGetDbBlkReadTime(...args) {
        return sqlFunction("pg_stat_get_db_blk_read_time", [{ args: [(oid$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    pgStatGetDbBlkWriteTime(...args) {
        return sqlFunction("pg_stat_get_db_blk_write_time", [{ args: [(oid$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    pgStatGetDbBlocksFetched(...args) {
        return sqlFunction("pg_stat_get_db_blocks_fetched", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetDbBlocksHit(...args) {
        return sqlFunction("pg_stat_get_db_blocks_hit", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetDbChecksumFailures(...args) {
        return sqlFunction("pg_stat_get_db_checksum_failures", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetDbChecksumLastFailure(...args) {
        return sqlFunction("pg_stat_get_db_checksum_last_failure", [{ args: [(oid$1)], ret: (timestamptz$1), isOperator: false }], [this, ...args]);
    }
    pgStatGetDbConflictAll(...args) {
        return sqlFunction("pg_stat_get_db_conflict_all", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetDbConflictLock(...args) {
        return sqlFunction("pg_stat_get_db_conflict_lock", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetDbConflictLogicalslot(...args) {
        return sqlFunction("pg_stat_get_db_conflict_logicalslot", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetDbConflictSnapshot(...args) {
        return sqlFunction("pg_stat_get_db_conflict_snapshot", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetDbConflictStartupDeadlock(...args) {
        return sqlFunction("pg_stat_get_db_conflict_startup_deadlock", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetDbConflictTablespace(...args) {
        return sqlFunction("pg_stat_get_db_conflict_tablespace", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetDbDeadlocks(...args) {
        return sqlFunction("pg_stat_get_db_deadlocks", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetDbIdleInTransactionTime(...args) {
        return sqlFunction("pg_stat_get_db_idle_in_transaction_time", [{ args: [(oid$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    pgStatGetDbNumbackends(...args) {
        return sqlFunction("pg_stat_get_db_numbackends", [{ args: [(oid$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    pgStatGetDbSessionTime(...args) {
        return sqlFunction("pg_stat_get_db_session_time", [{ args: [(oid$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    pgStatGetDbSessions(...args) {
        return sqlFunction("pg_stat_get_db_sessions", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetDbSessionsAbandoned(...args) {
        return sqlFunction("pg_stat_get_db_sessions_abandoned", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetDbSessionsFatal(...args) {
        return sqlFunction("pg_stat_get_db_sessions_fatal", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetDbSessionsKilled(...args) {
        return sqlFunction("pg_stat_get_db_sessions_killed", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetDbStatResetTime(...args) {
        return sqlFunction("pg_stat_get_db_stat_reset_time", [{ args: [(oid$1)], ret: (timestamptz$1), isOperator: false }], [this, ...args]);
    }
    pgStatGetDbTempBytes(...args) {
        return sqlFunction("pg_stat_get_db_temp_bytes", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetDbTempFiles(...args) {
        return sqlFunction("pg_stat_get_db_temp_files", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetDbTuplesDeleted(...args) {
        return sqlFunction("pg_stat_get_db_tuples_deleted", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetDbTuplesFetched(...args) {
        return sqlFunction("pg_stat_get_db_tuples_fetched", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetDbTuplesInserted(...args) {
        return sqlFunction("pg_stat_get_db_tuples_inserted", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetDbTuplesReturned(...args) {
        return sqlFunction("pg_stat_get_db_tuples_returned", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetDbTuplesUpdated(...args) {
        return sqlFunction("pg_stat_get_db_tuples_updated", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetDbXactCommit(...args) {
        return sqlFunction("pg_stat_get_db_xact_commit", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetDbXactRollback(...args) {
        return sqlFunction("pg_stat_get_db_xact_rollback", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetDeadTuples(...args) {
        return sqlFunction("pg_stat_get_dead_tuples", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetFunctionCalls(...args) {
        return sqlFunction("pg_stat_get_function_calls", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetFunctionSelfTime(...args) {
        return sqlFunction("pg_stat_get_function_self_time", [{ args: [(oid$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    pgStatGetFunctionTotalTime(...args) {
        return sqlFunction("pg_stat_get_function_total_time", [{ args: [(oid$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    pgStatGetInsSinceVacuum(...args) {
        return sqlFunction("pg_stat_get_ins_since_vacuum", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetLastAnalyzeTime(...args) {
        return sqlFunction("pg_stat_get_last_analyze_time", [{ args: [(oid$1)], ret: (timestamptz$1), isOperator: false }], [this, ...args]);
    }
    pgStatGetLastAutoanalyzeTime(...args) {
        return sqlFunction("pg_stat_get_last_autoanalyze_time", [{ args: [(oid$1)], ret: (timestamptz$1), isOperator: false }], [this, ...args]);
    }
    pgStatGetLastAutovacuumTime(...args) {
        return sqlFunction("pg_stat_get_last_autovacuum_time", [{ args: [(oid$1)], ret: (timestamptz$1), isOperator: false }], [this, ...args]);
    }
    pgStatGetLastVacuumTime(...args) {
        return sqlFunction("pg_stat_get_last_vacuum_time", [{ args: [(oid$1)], ret: (timestamptz$1), isOperator: false }], [this, ...args]);
    }
    pgStatGetLastscan(...args) {
        return sqlFunction("pg_stat_get_lastscan", [{ args: [(oid$1)], ret: (timestamptz$1), isOperator: false }], [this, ...args]);
    }
    pgStatGetLiveTuples(...args) {
        return sqlFunction("pg_stat_get_live_tuples", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetModSinceAnalyze(...args) {
        return sqlFunction("pg_stat_get_mod_since_analyze", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetNumscans(...args) {
        return sqlFunction("pg_stat_get_numscans", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetSubscription(...args) {
        return sqlFunction("pg_stat_get_subscription", [{ args: [(oid$1)], ret: Setof.ofSchema({ subid: (oid$1), relid: (oid$1), pid: (default_1$4), leader_pid: (default_1$4), received_lsn: (pg_lsn), last_msg_send_time: (timestamptz$1), last_msg_receipt_time: (timestamptz$1), latest_end_lsn: (pg_lsn), latest_end_time: (timestamptz$1), worker_type: (default_1$1) }), isOperator: false }], [this, ...args]);
    }
    pgStatGetSubscriptionStats(...args) {
        return sqlFunction("pg_stat_get_subscription_stats", [{ args: [(oid$1)], ret: Record.of({ subid: (oid$1), apply_error_count: (default_1$3), sync_error_count: (default_1$3), stats_reset: (timestamptz$1) }), isOperator: false }], [this, ...args]);
    }
    pgStatGetTuplesDeleted(...args) {
        return sqlFunction("pg_stat_get_tuples_deleted", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetTuplesFetched(...args) {
        return sqlFunction("pg_stat_get_tuples_fetched", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetTuplesHotUpdated(...args) {
        return sqlFunction("pg_stat_get_tuples_hot_updated", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetTuplesInserted(...args) {
        return sqlFunction("pg_stat_get_tuples_inserted", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetTuplesNewpageUpdated(...args) {
        return sqlFunction("pg_stat_get_tuples_newpage_updated", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetTuplesReturned(...args) {
        return sqlFunction("pg_stat_get_tuples_returned", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetTuplesUpdated(...args) {
        return sqlFunction("pg_stat_get_tuples_updated", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetVacuumCount(...args) {
        return sqlFunction("pg_stat_get_vacuum_count", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetXactBlocksFetched(...args) {
        return sqlFunction("pg_stat_get_xact_blocks_fetched", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetXactBlocksHit(...args) {
        return sqlFunction("pg_stat_get_xact_blocks_hit", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetXactFunctionCalls(...args) {
        return sqlFunction("pg_stat_get_xact_function_calls", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetXactFunctionSelfTime(...args) {
        return sqlFunction("pg_stat_get_xact_function_self_time", [{ args: [(oid$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    pgStatGetXactFunctionTotalTime(...args) {
        return sqlFunction("pg_stat_get_xact_function_total_time", [{ args: [(oid$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    pgStatGetXactNumscans(...args) {
        return sqlFunction("pg_stat_get_xact_numscans", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetXactTuplesDeleted(...args) {
        return sqlFunction("pg_stat_get_xact_tuples_deleted", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetXactTuplesFetched(...args) {
        return sqlFunction("pg_stat_get_xact_tuples_fetched", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetXactTuplesHotUpdated(...args) {
        return sqlFunction("pg_stat_get_xact_tuples_hot_updated", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetXactTuplesInserted(...args) {
        return sqlFunction("pg_stat_get_xact_tuples_inserted", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetXactTuplesNewpageUpdated(...args) {
        return sqlFunction("pg_stat_get_xact_tuples_newpage_updated", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetXactTuplesReturned(...args) {
        return sqlFunction("pg_stat_get_xact_tuples_returned", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatGetXactTuplesUpdated(...args) {
        return sqlFunction("pg_stat_get_xact_tuples_updated", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgStatResetSingleFunctionCounters(...args) {
        return sqlFunction("pg_stat_reset_single_function_counters", [{ args: [(oid$1)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    pgStatResetSingleTableCounters(...args) {
        return sqlFunction("pg_stat_reset_single_table_counters", [{ args: [(oid$1)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    pgStatResetSubscriptionStats(...args) {
        return sqlFunction("pg_stat_reset_subscription_stats", [{ args: [(oid$1)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    pgStatisticsObjIsVisible(...args) {
        return sqlFunction("pg_statistics_obj_is_visible", [{ args: [(oid$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgTableIsVisible(...args) {
        return sqlFunction("pg_table_is_visible", [{ args: [(oid$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgTablespaceDatabases(...args) {
        return sqlFunction("pg_tablespace_databases", [{ args: [(oid$1)], ret: Setof.ofSchema({}), isOperator: false }], [this, ...args]);
    }
    pgTablespaceLocation(...args) {
        return sqlFunction("pg_tablespace_location", [{ args: [(oid$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    pgTablespaceSize(...args) {
        return sqlFunction("pg_tablespace_size", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgTsConfigIsVisible(...args) {
        return sqlFunction("pg_ts_config_is_visible", [{ args: [(oid$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgTsDictIsVisible(...args) {
        return sqlFunction("pg_ts_dict_is_visible", [{ args: [(oid$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgTsParserIsVisible(...args) {
        return sqlFunction("pg_ts_parser_is_visible", [{ args: [(oid$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgTsTemplateIsVisible(...args) {
        return sqlFunction("pg_ts_template_is_visible", [{ args: [(oid$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgTypeIsVisible(...args) {
        return sqlFunction("pg_type_is_visible", [{ args: [(oid$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    plpgsqlValidator(...args) {
        return sqlFunction("plpgsql_validator", [{ args: [(oid$1)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    rowSecurityActive(...args) {
        return sqlFunction("row_security_active", [{ args: [(oid$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    satisfiesHashPartition(...args) {
        return sqlFunction("satisfies_hash_partition", [{ args: [(oid$1), (default_1$4), (default_1$4), (Any)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    shobjDescription(...args) {
        return sqlFunction("shobj_description", [{ args: [(oid$1), (name$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    tsParse(...args) {
        return sqlFunction("ts_parse", [{ args: [(oid$1), (default_1$1)], ret: Setof.ofSchema({ tokid: (default_1$4), token: (default_1$1) }), isOperator: false }], [this, ...args]);
    }
    tsTokenType(...args) {
        return sqlFunction("ts_token_type", [{ args: [(oid$1)], ret: Setof.ofSchema({ tokid: (default_1$4), alias: (default_1$1), description: (default_1$1) }), isOperator: false }], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [{ args: [(oid$1), (oid$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">="](...args) {
        return sqlFunction(">=", [{ args: [(oid$1), (oid$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">"](...args) {
        return sqlFunction(">", [{ args: [(oid$1), (oid$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<="](...args) {
        return sqlFunction("<=", [{ args: [(oid$1), (oid$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<"](...args) {
        return sqlFunction("<", [{ args: [(oid$1), (oid$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<>"](...args) {
        return sqlFunction("<>", [{ args: [(oid$1), (oid$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
}

class oidvector extends Any {
    static new(v) { return new oidvector(v); }
    static parse(v) { return v; }
    static typeString() { return "oidvector"; }
    asAggregate() {
        return undefined;
    }
    btoidvectorcmp(...args) {
        return sqlFunction("btoidvectorcmp", [{ args: [(oidvector), (oidvector)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    hashoidvector(...args) {
        return sqlFunction("hashoidvector", [{ args: [(oidvector)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    hashoidvectorextended(...args) {
        return sqlFunction("hashoidvectorextended", [{ args: [(oidvector), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    oidvectoreq(...args) {
        return sqlFunction("oidvectoreq", [{ args: [(oidvector), (oidvector)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    oidvectorge(...args) {
        return sqlFunction("oidvectorge", [{ args: [(oidvector), (oidvector)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    oidvectorgt(...args) {
        return sqlFunction("oidvectorgt", [{ args: [(oidvector), (oidvector)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    oidvectorle(...args) {
        return sqlFunction("oidvectorle", [{ args: [(oidvector), (oidvector)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    oidvectorlt(...args) {
        return sqlFunction("oidvectorlt", [{ args: [(oidvector), (oidvector)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    oidvectorne(...args) {
        return sqlFunction("oidvectorne", [{ args: [(oidvector), (oidvector)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    oidvectortypes(...args) {
        return sqlFunction("oidvectortypes", [{ args: [(oidvector)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [{ args: [(oidvector), (oidvector)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">="](...args) {
        return sqlFunction(">=", [{ args: [(oidvector), (oidvector)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">"](...args) {
        return sqlFunction(">", [{ args: [(oidvector), (oidvector)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<="](...args) {
        return sqlFunction("<=", [{ args: [(oidvector), (oidvector)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<"](...args) {
        return sqlFunction("<", [{ args: [(oidvector), (oidvector)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<>"](...args) {
        return sqlFunction("<>", [{ args: [(oidvector), (oidvector)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
}

class path$1 extends Any {
    static new(v) { return new path$1(v); }
    static parse(v) { return v; }
    static typeString() { return "path"; }
    asAggregate() {
        return undefined;
    }
    area(...args) {
        return sqlFunction("area", [{ args: [(path$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    distPathp(...args) {
        return sqlFunction("dist_pathp", [{ args: [(path$1), (point$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    isclosed(...args) {
        return sqlFunction("isclosed", [{ args: [(path$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    isopen(...args) {
        return sqlFunction("isopen", [{ args: [(path$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    length(...args) {
        return sqlFunction("length", [{ args: [(path$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    npoints(...args) {
        return sqlFunction("npoints", [{ args: [(path$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    pathAdd(...args) {
        return sqlFunction("path_add", [{ args: [(path$1), (path$1)], ret: (path$1), isOperator: false }], [this, ...args]);
    }
    pathAddPt(...args) {
        return sqlFunction("path_add_pt", [{ args: [(path$1), (point$1)], ret: (path$1), isOperator: false }], [this, ...args]);
    }
    pathContainPt(...args) {
        return sqlFunction("path_contain_pt", [{ args: [(path$1), (point$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pathDistance(...args) {
        return sqlFunction("path_distance", [{ args: [(path$1), (path$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    pathDivPt(...args) {
        return sqlFunction("path_div_pt", [{ args: [(path$1), (point$1)], ret: (path$1), isOperator: false }], [this, ...args]);
    }
    pathInter(...args) {
        return sqlFunction("path_inter", [{ args: [(path$1), (path$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pathLength(...args) {
        return sqlFunction("path_length", [{ args: [(path$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    pathMulPt(...args) {
        return sqlFunction("path_mul_pt", [{ args: [(path$1), (point$1)], ret: (path$1), isOperator: false }], [this, ...args]);
    }
    pathNEq(...args) {
        return sqlFunction("path_n_eq", [{ args: [(path$1), (path$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pathNGe(...args) {
        return sqlFunction("path_n_ge", [{ args: [(path$1), (path$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pathNGt(...args) {
        return sqlFunction("path_n_gt", [{ args: [(path$1), (path$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pathNLe(...args) {
        return sqlFunction("path_n_le", [{ args: [(path$1), (path$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pathNLt(...args) {
        return sqlFunction("path_n_lt", [{ args: [(path$1), (path$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pathNpoints(...args) {
        return sqlFunction("path_npoints", [{ args: [(path$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    pathSubPt(...args) {
        return sqlFunction("path_sub_pt", [{ args: [(path$1), (point$1)], ret: (path$1), isOperator: false }], [this, ...args]);
    }
    pclose(...args) {
        return sqlFunction("pclose", [{ args: [(path$1)], ret: (path$1), isOperator: false }], [this, ...args]);
    }
    polygon(...args) {
        return sqlFunction("polygon", [{ args: [(path$1)], ret: (polygon$1), isOperator: false }], [this, ...args]);
    }
    popen(...args) {
        return sqlFunction("popen", [{ args: [(path$1)], ret: (path$1), isOperator: false }], [this, ...args]);
    }
    ["<->"](...args) {
        return sqlFunction("<->", [{ args: [(path$1), (point$1)], ret: (default_1$6), isOperator: true }, { args: [(path$1), (path$1)], ret: (default_1$6), isOperator: true }], [this, ...args]);
    }
    ["+"](...args) {
        return sqlFunction("+", [{ args: [(path$1), (path$1)], ret: (path$1), isOperator: true }, { args: [(path$1), (point$1)], ret: (path$1), isOperator: true }], [this, ...args]);
    }
    ["@>"](...args) {
        return sqlFunction("@>", [{ args: [(path$1), (point$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["/"](...args) {
        return sqlFunction("/", [{ args: [(path$1), (point$1)], ret: (path$1), isOperator: true }], [this, ...args]);
    }
    ["?#"](...args) {
        return sqlFunction("?#", [{ args: [(path$1), (path$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["*"](...args) {
        return sqlFunction("*", [{ args: [(path$1), (point$1)], ret: (path$1), isOperator: true }], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [{ args: [(path$1), (path$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">="](...args) {
        return sqlFunction(">=", [{ args: [(path$1), (path$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">"](...args) {
        return sqlFunction(">", [{ args: [(path$1), (path$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<="](...args) {
        return sqlFunction("<=", [{ args: [(path$1), (path$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<"](...args) {
        return sqlFunction("<", [{ args: [(path$1), (path$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["-"](...args) {
        return sqlFunction("-", [{ args: [(path$1), (point$1)], ret: (path$1), isOperator: true }], [this, ...args]);
    }
}

class pg_ddl_command extends Any {
    static new(v) { return new pg_ddl_command(v); }
    static parse(v) { return v; }
    static typeString() { return "pg_ddl_command"; }
    asAggregate() {
        return undefined;
    }
}

class pg_lsn extends Any {
    static new(v) { return new pg_lsn(v); }
    static parse(v) { return v; }
    static typeString() { return "pg_lsn"; }
    asAggregate() {
        return undefined;
    }
    max(...args) {
        return sqlFunction("max", [{ args: [(pg_lsn)], ret: (pg_lsn), isOperator: false }], [this, ...args]);
    }
    pgLsnCmp(...args) {
        return sqlFunction("pg_lsn_cmp", [{ args: [(pg_lsn), (pg_lsn)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    pgLsnEq(...args) {
        return sqlFunction("pg_lsn_eq", [{ args: [(pg_lsn), (pg_lsn)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgLsnGe(...args) {
        return sqlFunction("pg_lsn_ge", [{ args: [(pg_lsn), (pg_lsn)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgLsnGt(...args) {
        return sqlFunction("pg_lsn_gt", [{ args: [(pg_lsn), (pg_lsn)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgLsnHash(...args) {
        return sqlFunction("pg_lsn_hash", [{ args: [(pg_lsn)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    pgLsnHashExtended(...args) {
        return sqlFunction("pg_lsn_hash_extended", [{ args: [(pg_lsn), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgLsnLarger(...args) {
        return sqlFunction("pg_lsn_larger", [{ args: [(pg_lsn), (pg_lsn)], ret: (pg_lsn), isOperator: false }], [this, ...args]);
    }
    pgLsnLe(...args) {
        return sqlFunction("pg_lsn_le", [{ args: [(pg_lsn), (pg_lsn)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgLsnLt(...args) {
        return sqlFunction("pg_lsn_lt", [{ args: [(pg_lsn), (pg_lsn)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgLsnMi(...args) {
        return sqlFunction("pg_lsn_mi", [{ args: [(pg_lsn), (pg_lsn)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    pgLsnMii(...args) {
        return sqlFunction("pg_lsn_mii", [{ args: [(pg_lsn), (default_1$2)], ret: (pg_lsn), isOperator: false }], [this, ...args]);
    }
    pgLsnNe(...args) {
        return sqlFunction("pg_lsn_ne", [{ args: [(pg_lsn), (pg_lsn)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgLsnPli(...args) {
        return sqlFunction("pg_lsn_pli", [{ args: [(pg_lsn), (default_1$2)], ret: (pg_lsn), isOperator: false }], [this, ...args]);
    }
    pgLsnSmaller(...args) {
        return sqlFunction("pg_lsn_smaller", [{ args: [(pg_lsn), (pg_lsn)], ret: (pg_lsn), isOperator: false }], [this, ...args]);
    }
    pgReplicationOriginXactSetup(...args) {
        return sqlFunction("pg_replication_origin_xact_setup", [{ args: [(pg_lsn), (timestamptz$1)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    pgWalLsnDiff(...args) {
        return sqlFunction("pg_wal_lsn_diff", [{ args: [(pg_lsn), (pg_lsn)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    pgWalfileName(...args) {
        return sqlFunction("pg_walfile_name", [{ args: [(pg_lsn)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    pgWalfileNameOffset(...args) {
        return sqlFunction("pg_walfile_name_offset", [{ args: [(pg_lsn)], ret: Record.of({ file_name: (default_1$1), file_offset: (default_1$4) }), isOperator: false }], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [{ args: [(pg_lsn), (pg_lsn)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">="](...args) {
        return sqlFunction(">=", [{ args: [(pg_lsn), (pg_lsn)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">"](...args) {
        return sqlFunction(">", [{ args: [(pg_lsn), (pg_lsn)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<="](...args) {
        return sqlFunction("<=", [{ args: [(pg_lsn), (pg_lsn)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<"](...args) {
        return sqlFunction("<", [{ args: [(pg_lsn), (pg_lsn)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["-"](...args) {
        return sqlFunction("-", [{ args: [(pg_lsn), (pg_lsn)], ret: (default_1$2), isOperator: true }, { args: [(pg_lsn), (default_1$2)], ret: (pg_lsn), isOperator: true }], [this, ...args]);
    }
    ["<>"](...args) {
        return sqlFunction("<>", [{ args: [(pg_lsn), (pg_lsn)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["+"](...args) {
        return sqlFunction("+", [{ args: [(pg_lsn), (default_1$2)], ret: (pg_lsn), isOperator: true }], [this, ...args]);
    }
}

class pg_mcv_list extends Any {
    static new(v) { return new pg_mcv_list(v); }
    static parse(v) { return v; }
    static typeString() { return "pg_mcv_list"; }
    asAggregate() {
        return undefined;
    }
    pgMcvListItems(...args) {
        return sqlFunction("pg_mcv_list_items", [{ args: [(pg_mcv_list)], ret: Setof.ofSchema({ index: (default_1$4), values: Array$1.of((default_1$1)), nulls: Array$1.of((default_1$8)), frequency: (default_1$6), base_frequency: (default_1$6) }), isOperator: false }], [this, ...args]);
    }
}

class pg_node_tree extends Any {
    static new(v) { return new pg_node_tree(v); }
    static parse(v) { return v; }
    static typeString() { return "pg_node_tree"; }
    asAggregate() {
        return undefined;
    }
    pgGetExpr(...args) {
        return sqlFunction("pg_get_expr", [{ args: [(pg_node_tree), (oid$1)], ret: (default_1$1), isOperator: false }, { args: [(pg_node_tree), (oid$1), (default_1$8)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
}

class pg_snapshot extends Any {
    static new(v) { return new pg_snapshot(v); }
    static parse(v) { return v; }
    static typeString() { return "pg_snapshot"; }
    asAggregate() {
        return undefined;
    }
    pgSnapshotXip(...args) {
        return sqlFunction("pg_snapshot_xip", [{ args: [(pg_snapshot)], ret: Setof.ofSchema({}), isOperator: false }], [this, ...args]);
    }
    pgSnapshotXmax(...args) {
        return sqlFunction("pg_snapshot_xmax", [{ args: [(pg_snapshot)], ret: (xid8), isOperator: false }], [this, ...args]);
    }
}

class point$1 extends Any {
    static new(v) { return new point$1(v); }
    static parse(v) { return v; }
    static typeString() { return "point"; }
    asAggregate() {
        return undefined;
    }
    box(...args) {
        return sqlFunction("box", [{ args: [(point$1)], ret: (box$1), isOperator: false }, { args: [(point$1), (point$1)], ret: (box$1), isOperator: false }], [this, ...args]);
    }
    circle(...args) {
        return sqlFunction("circle", [{ args: [(point$1), (default_1$6)], ret: (circle$1), isOperator: false }], [this, ...args]);
    }
    closePb(...args) {
        return sqlFunction("close_pb", [{ args: [(point$1), (box$1)], ret: (point$1), isOperator: false }], [this, ...args]);
    }
    closePl(...args) {
        return sqlFunction("close_pl", [{ args: [(point$1), (line$1)], ret: (point$1), isOperator: false }], [this, ...args]);
    }
    closePs(...args) {
        return sqlFunction("close_ps", [{ args: [(point$1), (lseg$1)], ret: (point$1), isOperator: false }], [this, ...args]);
    }
    distPb(...args) {
        return sqlFunction("dist_pb", [{ args: [(point$1), (box$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    distPc(...args) {
        return sqlFunction("dist_pc", [{ args: [(point$1), (circle$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    distPl(...args) {
        return sqlFunction("dist_pl", [{ args: [(point$1), (line$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    distPpath(...args) {
        return sqlFunction("dist_ppath", [{ args: [(point$1), (path$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    distPpoly(...args) {
        return sqlFunction("dist_ppoly", [{ args: [(point$1), (polygon$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    distPs(...args) {
        return sqlFunction("dist_ps", [{ args: [(point$1), (lseg$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    ishorizontal(...args) {
        return sqlFunction("ishorizontal", [{ args: [(point$1), (point$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    isvertical(...args) {
        return sqlFunction("isvertical", [{ args: [(point$1), (point$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    line(...args) {
        return sqlFunction("line", [{ args: [(point$1), (point$1)], ret: (line$1), isOperator: false }], [this, ...args]);
    }
    lseg(...args) {
        return sqlFunction("lseg", [{ args: [(point$1), (point$1)], ret: (lseg$1), isOperator: false }], [this, ...args]);
    }
    onPb(...args) {
        return sqlFunction("on_pb", [{ args: [(point$1), (box$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    onPl(...args) {
        return sqlFunction("on_pl", [{ args: [(point$1), (line$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    onPpath(...args) {
        return sqlFunction("on_ppath", [{ args: [(point$1), (path$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    onPs(...args) {
        return sqlFunction("on_ps", [{ args: [(point$1), (lseg$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pointAbove(...args) {
        return sqlFunction("point_above", [{ args: [(point$1), (point$1)], ret: (default_1$8), isOperator: false }, { args: [(point$1), (point$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pointAdd(...args) {
        return sqlFunction("point_add", [{ args: [(point$1), (point$1)], ret: (point$1), isOperator: false }], [this, ...args]);
    }
    pointBelow(...args) {
        return sqlFunction("point_below", [{ args: [(point$1), (point$1)], ret: (default_1$8), isOperator: false }, { args: [(point$1), (point$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pointDistance(...args) {
        return sqlFunction("point_distance", [{ args: [(point$1), (point$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    pointDiv(...args) {
        return sqlFunction("point_div", [{ args: [(point$1), (point$1)], ret: (point$1), isOperator: false }], [this, ...args]);
    }
    pointEq(...args) {
        return sqlFunction("point_eq", [{ args: [(point$1), (point$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pointHoriz(...args) {
        return sqlFunction("point_horiz", [{ args: [(point$1), (point$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pointLeft(...args) {
        return sqlFunction("point_left", [{ args: [(point$1), (point$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pointMul(...args) {
        return sqlFunction("point_mul", [{ args: [(point$1), (point$1)], ret: (point$1), isOperator: false }], [this, ...args]);
    }
    pointNe(...args) {
        return sqlFunction("point_ne", [{ args: [(point$1), (point$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pointRight(...args) {
        return sqlFunction("point_right", [{ args: [(point$1), (point$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pointSub(...args) {
        return sqlFunction("point_sub", [{ args: [(point$1), (point$1)], ret: (point$1), isOperator: false }], [this, ...args]);
    }
    pointVert(...args) {
        return sqlFunction("point_vert", [{ args: [(point$1), (point$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    ptContainedCircle(...args) {
        return sqlFunction("pt_contained_circle", [{ args: [(point$1), (circle$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    ptContainedPoly(...args) {
        return sqlFunction("pt_contained_poly", [{ args: [(point$1), (polygon$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    slope(...args) {
        return sqlFunction("slope", [{ args: [(point$1), (point$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    ["##"](...args) {
        return sqlFunction("##", [{ args: [(point$1), (box$1)], ret: (point$1), isOperator: true }, { args: [(point$1), (line$1)], ret: (point$1), isOperator: true }, { args: [(point$1), (lseg$1)], ret: (point$1), isOperator: true }], [this, ...args]);
    }
    ["<->"](...args) {
        return sqlFunction("<->", [{ args: [(point$1), (box$1)], ret: (default_1$6), isOperator: true }, { args: [(point$1), (circle$1)], ret: (default_1$6), isOperator: true }, { args: [(point$1), (line$1)], ret: (default_1$6), isOperator: true }, { args: [(point$1), (path$1)], ret: (default_1$6), isOperator: true }, { args: [(point$1), (polygon$1)], ret: (default_1$6), isOperator: true }, { args: [(point$1), (lseg$1)], ret: (default_1$6), isOperator: true }, { args: [(point$1), (point$1)], ret: (default_1$6), isOperator: true }], [this, ...args]);
    }
    [">^"](...args) {
        return sqlFunction(">^", [{ args: [(point$1), (point$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["|>>"](...args) {
        return sqlFunction("|>>", [{ args: [(point$1), (point$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["+"](...args) {
        return sqlFunction("+", [{ args: [(point$1), (point$1)], ret: (point$1), isOperator: true }], [this, ...args]);
    }
    ["<^"](...args) {
        return sqlFunction("<^", [{ args: [(point$1), (point$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<<|"](...args) {
        return sqlFunction("<<|", [{ args: [(point$1), (point$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["/"](...args) {
        return sqlFunction("/", [{ args: [(point$1), (point$1)], ret: (point$1), isOperator: true }], [this, ...args]);
    }
    ["~="](...args) {
        return sqlFunction("~=", [{ args: [(point$1), (point$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["?-"](...args) {
        return sqlFunction("?-", [{ args: [(point$1), (point$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<<"](...args) {
        return sqlFunction("<<", [{ args: [(point$1), (point$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["*"](...args) {
        return sqlFunction("*", [{ args: [(point$1), (point$1)], ret: (point$1), isOperator: true }], [this, ...args]);
    }
    ["<>"](...args) {
        return sqlFunction("<>", [{ args: [(point$1), (point$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">>"](...args) {
        return sqlFunction(">>", [{ args: [(point$1), (point$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["-"](...args) {
        return sqlFunction("-", [{ args: [(point$1), (point$1)], ret: (point$1), isOperator: true }], [this, ...args]);
    }
    ["?|"](...args) {
        return sqlFunction("?|", [{ args: [(point$1), (point$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
}

class polygon$1 extends Any {
    static new(v) { return new polygon$1(v); }
    static parse(v) { return v; }
    static typeString() { return "polygon"; }
    asAggregate() {
        return undefined;
    }
    box(...args) {
        return sqlFunction("box", [{ args: [(polygon$1)], ret: (box$1), isOperator: false }], [this, ...args]);
    }
    circle(...args) {
        return sqlFunction("circle", [{ args: [(polygon$1)], ret: (circle$1), isOperator: false }], [this, ...args]);
    }
    distPolyc(...args) {
        return sqlFunction("dist_polyc", [{ args: [(polygon$1), (circle$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    distPolyp(...args) {
        return sqlFunction("dist_polyp", [{ args: [(polygon$1), (point$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    npoints(...args) {
        return sqlFunction("npoints", [{ args: [(polygon$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    path(...args) {
        return sqlFunction("path", [{ args: [(polygon$1)], ret: (path$1), isOperator: false }], [this, ...args]);
    }
    point(...args) {
        return sqlFunction("point", [{ args: [(polygon$1)], ret: (point$1), isOperator: false }], [this, ...args]);
    }
    polyAbove(...args) {
        return sqlFunction("poly_above", [{ args: [(polygon$1), (polygon$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    polyBelow(...args) {
        return sqlFunction("poly_below", [{ args: [(polygon$1), (polygon$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    polyCenter(...args) {
        return sqlFunction("poly_center", [{ args: [(polygon$1)], ret: (point$1), isOperator: false }], [this, ...args]);
    }
    polyContainPt(...args) {
        return sqlFunction("poly_contain_pt", [{ args: [(polygon$1), (point$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    polyContained(...args) {
        return sqlFunction("poly_contained", [{ args: [(polygon$1), (polygon$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    polyDistance(...args) {
        return sqlFunction("poly_distance", [{ args: [(polygon$1), (polygon$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    polyLeft(...args) {
        return sqlFunction("poly_left", [{ args: [(polygon$1), (polygon$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    polyNpoints(...args) {
        return sqlFunction("poly_npoints", [{ args: [(polygon$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    polyOverabove(...args) {
        return sqlFunction("poly_overabove", [{ args: [(polygon$1), (polygon$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    polyOverbelow(...args) {
        return sqlFunction("poly_overbelow", [{ args: [(polygon$1), (polygon$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    polyOverlap(...args) {
        return sqlFunction("poly_overlap", [{ args: [(polygon$1), (polygon$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    polyOverleft(...args) {
        return sqlFunction("poly_overleft", [{ args: [(polygon$1), (polygon$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    polyOverright(...args) {
        return sqlFunction("poly_overright", [{ args: [(polygon$1), (polygon$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    polyRight(...args) {
        return sqlFunction("poly_right", [{ args: [(polygon$1), (polygon$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    polySame(...args) {
        return sqlFunction("poly_same", [{ args: [(polygon$1), (polygon$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    spgPolyQuadCompress(...args) {
        return sqlFunction("spg_poly_quad_compress", [{ args: [(polygon$1)], ret: (box$1), isOperator: false }], [this, ...args]);
    }
    ["<->"](...args) {
        return sqlFunction("<->", [{ args: [(polygon$1), (circle$1)], ret: (default_1$6), isOperator: true }, { args: [(polygon$1), (point$1)], ret: (default_1$6), isOperator: true }, { args: [(polygon$1), (polygon$1)], ret: (default_1$6), isOperator: true }], [this, ...args]);
    }
    ["|>>"](...args) {
        return sqlFunction("|>>", [{ args: [(polygon$1), (polygon$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<<|"](...args) {
        return sqlFunction("<<|", [{ args: [(polygon$1), (polygon$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["@>"](...args) {
        return sqlFunction("@>", [{ args: [(polygon$1), (point$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<<"](...args) {
        return sqlFunction("<<", [{ args: [(polygon$1), (polygon$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["|&>"](...args) {
        return sqlFunction("|&>", [{ args: [(polygon$1), (polygon$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["&<|"](...args) {
        return sqlFunction("&<|", [{ args: [(polygon$1), (polygon$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["&&"](...args) {
        return sqlFunction("&&", [{ args: [(polygon$1), (polygon$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["&<"](...args) {
        return sqlFunction("&<", [{ args: [(polygon$1), (polygon$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["&>"](...args) {
        return sqlFunction("&>", [{ args: [(polygon$1), (polygon$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">>"](...args) {
        return sqlFunction(">>", [{ args: [(polygon$1), (polygon$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["~="](...args) {
        return sqlFunction("~=", [{ args: [(polygon$1), (polygon$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
}

class PgRecord extends Any {
    static parse(v) { return v; }
    static typeString() { return "record"; }
    asAggregate() {
        return undefined;
    }
    btrecordcmp(...args) {
        return sqlFunction("btrecordcmp", [({ R }) => ({ args: [Record.of(R), Record.of(R)], ret: (default_1$4), isOperator: false })], [this, ...args]);
    }
    btrecordimagecmp(...args) {
        return sqlFunction("btrecordimagecmp", [({ R }) => ({ args: [Record.of(R), Record.of(R)], ret: (default_1$4), isOperator: false })], [this, ...args]);
    }
    hashRecord(...args) {
        return sqlFunction("hash_record", [({ R }) => ({ args: [Record.of(R)], ret: (default_1$4), isOperator: false })], [this, ...args]);
    }
    hashRecordExtended(...args) {
        return sqlFunction("hash_record_extended", [({ R }) => ({ args: [Record.of(R), (default_1$3)], ret: (default_1$3), isOperator: false })], [this, ...args]);
    }
    recordEq(...args) {
        return sqlFunction("record_eq", [({ R }) => ({ args: [Record.of(R), Record.of(R)], ret: (default_1$8), isOperator: false })], [this, ...args]);
    }
    recordGe(...args) {
        return sqlFunction("record_ge", [({ R }) => ({ args: [Record.of(R), Record.of(R)], ret: (default_1$8), isOperator: false })], [this, ...args]);
    }
    recordGt(...args) {
        return sqlFunction("record_gt", [({ R }) => ({ args: [Record.of(R), Record.of(R)], ret: (default_1$8), isOperator: false })], [this, ...args]);
    }
    recordImageEq(...args) {
        return sqlFunction("record_image_eq", [({ R }) => ({ args: [Record.of(R), Record.of(R)], ret: (default_1$8), isOperator: false })], [this, ...args]);
    }
    recordImageGe(...args) {
        return sqlFunction("record_image_ge", [({ R }) => ({ args: [Record.of(R), Record.of(R)], ret: (default_1$8), isOperator: false })], [this, ...args]);
    }
    recordImageGt(...args) {
        return sqlFunction("record_image_gt", [({ R }) => ({ args: [Record.of(R), Record.of(R)], ret: (default_1$8), isOperator: false })], [this, ...args]);
    }
    recordImageLe(...args) {
        return sqlFunction("record_image_le", [({ R }) => ({ args: [Record.of(R), Record.of(R)], ret: (default_1$8), isOperator: false })], [this, ...args]);
    }
    recordImageLt(...args) {
        return sqlFunction("record_image_lt", [({ R }) => ({ args: [Record.of(R), Record.of(R)], ret: (default_1$8), isOperator: false })], [this, ...args]);
    }
    recordImageNe(...args) {
        return sqlFunction("record_image_ne", [({ R }) => ({ args: [Record.of(R), Record.of(R)], ret: (default_1$8), isOperator: false })], [this, ...args]);
    }
    recordLe(...args) {
        return sqlFunction("record_le", [({ R }) => ({ args: [Record.of(R), Record.of(R)], ret: (default_1$8), isOperator: false })], [this, ...args]);
    }
    recordLt(...args) {
        return sqlFunction("record_lt", [({ R }) => ({ args: [Record.of(R), Record.of(R)], ret: (default_1$8), isOperator: false })], [this, ...args]);
    }
    recordNe(...args) {
        return sqlFunction("record_ne", [({ R }) => ({ args: [Record.of(R), Record.of(R)], ret: (default_1$8), isOperator: false })], [this, ...args]);
    }
    rowToJson(...args) {
        return sqlFunction("row_to_json", [({ R }) => ({ args: [Record.of(R)], ret: (json), isOperator: false }), ({ R }) => ({ args: [Record.of(R), (default_1$8)], ret: (json), isOperator: false })], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [({ R }) => ({ args: [Record.of(R), Record.of(R)], ret: (default_1$8), isOperator: true })], [this, ...args]);
    }
    [">="](...args) {
        return sqlFunction(">=", [({ R }) => ({ args: [Record.of(R), Record.of(R)], ret: (default_1$8), isOperator: true })], [this, ...args]);
    }
    [">"](...args) {
        return sqlFunction(">", [({ R }) => ({ args: [Record.of(R), Record.of(R)], ret: (default_1$8), isOperator: true })], [this, ...args]);
    }
    ["*="](...args) {
        return sqlFunction("*=", [({ R }) => ({ args: [Record.of(R), Record.of(R)], ret: (default_1$8), isOperator: true })], [this, ...args]);
    }
    ["*>="](...args) {
        return sqlFunction("*>=", [({ R }) => ({ args: [Record.of(R), Record.of(R)], ret: (default_1$8), isOperator: true })], [this, ...args]);
    }
    ["*>"](...args) {
        return sqlFunction("*>", [({ R }) => ({ args: [Record.of(R), Record.of(R)], ret: (default_1$8), isOperator: true })], [this, ...args]);
    }
    ["*<="](...args) {
        return sqlFunction("*<=", [({ R }) => ({ args: [Record.of(R), Record.of(R)], ret: (default_1$8), isOperator: true })], [this, ...args]);
    }
    ["*<"](...args) {
        return sqlFunction("*<", [({ R }) => ({ args: [Record.of(R), Record.of(R)], ret: (default_1$8), isOperator: true })], [this, ...args]);
    }
    ["*<>"](...args) {
        return sqlFunction("*<>", [({ R }) => ({ args: [Record.of(R), Record.of(R)], ret: (default_1$8), isOperator: true })], [this, ...args]);
    }
    ["<="](...args) {
        return sqlFunction("<=", [({ R }) => ({ args: [Record.of(R), Record.of(R)], ret: (default_1$8), isOperator: true })], [this, ...args]);
    }
    ["<"](...args) {
        return sqlFunction("<", [({ R }) => ({ args: [Record.of(R), Record.of(R)], ret: (default_1$8), isOperator: true })], [this, ...args]);
    }
    ["<>"](...args) {
        return sqlFunction("<>", [({ R }) => ({ args: [Record.of(R), Record.of(R)], ret: (default_1$8), isOperator: true })], [this, ...args]);
    }
}

class refcursor extends Any {
    static new(v) { return new refcursor(v); }
    static parse(v) { return v; }
    static typeString() { return "refcursor"; }
    asAggregate() {
        return undefined;
    }
    cursorToXml(...args) {
        return sqlFunction("cursor_to_xml", [{ args: [(refcursor), (default_1$4), (default_1$8), (default_1$8), (default_1$1)], ret: (xml$1), isOperator: false }], [this, ...args]);
    }
    cursorToXmlschema(...args) {
        return sqlFunction("cursor_to_xmlschema", [{ args: [(refcursor), (default_1$8), (default_1$8), (default_1$1)], ret: (xml$1), isOperator: false }], [this, ...args]);
    }
}

class regclass$1 extends Any {
    static new(v) { return new regclass$1(v); }
    static parse(v) { return v; }
    static typeString() { return "regclass"; }
    asAggregate() {
        return undefined;
    }
    brinDesummarizeRange(...args) {
        return sqlFunction("brin_desummarize_range", [{ args: [(regclass$1), (default_1$3)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    brinSummarizeNewValues(...args) {
        return sqlFunction("brin_summarize_new_values", [{ args: [(regclass$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    brinSummarizeRange(...args) {
        return sqlFunction("brin_summarize_range", [{ args: [(regclass$1), (default_1$3)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    currval(...args) {
        return sqlFunction("currval", [{ args: [(regclass$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    ginCleanPendingList(...args) {
        return sqlFunction("gin_clean_pending_list", [{ args: [(regclass$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    nextval(...args) {
        return sqlFunction("nextval", [{ args: [(regclass$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgColumnIsUpdatable(...args) {
        return sqlFunction("pg_column_is_updatable", [{ args: [(regclass$1), (default_1$5), (default_1$8)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgExtensionConfigDump(...args) {
        return sqlFunction("pg_extension_config_dump", [{ args: [(regclass$1), (default_1$1)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    pgGetReplicaIdentityIndex(...args) {
        return sqlFunction("pg_get_replica_identity_index", [{ args: [(regclass$1)], ret: (regclass$1), isOperator: false }], [this, ...args]);
    }
    pgIndexColumnHasProperty(...args) {
        return sqlFunction("pg_index_column_has_property", [{ args: [(regclass$1), (default_1$4), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgIndexHasProperty(...args) {
        return sqlFunction("pg_index_has_property", [{ args: [(regclass$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgIndexesSize(...args) {
        return sqlFunction("pg_indexes_size", [{ args: [(regclass$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgNextoid(...args) {
        return sqlFunction("pg_nextoid", [{ args: [(regclass$1), (name$1), (regclass$1)], ret: (oid$1), isOperator: false }], [this, ...args]);
    }
    pgPartitionAncestors(...args) {
        return sqlFunction("pg_partition_ancestors", [{ args: [(regclass$1)], ret: Setof.ofSchema({ relid: (regclass$1) }), isOperator: false }], [this, ...args]);
    }
    pgPartitionRoot(...args) {
        return sqlFunction("pg_partition_root", [{ args: [(regclass$1)], ret: (regclass$1), isOperator: false }], [this, ...args]);
    }
    pgPartitionTree(...args) {
        return sqlFunction("pg_partition_tree", [{ args: [(regclass$1)], ret: Setof.ofSchema({ relid: (regclass$1), parentrelid: (regclass$1), isleaf: (default_1$8), level: (default_1$4) }), isOperator: false }], [this, ...args]);
    }
    pgRelationFilenode(...args) {
        return sqlFunction("pg_relation_filenode", [{ args: [(regclass$1)], ret: (oid$1), isOperator: false }], [this, ...args]);
    }
    pgRelationFilepath(...args) {
        return sqlFunction("pg_relation_filepath", [{ args: [(regclass$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    pgRelationIsPublishable(...args) {
        return sqlFunction("pg_relation_is_publishable", [{ args: [(regclass$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgRelationIsUpdatable(...args) {
        return sqlFunction("pg_relation_is_updatable", [{ args: [(regclass$1), (default_1$8)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    pgRelationSize(...args) {
        return sqlFunction("pg_relation_size", [{ args: [(regclass$1)], ret: (default_1$3), isOperator: false }, { args: [(regclass$1), (default_1$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgSequenceLastValue(...args) {
        return sqlFunction("pg_sequence_last_value", [{ args: [(regclass$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgTableSize(...args) {
        return sqlFunction("pg_table_size", [{ args: [(regclass$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgTotalRelationSize(...args) {
        return sqlFunction("pg_total_relation_size", [{ args: [(regclass$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    setval(...args) {
        return sqlFunction("setval", [{ args: [(regclass$1), (default_1$3)], ret: (default_1$3), isOperator: false }, { args: [(regclass$1), (default_1$3), (default_1$8)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    tableToXml(...args) {
        return sqlFunction("table_to_xml", [{ args: [(regclass$1), (default_1$8), (default_1$8), (default_1$1)], ret: (xml$1), isOperator: false }], [this, ...args]);
    }
    tableToXmlAndXmlschema(...args) {
        return sqlFunction("table_to_xml_and_xmlschema", [{ args: [(regclass$1), (default_1$8), (default_1$8), (default_1$1)], ret: (xml$1), isOperator: false }], [this, ...args]);
    }
    tableToXmlschema(...args) {
        return sqlFunction("table_to_xmlschema", [{ args: [(regclass$1), (default_1$8), (default_1$8), (default_1$1)], ret: (xml$1), isOperator: false }], [this, ...args]);
    }
}

class regcollation extends Any {
    static new(v) { return new regcollation(v); }
    static parse(v) { return v; }
    static typeString() { return "regcollation"; }
    asAggregate() {
        return undefined;
    }
}

class regconfig extends Any {
    static new(v) { return new regconfig(v); }
    static parse(v) { return v; }
    static typeString() { return "regconfig"; }
    asAggregate() {
        return undefined;
    }
    jsonToTsvector(...args) {
        return sqlFunction("json_to_tsvector", [{ args: [(regconfig), (json), (jsonb)], ret: (tsvector), isOperator: false }], [this, ...args]);
    }
    jsonbToTsvector(...args) {
        return sqlFunction("jsonb_to_tsvector", [{ args: [(regconfig), (jsonb), (jsonb)], ret: (tsvector), isOperator: false }], [this, ...args]);
    }
    phrasetoTsquery(...args) {
        return sqlFunction("phraseto_tsquery", [{ args: [(regconfig), (default_1$1)], ret: (tsquery), isOperator: false }], [this, ...args]);
    }
    plaintoTsquery(...args) {
        return sqlFunction("plainto_tsquery", [{ args: [(regconfig), (default_1$1)], ret: (tsquery), isOperator: false }], [this, ...args]);
    }
    toTsquery(...args) {
        return sqlFunction("to_tsquery", [{ args: [(regconfig), (default_1$1)], ret: (tsquery), isOperator: false }], [this, ...args]);
    }
    toTsvector(...args) {
        return sqlFunction("to_tsvector", [{ args: [(regconfig), (json)], ret: (tsvector), isOperator: false }, { args: [(regconfig), (jsonb)], ret: (tsvector), isOperator: false }, { args: [(regconfig), (default_1$1)], ret: (tsvector), isOperator: false }], [this, ...args]);
    }
    tsDebug(...args) {
        return sqlFunction("ts_debug", [{ args: [(regconfig), (default_1$1)], ret: Setof.ofSchema({ alias: (default_1$1), description: (default_1$1), token: (default_1$1), dictionaries: Array$1.of((regdictionary)), dictionary: (regdictionary), lexemes: Array$1.of((default_1$1)) }), isOperator: false }], [this, ...args]);
    }
    tsHeadline(...args) {
        return sqlFunction("ts_headline", [{ args: [(regconfig), (json), (tsquery)], ret: (json), isOperator: false }, { args: [(regconfig), (json), (tsquery), (default_1$1)], ret: (json), isOperator: false }, { args: [(regconfig), (jsonb), (tsquery)], ret: (jsonb), isOperator: false }, { args: [(regconfig), (jsonb), (tsquery), (default_1$1)], ret: (jsonb), isOperator: false }, { args: [(regconfig), (default_1$1), (tsquery)], ret: (default_1$1), isOperator: false }, { args: [(regconfig), (default_1$1), (tsquery), (default_1$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    websearchToTsquery(...args) {
        return sqlFunction("websearch_to_tsquery", [{ args: [(regconfig), (default_1$1)], ret: (tsquery), isOperator: false }], [this, ...args]);
    }
}

class regdictionary extends Any {
    static new(v) { return new regdictionary(v); }
    static parse(v) { return v; }
    static typeString() { return "regdictionary"; }
    asAggregate() {
        return undefined;
    }
    tsLexize(...args) {
        return sqlFunction("ts_lexize", [{ args: [(regdictionary), (default_1$1)], ret: Array$1.of((default_1$1)), isOperator: false }], [this, ...args]);
    }
}

class regnamespace extends Any {
    static new(v) { return new regnamespace(v); }
    static parse(v) { return v; }
    static typeString() { return "regnamespace"; }
    asAggregate() {
        return undefined;
    }
    pgImportSystemCollations(...args) {
        return sqlFunction("pg_import_system_collations", [{ args: [(regnamespace)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
}

class regoper extends Any {
    static new(v) { return new regoper(v); }
    static parse(v) { return v; }
    static typeString() { return "regoper"; }
    asAggregate() {
        return undefined;
    }
}

class regoperator extends Any {
    static new(v) { return new regoperator(v); }
    static parse(v) { return v; }
    static typeString() { return "regoperator"; }
    asAggregate() {
        return undefined;
    }
}

class regproc extends Any {
    static new(v) { return new regproc(v); }
    static parse(v) { return v; }
    static typeString() { return "regproc"; }
    asAggregate() {
        return undefined;
    }
}

class regprocedure extends Any {
    static new(v) { return new regprocedure(v); }
    static parse(v) { return v; }
    static typeString() { return "regprocedure"; }
    asAggregate() {
        return undefined;
    }
}

class regrole extends Any {
    static new(v) { return new regrole(v); }
    static parse(v) { return v; }
    static typeString() { return "regrole"; }
    asAggregate() {
        return undefined;
    }
}

class regtype extends Any {
    static new(v) { return new regtype(v); }
    static parse(v) { return v; }
    static typeString() { return "regtype"; }
    asAggregate() {
        return undefined;
    }
    pgBasetype(...args) {
        return sqlFunction("pg_basetype", [{ args: [(regtype)], ret: (regtype), isOperator: false }], [this, ...args]);
    }
}

let default_1$1 = class default_1 extends Any {
    static new(v) { return new default_1$1(v); }
    static serializeParamTypes = undefined;
    static parse(v) { return typeMap["text"].parse(v); }
    static typeString() { return "text"; }
    asAggregate() {
        return undefined;
    }
    ascii(...args) {
        return sqlFunction("ascii", [{ args: [(default_1$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    binaryUpgradeAddSubRelState(...args) {
        return sqlFunction("binary_upgrade_add_sub_rel_state", [{ args: [(default_1$1), (oid$1), (char$1), (pg_lsn)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    binaryUpgradeCreateEmptyExtension(...args) {
        return sqlFunction("binary_upgrade_create_empty_extension", [{ args: [(default_1$1), (default_1$1), (default_1$8), (default_1$1), Array$1.of((oid$1)), Array$1.of((default_1$1)), Array$1.of((default_1$1))], ret: (_void), isOperator: false }], [this, ...args]);
    }
    binaryUpgradeReploriginAdvance(...args) {
        return sqlFunction("binary_upgrade_replorigin_advance", [{ args: [(default_1$1), (pg_lsn)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    bitLength(...args) {
        return sqlFunction("bit_length", [{ args: [(default_1$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    btrim(...args) {
        return sqlFunction("btrim", [{ args: [(default_1$1)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    bttextPatternCmp(...args) {
        return sqlFunction("bttext_pattern_cmp", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    bttextcmp(...args) {
        return sqlFunction("bttextcmp", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    bttextnamecmp(...args) {
        return sqlFunction("bttextnamecmp", [{ args: [(default_1$1), (name$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    char(...args) {
        return sqlFunction("char", [{ args: [(default_1$1)], ret: (char$1), isOperator: false }], [this, ...args]);
    }
    charLength(...args) {
        return sqlFunction("char_length", [{ args: [(default_1$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    characterLength(...args) {
        return sqlFunction("character_length", [{ args: [(default_1$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    concatWs(...args) {
        return sqlFunction("concat_ws", [{ args: [(default_1$1), (Any)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    convertTo(...args) {
        return sqlFunction("convert_to", [{ args: [(default_1$1), (name$1)], ret: (bytea), isOperator: false }], [this, ...args]);
    }
    currentSetting(...args) {
        return sqlFunction("current_setting", [{ args: [(default_1$1)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$8)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    currtid2(...args) {
        return sqlFunction("currtid2", [{ args: [(default_1$1), (tid)], ret: (tid), isOperator: false }], [this, ...args]);
    }
    datePart(...args) {
        return sqlFunction("date_part", [{ args: [(default_1$1), (date$1)], ret: (default_1$6), isOperator: false }, { args: [(default_1$1), (interval$1)], ret: (default_1$6), isOperator: false }, { args: [(default_1$1), (time$1)], ret: (default_1$6), isOperator: false }, { args: [(default_1$1), (timestamp$1)], ret: (default_1$6), isOperator: false }, { args: [(default_1$1), (timestamptz$1)], ret: (default_1$6), isOperator: false }, { args: [(default_1$1), (timetz$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    dateTrunc(...args) {
        return sqlFunction("date_trunc", [{ args: [(default_1$1), (interval$1)], ret: (interval$1), isOperator: false }, { args: [(default_1$1), (timestamp$1)], ret: (timestamp$1), isOperator: false }, { args: [(default_1$1), (timestamptz$1)], ret: (timestamptz$1), isOperator: false }, { args: [(default_1$1), (timestamptz$1), (default_1$1)], ret: (timestamptz$1), isOperator: false }], [this, ...args]);
    }
    decode(...args) {
        return sqlFunction("decode", [{ args: [(default_1$1), (default_1$1)], ret: (bytea), isOperator: false }], [this, ...args]);
    }
    extract(...args) {
        return sqlFunction("extract", [{ args: [(default_1$1), (date$1)], ret: (default_1$2), isOperator: false }, { args: [(default_1$1), (interval$1)], ret: (default_1$2), isOperator: false }, { args: [(default_1$1), (time$1)], ret: (default_1$2), isOperator: false }, { args: [(default_1$1), (timestamp$1)], ret: (default_1$2), isOperator: false }, { args: [(default_1$1), (timestamptz$1)], ret: (default_1$2), isOperator: false }, { args: [(default_1$1), (timetz$1)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    format(...args) {
        return sqlFunction("format", [{ args: [(default_1$1)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (Any)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    ginCmpTslexeme(...args) {
        return sqlFunction("gin_cmp_tslexeme", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    ginCompareJsonb(...args) {
        return sqlFunction("gin_compare_jsonb", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    hasAnyColumnPrivilege(...args) {
        return sqlFunction("has_any_column_privilege", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    hasColumnPrivilege(...args) {
        return sqlFunction("has_column_privilege", [{ args: [(default_1$1), (default_1$5), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    hasDatabasePrivilege(...args) {
        return sqlFunction("has_database_privilege", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    hasForeignDataWrapperPrivilege(...args) {
        return sqlFunction("has_foreign_data_wrapper_privilege", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    hasFunctionPrivilege(...args) {
        return sqlFunction("has_function_privilege", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    hasLanguagePrivilege(...args) {
        return sqlFunction("has_language_privilege", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    hasParameterPrivilege(...args) {
        return sqlFunction("has_parameter_privilege", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    hasSchemaPrivilege(...args) {
        return sqlFunction("has_schema_privilege", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    hasSequencePrivilege(...args) {
        return sqlFunction("has_sequence_privilege", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    hasServerPrivilege(...args) {
        return sqlFunction("has_server_privilege", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    hasTablePrivilege(...args) {
        return sqlFunction("has_table_privilege", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    hasTablespacePrivilege(...args) {
        return sqlFunction("has_tablespace_privilege", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    hasTypePrivilege(...args) {
        return sqlFunction("has_type_privilege", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    hashtext(...args) {
        return sqlFunction("hashtext", [{ args: [(default_1$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    hashtextextended(...args) {
        return sqlFunction("hashtextextended", [{ args: [(default_1$1), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    initcap(...args) {
        return sqlFunction("initcap", [{ args: [(default_1$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    isNormalized(...args) {
        return sqlFunction("is_normalized", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    left(...args) {
        return sqlFunction("left", [{ args: [(default_1$1), (default_1$4)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    length(...args) {
        return sqlFunction("length", [{ args: [(default_1$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    like(...args) {
        return sqlFunction("like", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    likeEscape(...args) {
        return sqlFunction("like_escape", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    loImport(...args) {
        return sqlFunction("lo_import", [{ args: [(default_1$1)], ret: (oid$1), isOperator: false }, { args: [(default_1$1), (oid$1)], ret: (oid$1), isOperator: false }], [this, ...args]);
    }
    lower(...args) {
        return sqlFunction("lower", [{ args: [(default_1$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    lpad(...args) {
        return sqlFunction("lpad", [{ args: [(default_1$1), (default_1$4)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$4), (default_1$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    ltrim(...args) {
        return sqlFunction("ltrim", [{ args: [(default_1$1)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    max(...args) {
        return sqlFunction("max", [{ args: [(default_1$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    md5(...args) {
        return sqlFunction("md5", [{ args: [(default_1$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    name(...args) {
        return sqlFunction("name", [{ args: [(default_1$1)], ret: (name$1), isOperator: false }], [this, ...args]);
    }
    normalize(...args) {
        return sqlFunction("normalize", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    notlike(...args) {
        return sqlFunction("notlike", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    octetLength(...args) {
        return sqlFunction("octet_length", [{ args: [(default_1$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    overlay(...args) {
        return sqlFunction("overlay", [{ args: [(default_1$1), (default_1$1), (default_1$4)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$4), (default_1$4)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    parseIdent(...args) {
        return sqlFunction("parse_ident", [{ args: [(default_1$1), (default_1$8)], ret: Array$1.of((default_1$1)), isOperator: false }], [this, ...args]);
    }
    pgBackupStart(...args) {
        return sqlFunction("pg_backup_start", [{ args: [(default_1$1), (default_1$8)], ret: (pg_lsn), isOperator: false }], [this, ...args]);
    }
    pgCreateRestorePoint(...args) {
        return sqlFunction("pg_create_restore_point", [{ args: [(default_1$1)], ret: (pg_lsn), isOperator: false }], [this, ...args]);
    }
    pgCurrentLogfile(...args) {
        return sqlFunction("pg_current_logfile", [{ args: [(default_1$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    pgGetObjectAddress(...args) {
        return sqlFunction("pg_get_object_address", [{ args: [(default_1$1), Array$1.of((default_1$1)), Array$1.of((default_1$1))], ret: Record.of({ classid: (oid$1), objid: (oid$1), objsubid: (default_1$4) }), isOperator: false }], [this, ...args]);
    }
    pgGetSerialSequence(...args) {
        return sqlFunction("pg_get_serial_sequence", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    pgGetViewdef(...args) {
        return sqlFunction("pg_get_viewdef", [{ args: [(default_1$1)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$8)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    pgInputErrorInfo(...args) {
        return sqlFunction("pg_input_error_info", [{ args: [(default_1$1), (default_1$1)], ret: Record.of({ message: (default_1$1), detail: (default_1$1), hint: (default_1$1), sql_error_code: (default_1$1) }), isOperator: false }], [this, ...args]);
    }
    pgInputIsValid(...args) {
        return sqlFunction("pg_input_is_valid", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgLsDir(...args) {
        return sqlFunction("pg_ls_dir", [{ args: [(default_1$1)], ret: Setof.ofSchema({}), isOperator: false }, { args: [(default_1$1), (default_1$8), (default_1$8)], ret: Setof.ofSchema({}), isOperator: false }], [this, ...args]);
    }
    pgLsReplslotdir(...args) {
        return sqlFunction("pg_ls_replslotdir", [{ args: [(default_1$1)], ret: Setof.ofSchema({ name: (default_1$1), size: (default_1$3), modification: (timestamptz$1) }), isOperator: false }], [this, ...args]);
    }
    pgNotify(...args) {
        return sqlFunction("pg_notify", [{ args: [(default_1$1), (default_1$1)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    pgReadBinaryFile(...args) {
        return sqlFunction("pg_read_binary_file", [{ args: [(default_1$1)], ret: (bytea), isOperator: false }, { args: [(default_1$1), (default_1$8)], ret: (bytea), isOperator: false }, { args: [(default_1$1), (default_1$3), (default_1$3)], ret: (bytea), isOperator: false }, { args: [(default_1$1), (default_1$3), (default_1$3), (default_1$8)], ret: (bytea), isOperator: false }], [this, ...args]);
    }
    pgReadFile(...args) {
        return sqlFunction("pg_read_file", [{ args: [(default_1$1)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$8)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$3), (default_1$3)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$3), (default_1$3), (default_1$8)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    pgReplicationOriginAdvance(...args) {
        return sqlFunction("pg_replication_origin_advance", [{ args: [(default_1$1), (pg_lsn)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    pgReplicationOriginCreate(...args) {
        return sqlFunction("pg_replication_origin_create", [{ args: [(default_1$1)], ret: (oid$1), isOperator: false }], [this, ...args]);
    }
    pgReplicationOriginDrop(...args) {
        return sqlFunction("pg_replication_origin_drop", [{ args: [(default_1$1)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    pgReplicationOriginOid(...args) {
        return sqlFunction("pg_replication_origin_oid", [{ args: [(default_1$1)], ret: (oid$1), isOperator: false }], [this, ...args]);
    }
    pgReplicationOriginProgress(...args) {
        return sqlFunction("pg_replication_origin_progress", [{ args: [(default_1$1), (default_1$8)], ret: (pg_lsn), isOperator: false }], [this, ...args]);
    }
    pgReplicationOriginSessionSetup(...args) {
        return sqlFunction("pg_replication_origin_session_setup", [{ args: [(default_1$1)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    pgSettingsGetFlags(...args) {
        return sqlFunction("pg_settings_get_flags", [{ args: [(default_1$1)], ret: Array$1.of((default_1$1)), isOperator: false }], [this, ...args]);
    }
    pgSizeBytes(...args) {
        return sqlFunction("pg_size_bytes", [{ args: [(default_1$1)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    pgSplitWalfileName(...args) {
        return sqlFunction("pg_split_walfile_name", [{ args: [(default_1$1)], ret: Record.of({ segment_number: (default_1$2), timeline_id: (default_1$3) }), isOperator: false }], [this, ...args]);
    }
    pgStatFile(...args) {
        return sqlFunction("pg_stat_file", [{ args: [(default_1$1)], ret: Record.of({ size: (default_1$3), access: (timestamptz$1), modification: (timestamptz$1), change: (timestamptz$1), creation: (timestamptz$1), isdir: (default_1$8) }), isOperator: false }, { args: [(default_1$1), (default_1$8)], ret: Record.of({ size: (default_1$3), access: (timestamptz$1), modification: (timestamptz$1), change: (timestamptz$1), creation: (timestamptz$1), isdir: (default_1$8) }), isOperator: false }], [this, ...args]);
    }
    pgStatGetProgressInfo(...args) {
        return sqlFunction("pg_stat_get_progress_info", [{ args: [(default_1$1)], ret: Setof.ofSchema({ pid: (default_1$4), datid: (oid$1), relid: (oid$1), param1: (default_1$3), param2: (default_1$3), param3: (default_1$3), param4: (default_1$3), param5: (default_1$3), param6: (default_1$3), param7: (default_1$3), param8: (default_1$3), param9: (default_1$3), param10: (default_1$3), param11: (default_1$3), param12: (default_1$3), param13: (default_1$3), param14: (default_1$3), param15: (default_1$3), param16: (default_1$3), param17: (default_1$3), param18: (default_1$3), param19: (default_1$3), param20: (default_1$3) }), isOperator: false }], [this, ...args]);
    }
    pgStatGetReplicationSlot(...args) {
        return sqlFunction("pg_stat_get_replication_slot", [{ args: [(default_1$1)], ret: Record.of({ slot_name: (default_1$1), spill_txns: (default_1$3), spill_count: (default_1$3), spill_bytes: (default_1$3), stream_txns: (default_1$3), stream_count: (default_1$3), stream_bytes: (default_1$3), total_txns: (default_1$3), total_bytes: (default_1$3), stats_reset: (timestamptz$1) }), isOperator: false }], [this, ...args]);
    }
    pgStatHaveStats(...args) {
        return sqlFunction("pg_stat_have_stats", [{ args: [(default_1$1), (oid$1), (oid$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgStatResetReplicationSlot(...args) {
        return sqlFunction("pg_stat_reset_replication_slot", [{ args: [(default_1$1)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    pgStatResetShared(...args) {
        return sqlFunction("pg_stat_reset_shared", [{ args: [(default_1$1)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    pgStatResetSlru(...args) {
        return sqlFunction("pg_stat_reset_slru", [{ args: [(default_1$1)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    phrasetoTsquery(...args) {
        return sqlFunction("phraseto_tsquery", [{ args: [(default_1$1)], ret: (tsquery), isOperator: false }], [this, ...args]);
    }
    plaintoTsquery(...args) {
        return sqlFunction("plainto_tsquery", [{ args: [(default_1$1)], ret: (tsquery), isOperator: false }], [this, ...args]);
    }
    position(...args) {
        return sqlFunction("position", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    queryToXml(...args) {
        return sqlFunction("query_to_xml", [{ args: [(default_1$1), (default_1$8), (default_1$8), (default_1$1)], ret: (xml$1), isOperator: false }], [this, ...args]);
    }
    queryToXmlAndXmlschema(...args) {
        return sqlFunction("query_to_xml_and_xmlschema", [{ args: [(default_1$1), (default_1$8), (default_1$8), (default_1$1)], ret: (xml$1), isOperator: false }], [this, ...args]);
    }
    queryToXmlschema(...args) {
        return sqlFunction("query_to_xmlschema", [{ args: [(default_1$1), (default_1$8), (default_1$8), (default_1$1)], ret: (xml$1), isOperator: false }], [this, ...args]);
    }
    quoteIdent(...args) {
        return sqlFunction("quote_ident", [{ args: [(default_1$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    quoteLiteral(...args) {
        return sqlFunction("quote_literal", [{ args: [(default_1$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    quoteNullable(...args) {
        return sqlFunction("quote_nullable", [{ args: [(default_1$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    regclass(...args) {
        return sqlFunction("regclass", [{ args: [(default_1$1)], ret: (regclass$1), isOperator: false }], [this, ...args]);
    }
    regexpCount(...args) {
        return sqlFunction("regexp_count", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$4), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$4)], ret: (default_1$4), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$4), (default_1$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    regexpInstr(...args) {
        return sqlFunction("regexp_instr", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$4), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$4)], ret: (default_1$4), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$4), (default_1$4)], ret: (default_1$4), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$4), (default_1$4), (default_1$4)], ret: (default_1$4), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$4), (default_1$4), (default_1$4), (default_1$1)], ret: (default_1$4), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$4), (default_1$4), (default_1$4), (default_1$1), (default_1$4)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    regexpLike(...args) {
        return sqlFunction("regexp_like", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    regexpMatch(...args) {
        return sqlFunction("regexp_match", [{ args: [(default_1$1), (default_1$1)], ret: Array$1.of((default_1$1)), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$1)], ret: Array$1.of((default_1$1)), isOperator: false }], [this, ...args]);
    }
    regexpMatches(...args) {
        return sqlFunction("regexp_matches", [{ args: [(default_1$1), (default_1$1)], ret: Setof.ofSchema({}), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$1)], ret: Setof.ofSchema({}), isOperator: false }], [this, ...args]);
    }
    regexpReplace(...args) {
        return sqlFunction("regexp_replace", [{ args: [(default_1$1), (default_1$1), (default_1$1)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$1), (default_1$4)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$1), (default_1$4), (default_1$4)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$1), (default_1$4), (default_1$4), (default_1$1)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$1), (default_1$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    regexpSplitToArray(...args) {
        return sqlFunction("regexp_split_to_array", [{ args: [(default_1$1), (default_1$1)], ret: Array$1.of((default_1$1)), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$1)], ret: Array$1.of((default_1$1)), isOperator: false }], [this, ...args]);
    }
    regexpSplitToTable(...args) {
        return sqlFunction("regexp_split_to_table", [{ args: [(default_1$1), (default_1$1)], ret: Setof.ofSchema({}), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$1)], ret: Setof.ofSchema({}), isOperator: false }], [this, ...args]);
    }
    regexpSubstr(...args) {
        return sqlFunction("regexp_substr", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$4)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$4), (default_1$4)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$4), (default_1$4), (default_1$1)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$4), (default_1$4), (default_1$1), (default_1$4)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    repeat(...args) {
        return sqlFunction("repeat", [{ args: [(default_1$1), (default_1$4)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    replace(...args) {
        return sqlFunction("replace", [{ args: [(default_1$1), (default_1$1), (default_1$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    reverse(...args) {
        return sqlFunction("reverse", [{ args: [(default_1$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    right(...args) {
        return sqlFunction("right", [{ args: [(default_1$1), (default_1$4)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    rowSecurityActive(...args) {
        return sqlFunction("row_security_active", [{ args: [(default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    rpad(...args) {
        return sqlFunction("rpad", [{ args: [(default_1$1), (default_1$4)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$4), (default_1$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    rtrim(...args) {
        return sqlFunction("rtrim", [{ args: [(default_1$1)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    setConfig(...args) {
        return sqlFunction("set_config", [{ args: [(default_1$1), (default_1$1), (default_1$8)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    similarEscape(...args) {
        return sqlFunction("similar_escape", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    similarToEscape(...args) {
        return sqlFunction("similar_to_escape", [{ args: [(default_1$1)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    splitPart(...args) {
        return sqlFunction("split_part", [{ args: [(default_1$1), (default_1$1), (default_1$4)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    startsWith(...args) {
        return sqlFunction("starts_with", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    stringAgg(...args) {
        return sqlFunction("string_agg", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    stringToArray(...args) {
        return sqlFunction("string_to_array", [{ args: [(default_1$1), (default_1$1)], ret: Array$1.of((default_1$1)), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$1)], ret: Array$1.of((default_1$1)), isOperator: false }], [this, ...args]);
    }
    stringToTable(...args) {
        return sqlFunction("string_to_table", [{ args: [(default_1$1), (default_1$1)], ret: Setof.ofSchema({}), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$1)], ret: Setof.ofSchema({}), isOperator: false }], [this, ...args]);
    }
    strpos(...args) {
        return sqlFunction("strpos", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    substr(...args) {
        return sqlFunction("substr", [{ args: [(default_1$1), (default_1$4)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$4), (default_1$4)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    substring(...args) {
        return sqlFunction("substring", [{ args: [(default_1$1), (default_1$4)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$4), (default_1$4)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$1)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    textGe(...args) {
        return sqlFunction("text_ge", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    textGt(...args) {
        return sqlFunction("text_gt", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    textLarger(...args) {
        return sqlFunction("text_larger", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    textLe(...args) {
        return sqlFunction("text_le", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    textLt(...args) {
        return sqlFunction("text_lt", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    textPatternGe(...args) {
        return sqlFunction("text_pattern_ge", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    textPatternGt(...args) {
        return sqlFunction("text_pattern_gt", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    textPatternLe(...args) {
        return sqlFunction("text_pattern_le", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    textPatternLt(...args) {
        return sqlFunction("text_pattern_lt", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    textSmaller(...args) {
        return sqlFunction("text_smaller", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    textanycat(...args) {
        return sqlFunction("textanycat", [({ T }) => ({ args: [(default_1$1), T], ret: (default_1$1), isOperator: false })], [this, ...args]);
    }
    textcat(...args) {
        return sqlFunction("textcat", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    texteq(...args) {
        return sqlFunction("texteq", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    texteqname(...args) {
        return sqlFunction("texteqname", [{ args: [(default_1$1), (name$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    textgename(...args) {
        return sqlFunction("textgename", [{ args: [(default_1$1), (name$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    textgtname(...args) {
        return sqlFunction("textgtname", [{ args: [(default_1$1), (name$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    texticlike(...args) {
        return sqlFunction("texticlike", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    texticnlike(...args) {
        return sqlFunction("texticnlike", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    texticregexeq(...args) {
        return sqlFunction("texticregexeq", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    texticregexne(...args) {
        return sqlFunction("texticregexne", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    textlen(...args) {
        return sqlFunction("textlen", [{ args: [(default_1$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    textlename(...args) {
        return sqlFunction("textlename", [{ args: [(default_1$1), (name$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    textlike(...args) {
        return sqlFunction("textlike", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    textltname(...args) {
        return sqlFunction("textltname", [{ args: [(default_1$1), (name$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    textne(...args) {
        return sqlFunction("textne", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    textnename(...args) {
        return sqlFunction("textnename", [{ args: [(default_1$1), (name$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    textnlike(...args) {
        return sqlFunction("textnlike", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    textregexeq(...args) {
        return sqlFunction("textregexeq", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    textregexne(...args) {
        return sqlFunction("textregexne", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timezone(...args) {
        return sqlFunction("timezone", [{ args: [(default_1$1), (timestamptz$1)], ret: (timestamp$1), isOperator: false }, { args: [(default_1$1), (timestamp$1)], ret: (timestamptz$1), isOperator: false }, { args: [(default_1$1), (timetz$1)], ret: (timetz$1), isOperator: false }], [this, ...args]);
    }
    toAscii(...args) {
        return sqlFunction("to_ascii", [{ args: [(default_1$1)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$4)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (name$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    toDate(...args) {
        return sqlFunction("to_date", [{ args: [(default_1$1), (default_1$1)], ret: (date$1), isOperator: false }], [this, ...args]);
    }
    toNumber(...args) {
        return sqlFunction("to_number", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$2), isOperator: false }], [this, ...args]);
    }
    toRegclass(...args) {
        return sqlFunction("to_regclass", [{ args: [(default_1$1)], ret: (regclass$1), isOperator: false }], [this, ...args]);
    }
    toRegcollation(...args) {
        return sqlFunction("to_regcollation", [{ args: [(default_1$1)], ret: (regcollation), isOperator: false }], [this, ...args]);
    }
    toRegnamespace(...args) {
        return sqlFunction("to_regnamespace", [{ args: [(default_1$1)], ret: (regnamespace), isOperator: false }], [this, ...args]);
    }
    toRegoper(...args) {
        return sqlFunction("to_regoper", [{ args: [(default_1$1)], ret: (regoper), isOperator: false }], [this, ...args]);
    }
    toRegoperator(...args) {
        return sqlFunction("to_regoperator", [{ args: [(default_1$1)], ret: (regoperator), isOperator: false }], [this, ...args]);
    }
    toRegproc(...args) {
        return sqlFunction("to_regproc", [{ args: [(default_1$1)], ret: (regproc), isOperator: false }], [this, ...args]);
    }
    toRegprocedure(...args) {
        return sqlFunction("to_regprocedure", [{ args: [(default_1$1)], ret: (regprocedure), isOperator: false }], [this, ...args]);
    }
    toRegrole(...args) {
        return sqlFunction("to_regrole", [{ args: [(default_1$1)], ret: (regrole), isOperator: false }], [this, ...args]);
    }
    toRegtype(...args) {
        return sqlFunction("to_regtype", [{ args: [(default_1$1)], ret: (regtype), isOperator: false }], [this, ...args]);
    }
    toRegtypemod(...args) {
        return sqlFunction("to_regtypemod", [{ args: [(default_1$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    toTimestamp(...args) {
        return sqlFunction("to_timestamp", [{ args: [(default_1$1), (default_1$1)], ret: (timestamptz$1), isOperator: false }], [this, ...args]);
    }
    toTsquery(...args) {
        return sqlFunction("to_tsquery", [{ args: [(default_1$1)], ret: (tsquery), isOperator: false }], [this, ...args]);
    }
    toTsvector(...args) {
        return sqlFunction("to_tsvector", [{ args: [(default_1$1)], ret: (tsvector), isOperator: false }], [this, ...args]);
    }
    translate(...args) {
        return sqlFunction("translate", [{ args: [(default_1$1), (default_1$1), (default_1$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    tsDebug(...args) {
        return sqlFunction("ts_debug", [{ args: [(default_1$1)], ret: Setof.ofSchema({ alias: (default_1$1), description: (default_1$1), token: (default_1$1), dictionaries: Array$1.of((regdictionary)), dictionary: (regdictionary), lexemes: Array$1.of((default_1$1)) }), isOperator: false }], [this, ...args]);
    }
    tsHeadline(...args) {
        return sqlFunction("ts_headline", [{ args: [(default_1$1), (tsquery)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (tsquery), (default_1$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    tsMatchTq(...args) {
        return sqlFunction("ts_match_tq", [{ args: [(default_1$1), (tsquery)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    tsMatchTt(...args) {
        return sqlFunction("ts_match_tt", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    tsParse(...args) {
        return sqlFunction("ts_parse", [{ args: [(default_1$1), (default_1$1)], ret: Setof.ofSchema({ tokid: (default_1$4), token: (default_1$1) }), isOperator: false }], [this, ...args]);
    }
    tsStat(...args) {
        return sqlFunction("ts_stat", [{ args: [(default_1$1)], ret: Setof.ofSchema({ word: (default_1$1), ndoc: (default_1$4), nentry: (default_1$4) }), isOperator: false }, { args: [(default_1$1), (default_1$1)], ret: Setof.ofSchema({ word: (default_1$1), ndoc: (default_1$4), nentry: (default_1$4) }), isOperator: false }], [this, ...args]);
    }
    tsTokenType(...args) {
        return sqlFunction("ts_token_type", [{ args: [(default_1$1)], ret: Setof.ofSchema({ tokid: (default_1$4), alias: (default_1$1), description: (default_1$1) }), isOperator: false }], [this, ...args]);
    }
    unicodeAssigned(...args) {
        return sqlFunction("unicode_assigned", [{ args: [(default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    unistr(...args) {
        return sqlFunction("unistr", [{ args: [(default_1$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    upper(...args) {
        return sqlFunction("upper", [{ args: [(default_1$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    websearchToTsquery(...args) {
        return sqlFunction("websearch_to_tsquery", [{ args: [(default_1$1)], ret: (tsquery), isOperator: false }], [this, ...args]);
    }
    xml(...args) {
        return sqlFunction("xml", [{ args: [(default_1$1)], ret: (xml$1), isOperator: false }], [this, ...args]);
    }
    xmlIsWellFormed(...args) {
        return sqlFunction("xml_is_well_formed", [{ args: [(default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    xmlIsWellFormedContent(...args) {
        return sqlFunction("xml_is_well_formed_content", [{ args: [(default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    xmlIsWellFormedDocument(...args) {
        return sqlFunction("xml_is_well_formed_document", [{ args: [(default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    xmlcomment(...args) {
        return sqlFunction("xmlcomment", [{ args: [(default_1$1)], ret: (xml$1), isOperator: false }], [this, ...args]);
    }
    xmlexists(...args) {
        return sqlFunction("xmlexists", [{ args: [(default_1$1), (xml$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    xmltext(...args) {
        return sqlFunction("xmltext", [{ args: [(default_1$1)], ret: (xml$1), isOperator: false }], [this, ...args]);
    }
    xpath(...args) {
        return sqlFunction("xpath", [{ args: [(default_1$1), (xml$1)], ret: Array$1.of((xml$1)), isOperator: false }, { args: [(default_1$1), (xml$1), Array$1.of((default_1$1))], ret: Array$1.of((xml$1)), isOperator: false }], [this, ...args]);
    }
    xpathExists(...args) {
        return sqlFunction("xpath_exists", [{ args: [(default_1$1), (xml$1)], ret: (default_1$8), isOperator: false }, { args: [(default_1$1), (xml$1), Array$1.of((default_1$1))], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    ["^@"](...args) {
        return sqlFunction("^@", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">="](...args) {
        return sqlFunction(">=", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: true }, { args: [(default_1$1), (name$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">"](...args) {
        return sqlFunction(">", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: true }, { args: [(default_1$1), (name$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<="](...args) {
        return sqlFunction("<=", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: true }, { args: [(default_1$1), (name$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<"](...args) {
        return sqlFunction("<", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: true }, { args: [(default_1$1), (name$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["~>=~"](...args) {
        return sqlFunction("~>=~", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["~>~"](...args) {
        return sqlFunction("~>~", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["~<=~"](...args) {
        return sqlFunction("~<=~", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["~<~"](...args) {
        return sqlFunction("~<~", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: true }, { args: [(default_1$1), (name$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["~~*"](...args) {
        return sqlFunction("~~*", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["!~~*"](...args) {
        return sqlFunction("!~~*", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["~*"](...args) {
        return sqlFunction("~*", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["!~*"](...args) {
        return sqlFunction("!~*", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["~~"](...args) {
        return sqlFunction("~~", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<>"](...args) {
        return sqlFunction("<>", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: true }, { args: [(default_1$1), (name$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["!~~"](...args) {
        return sqlFunction("!~~", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["~"](...args) {
        return sqlFunction("~", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["!~"](...args) {
        return sqlFunction("!~", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["@@"](...args) {
        return sqlFunction("@@", [{ args: [(default_1$1), (tsquery)], ret: (default_1$8), isOperator: true }, { args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
};

class tid extends Any {
    static new(v) { return new tid(v); }
    static parse(v) { return v; }
    static typeString() { return "tid"; }
    asAggregate() {
        return undefined;
    }
    bttidcmp(...args) {
        return sqlFunction("bttidcmp", [{ args: [(tid), (tid)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    hashtid(...args) {
        return sqlFunction("hashtid", [{ args: [(tid)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    hashtidextended(...args) {
        return sqlFunction("hashtidextended", [{ args: [(tid), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    max(...args) {
        return sqlFunction("max", [{ args: [(tid)], ret: (tid), isOperator: false }], [this, ...args]);
    }
    tideq(...args) {
        return sqlFunction("tideq", [{ args: [(tid), (tid)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    tidge(...args) {
        return sqlFunction("tidge", [{ args: [(tid), (tid)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    tidgt(...args) {
        return sqlFunction("tidgt", [{ args: [(tid), (tid)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    tidlarger(...args) {
        return sqlFunction("tidlarger", [{ args: [(tid), (tid)], ret: (tid), isOperator: false }], [this, ...args]);
    }
    tidle(...args) {
        return sqlFunction("tidle", [{ args: [(tid), (tid)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    tidlt(...args) {
        return sqlFunction("tidlt", [{ args: [(tid), (tid)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    tidne(...args) {
        return sqlFunction("tidne", [{ args: [(tid), (tid)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    tidsmaller(...args) {
        return sqlFunction("tidsmaller", [{ args: [(tid), (tid)], ret: (tid), isOperator: false }], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [{ args: [(tid), (tid)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">="](...args) {
        return sqlFunction(">=", [{ args: [(tid), (tid)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">"](...args) {
        return sqlFunction(">", [{ args: [(tid), (tid)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<="](...args) {
        return sqlFunction("<=", [{ args: [(tid), (tid)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<"](...args) {
        return sqlFunction("<", [{ args: [(tid), (tid)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<>"](...args) {
        return sqlFunction("<>", [{ args: [(tid), (tid)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
}

class time$1 extends Any {
    static new(v) { return new time$1(v); }
    static parse(v) { return v; }
    static typeString() { return "time"; }
    asAggregate() {
        return undefined;
    }
    inRange(...args) {
        return sqlFunction("in_range", [{ args: [(time$1), (time$1), (interval$1), (default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    interval(...args) {
        return sqlFunction("interval", [{ args: [(time$1)], ret: (interval$1), isOperator: false }], [this, ...args]);
    }
    max(...args) {
        return sqlFunction("max", [{ args: [(time$1)], ret: (time$1), isOperator: false }], [this, ...args]);
    }
    overlaps(...args) {
        return sqlFunction("overlaps", [{ args: [(time$1), (interval$1), (time$1), (interval$1)], ret: (default_1$8), isOperator: false }, { args: [(time$1), (interval$1), (time$1), (time$1)], ret: (default_1$8), isOperator: false }, { args: [(time$1), (time$1), (time$1), (interval$1)], ret: (default_1$8), isOperator: false }, { args: [(time$1), (time$1), (time$1), (time$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    time(...args) {
        return sqlFunction("time", [{ args: [(time$1), (default_1$4)], ret: (time$1), isOperator: false }], [this, ...args]);
    }
    timeCmp(...args) {
        return sqlFunction("time_cmp", [{ args: [(time$1), (time$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    timeEq(...args) {
        return sqlFunction("time_eq", [{ args: [(time$1), (time$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timeGe(...args) {
        return sqlFunction("time_ge", [{ args: [(time$1), (time$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timeGt(...args) {
        return sqlFunction("time_gt", [{ args: [(time$1), (time$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timeHash(...args) {
        return sqlFunction("time_hash", [{ args: [(time$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    timeHashExtended(...args) {
        return sqlFunction("time_hash_extended", [{ args: [(time$1), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    timeLarger(...args) {
        return sqlFunction("time_larger", [{ args: [(time$1), (time$1)], ret: (time$1), isOperator: false }], [this, ...args]);
    }
    timeLe(...args) {
        return sqlFunction("time_le", [{ args: [(time$1), (time$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timeLt(...args) {
        return sqlFunction("time_lt", [{ args: [(time$1), (time$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timeMiInterval(...args) {
        return sqlFunction("time_mi_interval", [{ args: [(time$1), (interval$1)], ret: (time$1), isOperator: false }], [this, ...args]);
    }
    timeMiTime(...args) {
        return sqlFunction("time_mi_time", [{ args: [(time$1), (time$1)], ret: (interval$1), isOperator: false }], [this, ...args]);
    }
    timeNe(...args) {
        return sqlFunction("time_ne", [{ args: [(time$1), (time$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timePlInterval(...args) {
        return sqlFunction("time_pl_interval", [{ args: [(time$1), (interval$1)], ret: (time$1), isOperator: false }], [this, ...args]);
    }
    timeSmaller(...args) {
        return sqlFunction("time_smaller", [{ args: [(time$1), (time$1)], ret: (time$1), isOperator: false }], [this, ...args]);
    }
    timedatePl(...args) {
        return sqlFunction("timedate_pl", [{ args: [(time$1), (date$1)], ret: (timestamp$1), isOperator: false }], [this, ...args]);
    }
    timetz(...args) {
        return sqlFunction("timetz", [{ args: [(time$1)], ret: (timetz$1), isOperator: false }], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [{ args: [(time$1), (time$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">="](...args) {
        return sqlFunction(">=", [{ args: [(time$1), (time$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">"](...args) {
        return sqlFunction(">", [{ args: [(time$1), (time$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<="](...args) {
        return sqlFunction("<=", [{ args: [(time$1), (time$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<"](...args) {
        return sqlFunction("<", [{ args: [(time$1), (time$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["-"](...args) {
        return sqlFunction("-", [{ args: [(time$1), (interval$1)], ret: (time$1), isOperator: true }, { args: [(time$1), (time$1)], ret: (interval$1), isOperator: true }], [this, ...args]);
    }
    ["<>"](...args) {
        return sqlFunction("<>", [{ args: [(time$1), (time$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["+"](...args) {
        return sqlFunction("+", [{ args: [(time$1), (interval$1)], ret: (time$1), isOperator: true }, { args: [(time$1), (date$1)], ret: (timestamp$1), isOperator: true }], [this, ...args]);
    }
}

class timestamp$1 extends Any {
    static new(v) { return new timestamp$1(v); }
    static parse(v) { return v; }
    static typeString() { return "timestamp"; }
    asAggregate() {
        return undefined;
    }
    age(...args) {
        return sqlFunction("age", [{ args: [(timestamp$1)], ret: (interval$1), isOperator: false }, { args: [(timestamp$1), (timestamp$1)], ret: (interval$1), isOperator: false }], [this, ...args]);
    }
    date(...args) {
        return sqlFunction("date", [{ args: [(timestamp$1)], ret: (date$1), isOperator: false }], [this, ...args]);
    }
    generateSeries(...args) {
        return sqlFunction("generate_series", [{ args: [(timestamp$1), (timestamp$1), (interval$1)], ret: Setof.ofSchema({}), isOperator: false }], [this, ...args]);
    }
    inRange(...args) {
        return sqlFunction("in_range", [{ args: [(timestamp$1), (timestamp$1), (interval$1), (default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    isfinite(...args) {
        return sqlFunction("isfinite", [{ args: [(timestamp$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    max(...args) {
        return sqlFunction("max", [{ args: [(timestamp$1)], ret: (timestamp$1), isOperator: false }], [this, ...args]);
    }
    overlaps(...args) {
        return sqlFunction("overlaps", [{ args: [(timestamp$1), (interval$1), (timestamp$1), (interval$1)], ret: (default_1$8), isOperator: false }, { args: [(timestamp$1), (interval$1), (timestamp$1), (timestamp$1)], ret: (default_1$8), isOperator: false }, { args: [(timestamp$1), (timestamp$1), (timestamp$1), (interval$1)], ret: (default_1$8), isOperator: false }, { args: [(timestamp$1), (timestamp$1), (timestamp$1), (timestamp$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    time(...args) {
        return sqlFunction("time", [{ args: [(timestamp$1)], ret: (time$1), isOperator: false }], [this, ...args]);
    }
    timestamp(...args) {
        return sqlFunction("timestamp", [{ args: [(timestamp$1), (default_1$4)], ret: (timestamp$1), isOperator: false }], [this, ...args]);
    }
    timestampCmp(...args) {
        return sqlFunction("timestamp_cmp", [{ args: [(timestamp$1), (timestamp$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    timestampCmpDate(...args) {
        return sqlFunction("timestamp_cmp_date", [{ args: [(timestamp$1), (date$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    timestampCmpTimestamptz(...args) {
        return sqlFunction("timestamp_cmp_timestamptz", [{ args: [(timestamp$1), (timestamptz$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    timestampEq(...args) {
        return sqlFunction("timestamp_eq", [{ args: [(timestamp$1), (timestamp$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timestampEqDate(...args) {
        return sqlFunction("timestamp_eq_date", [{ args: [(timestamp$1), (date$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timestampEqTimestamptz(...args) {
        return sqlFunction("timestamp_eq_timestamptz", [{ args: [(timestamp$1), (timestamptz$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timestampGe(...args) {
        return sqlFunction("timestamp_ge", [{ args: [(timestamp$1), (timestamp$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timestampGeDate(...args) {
        return sqlFunction("timestamp_ge_date", [{ args: [(timestamp$1), (date$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timestampGeTimestamptz(...args) {
        return sqlFunction("timestamp_ge_timestamptz", [{ args: [(timestamp$1), (timestamptz$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timestampGt(...args) {
        return sqlFunction("timestamp_gt", [{ args: [(timestamp$1), (timestamp$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timestampGtDate(...args) {
        return sqlFunction("timestamp_gt_date", [{ args: [(timestamp$1), (date$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timestampGtTimestamptz(...args) {
        return sqlFunction("timestamp_gt_timestamptz", [{ args: [(timestamp$1), (timestamptz$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timestampHash(...args) {
        return sqlFunction("timestamp_hash", [{ args: [(timestamp$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    timestampHashExtended(...args) {
        return sqlFunction("timestamp_hash_extended", [{ args: [(timestamp$1), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    timestampLarger(...args) {
        return sqlFunction("timestamp_larger", [{ args: [(timestamp$1), (timestamp$1)], ret: (timestamp$1), isOperator: false }], [this, ...args]);
    }
    timestampLe(...args) {
        return sqlFunction("timestamp_le", [{ args: [(timestamp$1), (timestamp$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timestampLeDate(...args) {
        return sqlFunction("timestamp_le_date", [{ args: [(timestamp$1), (date$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timestampLeTimestamptz(...args) {
        return sqlFunction("timestamp_le_timestamptz", [{ args: [(timestamp$1), (timestamptz$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timestampLt(...args) {
        return sqlFunction("timestamp_lt", [{ args: [(timestamp$1), (timestamp$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timestampLtDate(...args) {
        return sqlFunction("timestamp_lt_date", [{ args: [(timestamp$1), (date$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timestampLtTimestamptz(...args) {
        return sqlFunction("timestamp_lt_timestamptz", [{ args: [(timestamp$1), (timestamptz$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timestampMi(...args) {
        return sqlFunction("timestamp_mi", [{ args: [(timestamp$1), (timestamp$1)], ret: (interval$1), isOperator: false }], [this, ...args]);
    }
    timestampMiInterval(...args) {
        return sqlFunction("timestamp_mi_interval", [{ args: [(timestamp$1), (interval$1)], ret: (timestamp$1), isOperator: false }], [this, ...args]);
    }
    timestampNe(...args) {
        return sqlFunction("timestamp_ne", [{ args: [(timestamp$1), (timestamp$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timestampNeDate(...args) {
        return sqlFunction("timestamp_ne_date", [{ args: [(timestamp$1), (date$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timestampNeTimestamptz(...args) {
        return sqlFunction("timestamp_ne_timestamptz", [{ args: [(timestamp$1), (timestamptz$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timestampPlInterval(...args) {
        return sqlFunction("timestamp_pl_interval", [{ args: [(timestamp$1), (interval$1)], ret: (timestamp$1), isOperator: false }], [this, ...args]);
    }
    timestampSmaller(...args) {
        return sqlFunction("timestamp_smaller", [{ args: [(timestamp$1), (timestamp$1)], ret: (timestamp$1), isOperator: false }], [this, ...args]);
    }
    timestamptz(...args) {
        return sqlFunction("timestamptz", [{ args: [(timestamp$1)], ret: (timestamptz$1), isOperator: false }], [this, ...args]);
    }
    timezone(...args) {
        return sqlFunction("timezone", [{ args: [(timestamp$1)], ret: (timestamptz$1), isOperator: false }], [this, ...args]);
    }
    toChar(...args) {
        return sqlFunction("to_char", [{ args: [(timestamp$1), (default_1$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    tsrange(...args) {
        return sqlFunction("tsrange", [{ args: [(timestamp$1), (timestamp$1)], ret: (tsrange$1), isOperator: false }, { args: [(timestamp$1), (timestamp$1), (default_1$1)], ret: (tsrange$1), isOperator: false }], [this, ...args]);
    }
    tsrangeSubdiff(...args) {
        return sqlFunction("tsrange_subdiff", [{ args: [(timestamp$1), (timestamp$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [{ args: [(timestamp$1), (timestamp$1)], ret: (default_1$8), isOperator: true }, { args: [(timestamp$1), (date$1)], ret: (default_1$8), isOperator: true }, { args: [(timestamp$1), (timestamptz$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">="](...args) {
        return sqlFunction(">=", [{ args: [(timestamp$1), (timestamp$1)], ret: (default_1$8), isOperator: true }, { args: [(timestamp$1), (date$1)], ret: (default_1$8), isOperator: true }, { args: [(timestamp$1), (timestamptz$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">"](...args) {
        return sqlFunction(">", [{ args: [(timestamp$1), (timestamp$1)], ret: (default_1$8), isOperator: true }, { args: [(timestamp$1), (date$1)], ret: (default_1$8), isOperator: true }, { args: [(timestamp$1), (timestamptz$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<="](...args) {
        return sqlFunction("<=", [{ args: [(timestamp$1), (timestamp$1)], ret: (default_1$8), isOperator: true }, { args: [(timestamp$1), (date$1)], ret: (default_1$8), isOperator: true }, { args: [(timestamp$1), (timestamptz$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<"](...args) {
        return sqlFunction("<", [{ args: [(timestamp$1), (timestamp$1)], ret: (default_1$8), isOperator: true }, { args: [(timestamp$1), (date$1)], ret: (default_1$8), isOperator: true }, { args: [(timestamp$1), (timestamptz$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["-"](...args) {
        return sqlFunction("-", [{ args: [(timestamp$1), (timestamp$1)], ret: (interval$1), isOperator: true }, { args: [(timestamp$1), (interval$1)], ret: (timestamp$1), isOperator: true }], [this, ...args]);
    }
    ["<>"](...args) {
        return sqlFunction("<>", [{ args: [(timestamp$1), (timestamp$1)], ret: (default_1$8), isOperator: true }, { args: [(timestamp$1), (date$1)], ret: (default_1$8), isOperator: true }, { args: [(timestamp$1), (timestamptz$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["+"](...args) {
        return sqlFunction("+", [{ args: [(timestamp$1), (interval$1)], ret: (timestamp$1), isOperator: true }], [this, ...args]);
    }
}

class timestamptz$1 extends Any {
    static new(v) { return new timestamptz$1(v); }
    static parse(v) { return v; }
    static typeString() { return "timestamptz"; }
    asAggregate() {
        return undefined;
    }
    age(...args) {
        return sqlFunction("age", [{ args: [(timestamptz$1)], ret: (interval$1), isOperator: false }, { args: [(timestamptz$1), (timestamptz$1)], ret: (interval$1), isOperator: false }], [this, ...args]);
    }
    date(...args) {
        return sqlFunction("date", [{ args: [(timestamptz$1)], ret: (date$1), isOperator: false }], [this, ...args]);
    }
    dateAdd(...args) {
        return sqlFunction("date_add", [{ args: [(timestamptz$1), (interval$1)], ret: (timestamptz$1), isOperator: false }, { args: [(timestamptz$1), (interval$1), (default_1$1)], ret: (timestamptz$1), isOperator: false }], [this, ...args]);
    }
    dateSubtract(...args) {
        return sqlFunction("date_subtract", [{ args: [(timestamptz$1), (interval$1)], ret: (timestamptz$1), isOperator: false }, { args: [(timestamptz$1), (interval$1), (default_1$1)], ret: (timestamptz$1), isOperator: false }], [this, ...args]);
    }
    generateSeries(...args) {
        return sqlFunction("generate_series", [{ args: [(timestamptz$1), (timestamptz$1), (interval$1)], ret: Setof.ofSchema({}), isOperator: false }, { args: [(timestamptz$1), (timestamptz$1), (interval$1), (default_1$1)], ret: Setof.ofSchema({}), isOperator: false }], [this, ...args]);
    }
    inRange(...args) {
        return sqlFunction("in_range", [{ args: [(timestamptz$1), (timestamptz$1), (interval$1), (default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    isfinite(...args) {
        return sqlFunction("isfinite", [{ args: [(timestamptz$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    max(...args) {
        return sqlFunction("max", [{ args: [(timestamptz$1)], ret: (timestamptz$1), isOperator: false }], [this, ...args]);
    }
    overlaps(...args) {
        return sqlFunction("overlaps", [{ args: [(timestamptz$1), (interval$1), (timestamptz$1), (interval$1)], ret: (default_1$8), isOperator: false }, { args: [(timestamptz$1), (interval$1), (timestamptz$1), (timestamptz$1)], ret: (default_1$8), isOperator: false }, { args: [(timestamptz$1), (timestamptz$1), (timestamptz$1), (interval$1)], ret: (default_1$8), isOperator: false }, { args: [(timestamptz$1), (timestamptz$1), (timestamptz$1), (timestamptz$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgSleepUntil(...args) {
        return sqlFunction("pg_sleep_until", [{ args: [(timestamptz$1)], ret: (_void), isOperator: false }], [this, ...args]);
    }
    time(...args) {
        return sqlFunction("time", [{ args: [(timestamptz$1)], ret: (time$1), isOperator: false }], [this, ...args]);
    }
    timestamp(...args) {
        return sqlFunction("timestamp", [{ args: [(timestamptz$1)], ret: (timestamp$1), isOperator: false }], [this, ...args]);
    }
    timestamptz(...args) {
        return sqlFunction("timestamptz", [{ args: [(timestamptz$1), (default_1$4)], ret: (timestamptz$1), isOperator: false }], [this, ...args]);
    }
    timestamptzCmp(...args) {
        return sqlFunction("timestamptz_cmp", [{ args: [(timestamptz$1), (timestamptz$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    timestamptzCmpDate(...args) {
        return sqlFunction("timestamptz_cmp_date", [{ args: [(timestamptz$1), (date$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    timestamptzCmpTimestamp(...args) {
        return sqlFunction("timestamptz_cmp_timestamp", [{ args: [(timestamptz$1), (timestamp$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    timestamptzEq(...args) {
        return sqlFunction("timestamptz_eq", [{ args: [(timestamptz$1), (timestamptz$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timestamptzEqDate(...args) {
        return sqlFunction("timestamptz_eq_date", [{ args: [(timestamptz$1), (date$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timestamptzEqTimestamp(...args) {
        return sqlFunction("timestamptz_eq_timestamp", [{ args: [(timestamptz$1), (timestamp$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timestamptzGe(...args) {
        return sqlFunction("timestamptz_ge", [{ args: [(timestamptz$1), (timestamptz$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timestamptzGeDate(...args) {
        return sqlFunction("timestamptz_ge_date", [{ args: [(timestamptz$1), (date$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timestamptzGeTimestamp(...args) {
        return sqlFunction("timestamptz_ge_timestamp", [{ args: [(timestamptz$1), (timestamp$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timestamptzGt(...args) {
        return sqlFunction("timestamptz_gt", [{ args: [(timestamptz$1), (timestamptz$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timestamptzGtDate(...args) {
        return sqlFunction("timestamptz_gt_date", [{ args: [(timestamptz$1), (date$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timestamptzGtTimestamp(...args) {
        return sqlFunction("timestamptz_gt_timestamp", [{ args: [(timestamptz$1), (timestamp$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timestamptzLarger(...args) {
        return sqlFunction("timestamptz_larger", [{ args: [(timestamptz$1), (timestamptz$1)], ret: (timestamptz$1), isOperator: false }], [this, ...args]);
    }
    timestamptzLe(...args) {
        return sqlFunction("timestamptz_le", [{ args: [(timestamptz$1), (timestamptz$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timestamptzLeDate(...args) {
        return sqlFunction("timestamptz_le_date", [{ args: [(timestamptz$1), (date$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timestamptzLeTimestamp(...args) {
        return sqlFunction("timestamptz_le_timestamp", [{ args: [(timestamptz$1), (timestamp$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timestamptzLt(...args) {
        return sqlFunction("timestamptz_lt", [{ args: [(timestamptz$1), (timestamptz$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timestamptzLtDate(...args) {
        return sqlFunction("timestamptz_lt_date", [{ args: [(timestamptz$1), (date$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timestamptzLtTimestamp(...args) {
        return sqlFunction("timestamptz_lt_timestamp", [{ args: [(timestamptz$1), (timestamp$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timestamptzMi(...args) {
        return sqlFunction("timestamptz_mi", [{ args: [(timestamptz$1), (timestamptz$1)], ret: (interval$1), isOperator: false }], [this, ...args]);
    }
    timestamptzMiInterval(...args) {
        return sqlFunction("timestamptz_mi_interval", [{ args: [(timestamptz$1), (interval$1)], ret: (timestamptz$1), isOperator: false }], [this, ...args]);
    }
    timestamptzNe(...args) {
        return sqlFunction("timestamptz_ne", [{ args: [(timestamptz$1), (timestamptz$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timestamptzNeDate(...args) {
        return sqlFunction("timestamptz_ne_date", [{ args: [(timestamptz$1), (date$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timestamptzNeTimestamp(...args) {
        return sqlFunction("timestamptz_ne_timestamp", [{ args: [(timestamptz$1), (timestamp$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timestamptzPlInterval(...args) {
        return sqlFunction("timestamptz_pl_interval", [{ args: [(timestamptz$1), (interval$1)], ret: (timestamptz$1), isOperator: false }], [this, ...args]);
    }
    timestamptzSmaller(...args) {
        return sqlFunction("timestamptz_smaller", [{ args: [(timestamptz$1), (timestamptz$1)], ret: (timestamptz$1), isOperator: false }], [this, ...args]);
    }
    timetz(...args) {
        return sqlFunction("timetz", [{ args: [(timestamptz$1)], ret: (timetz$1), isOperator: false }], [this, ...args]);
    }
    timezone(...args) {
        return sqlFunction("timezone", [{ args: [(timestamptz$1)], ret: (timestamp$1), isOperator: false }], [this, ...args]);
    }
    toChar(...args) {
        return sqlFunction("to_char", [{ args: [(timestamptz$1), (default_1$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    tstzrange(...args) {
        return sqlFunction("tstzrange", [{ args: [(timestamptz$1), (timestamptz$1)], ret: (tstzrange$1), isOperator: false }, { args: [(timestamptz$1), (timestamptz$1), (default_1$1)], ret: (tstzrange$1), isOperator: false }], [this, ...args]);
    }
    tstzrangeSubdiff(...args) {
        return sqlFunction("tstzrange_subdiff", [{ args: [(timestamptz$1), (timestamptz$1)], ret: (default_1$6), isOperator: false }], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [{ args: [(timestamptz$1), (timestamptz$1)], ret: (default_1$8), isOperator: true }, { args: [(timestamptz$1), (date$1)], ret: (default_1$8), isOperator: true }, { args: [(timestamptz$1), (timestamp$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">="](...args) {
        return sqlFunction(">=", [{ args: [(timestamptz$1), (timestamptz$1)], ret: (default_1$8), isOperator: true }, { args: [(timestamptz$1), (date$1)], ret: (default_1$8), isOperator: true }, { args: [(timestamptz$1), (timestamp$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">"](...args) {
        return sqlFunction(">", [{ args: [(timestamptz$1), (timestamptz$1)], ret: (default_1$8), isOperator: true }, { args: [(timestamptz$1), (date$1)], ret: (default_1$8), isOperator: true }, { args: [(timestamptz$1), (timestamp$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<="](...args) {
        return sqlFunction("<=", [{ args: [(timestamptz$1), (timestamptz$1)], ret: (default_1$8), isOperator: true }, { args: [(timestamptz$1), (date$1)], ret: (default_1$8), isOperator: true }, { args: [(timestamptz$1), (timestamp$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<"](...args) {
        return sqlFunction("<", [{ args: [(timestamptz$1), (timestamptz$1)], ret: (default_1$8), isOperator: true }, { args: [(timestamptz$1), (date$1)], ret: (default_1$8), isOperator: true }, { args: [(timestamptz$1), (timestamp$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["-"](...args) {
        return sqlFunction("-", [{ args: [(timestamptz$1), (timestamptz$1)], ret: (interval$1), isOperator: true }, { args: [(timestamptz$1), (interval$1)], ret: (timestamptz$1), isOperator: true }], [this, ...args]);
    }
    ["<>"](...args) {
        return sqlFunction("<>", [{ args: [(timestamptz$1), (timestamptz$1)], ret: (default_1$8), isOperator: true }, { args: [(timestamptz$1), (date$1)], ret: (default_1$8), isOperator: true }, { args: [(timestamptz$1), (timestamp$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["+"](...args) {
        return sqlFunction("+", [{ args: [(timestamptz$1), (interval$1)], ret: (timestamptz$1), isOperator: true }], [this, ...args]);
    }
}

class timetz$1 extends Any {
    static new(v) { return new timetz$1(v); }
    static parse(v) { return v; }
    static typeString() { return "timetz"; }
    asAggregate() {
        return undefined;
    }
    inRange(...args) {
        return sqlFunction("in_range", [{ args: [(timetz$1), (timetz$1), (interval$1), (default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    max(...args) {
        return sqlFunction("max", [{ args: [(timetz$1)], ret: (timetz$1), isOperator: false }], [this, ...args]);
    }
    overlaps(...args) {
        return sqlFunction("overlaps", [{ args: [(timetz$1), (timetz$1), (timetz$1), (timetz$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    time(...args) {
        return sqlFunction("time", [{ args: [(timetz$1)], ret: (time$1), isOperator: false }], [this, ...args]);
    }
    timetz(...args) {
        return sqlFunction("timetz", [{ args: [(timetz$1), (default_1$4)], ret: (timetz$1), isOperator: false }], [this, ...args]);
    }
    timetzCmp(...args) {
        return sqlFunction("timetz_cmp", [{ args: [(timetz$1), (timetz$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    timetzEq(...args) {
        return sqlFunction("timetz_eq", [{ args: [(timetz$1), (timetz$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timetzGe(...args) {
        return sqlFunction("timetz_ge", [{ args: [(timetz$1), (timetz$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timetzGt(...args) {
        return sqlFunction("timetz_gt", [{ args: [(timetz$1), (timetz$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timetzHash(...args) {
        return sqlFunction("timetz_hash", [{ args: [(timetz$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    timetzHashExtended(...args) {
        return sqlFunction("timetz_hash_extended", [{ args: [(timetz$1), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    timetzLarger(...args) {
        return sqlFunction("timetz_larger", [{ args: [(timetz$1), (timetz$1)], ret: (timetz$1), isOperator: false }], [this, ...args]);
    }
    timetzLe(...args) {
        return sqlFunction("timetz_le", [{ args: [(timetz$1), (timetz$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timetzLt(...args) {
        return sqlFunction("timetz_lt", [{ args: [(timetz$1), (timetz$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timetzMiInterval(...args) {
        return sqlFunction("timetz_mi_interval", [{ args: [(timetz$1), (interval$1)], ret: (timetz$1), isOperator: false }], [this, ...args]);
    }
    timetzNe(...args) {
        return sqlFunction("timetz_ne", [{ args: [(timetz$1), (timetz$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    timetzPlInterval(...args) {
        return sqlFunction("timetz_pl_interval", [{ args: [(timetz$1), (interval$1)], ret: (timetz$1), isOperator: false }], [this, ...args]);
    }
    timetzSmaller(...args) {
        return sqlFunction("timetz_smaller", [{ args: [(timetz$1), (timetz$1)], ret: (timetz$1), isOperator: false }], [this, ...args]);
    }
    timetzdatePl(...args) {
        return sqlFunction("timetzdate_pl", [{ args: [(timetz$1), (date$1)], ret: (timestamptz$1), isOperator: false }], [this, ...args]);
    }
    timezone(...args) {
        return sqlFunction("timezone", [{ args: [(timetz$1)], ret: (timetz$1), isOperator: false }], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [{ args: [(timetz$1), (timetz$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">="](...args) {
        return sqlFunction(">=", [{ args: [(timetz$1), (timetz$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">"](...args) {
        return sqlFunction(">", [{ args: [(timetz$1), (timetz$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<="](...args) {
        return sqlFunction("<=", [{ args: [(timetz$1), (timetz$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<"](...args) {
        return sqlFunction("<", [{ args: [(timetz$1), (timetz$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["-"](...args) {
        return sqlFunction("-", [{ args: [(timetz$1), (interval$1)], ret: (timetz$1), isOperator: true }], [this, ...args]);
    }
    ["<>"](...args) {
        return sqlFunction("<>", [{ args: [(timetz$1), (timetz$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["+"](...args) {
        return sqlFunction("+", [{ args: [(timetz$1), (interval$1)], ret: (timetz$1), isOperator: true }, { args: [(timetz$1), (date$1)], ret: (timestamptz$1), isOperator: true }], [this, ...args]);
    }
}

class trigger extends Any {
    static new(v) { return new trigger(v); }
    static parse(v) { return v; }
    static typeString() { return "trigger"; }
    asAggregate() {
        return undefined;
    }
}

class tsmultirange$1 extends Any {
    static new(v) { return new tsmultirange$1(v); }
    static parse(v) { return v; }
    static typeString() { return "tsmultirange"; }
    asAggregate() {
        return undefined;
    }
}

class tsquery extends Any {
    static new(v) { return new tsquery(v); }
    static parse(v) { return v; }
    static typeString() { return "tsquery"; }
    asAggregate() {
        return undefined;
    }
    numnode(...args) {
        return sqlFunction("numnode", [{ args: [(tsquery)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    querytree(...args) {
        return sqlFunction("querytree", [{ args: [(tsquery)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    tsMatchQv(...args) {
        return sqlFunction("ts_match_qv", [{ args: [(tsquery), (tsvector)], ret: (default_1$8), isOperator: false }, { args: [(tsquery), (tsvector)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    tsRewrite(...args) {
        return sqlFunction("ts_rewrite", [{ args: [(tsquery), (default_1$1)], ret: (tsquery), isOperator: false }, { args: [(tsquery), (tsquery), (tsquery)], ret: (tsquery), isOperator: false }], [this, ...args]);
    }
    tsqMcontained(...args) {
        return sqlFunction("tsq_mcontained", [{ args: [(tsquery), (tsquery)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    tsqMcontains(...args) {
        return sqlFunction("tsq_mcontains", [{ args: [(tsquery), (tsquery)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    tsqueryAnd(...args) {
        return sqlFunction("tsquery_and", [{ args: [(tsquery), (tsquery)], ret: (tsquery), isOperator: false }], [this, ...args]);
    }
    tsqueryCmp(...args) {
        return sqlFunction("tsquery_cmp", [{ args: [(tsquery), (tsquery)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    tsqueryEq(...args) {
        return sqlFunction("tsquery_eq", [{ args: [(tsquery), (tsquery)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    tsqueryGe(...args) {
        return sqlFunction("tsquery_ge", [{ args: [(tsquery), (tsquery)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    tsqueryGt(...args) {
        return sqlFunction("tsquery_gt", [{ args: [(tsquery), (tsquery)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    tsqueryLe(...args) {
        return sqlFunction("tsquery_le", [{ args: [(tsquery), (tsquery)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    tsqueryLt(...args) {
        return sqlFunction("tsquery_lt", [{ args: [(tsquery), (tsquery)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    tsqueryNe(...args) {
        return sqlFunction("tsquery_ne", [{ args: [(tsquery), (tsquery)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    tsqueryNot(...args) {
        return sqlFunction("tsquery_not", [{ args: [(tsquery)], ret: (tsquery), isOperator: false }], [this, ...args]);
    }
    tsqueryOr(...args) {
        return sqlFunction("tsquery_or", [{ args: [(tsquery), (tsquery)], ret: (tsquery), isOperator: false }], [this, ...args]);
    }
    tsqueryPhrase(...args) {
        return sqlFunction("tsquery_phrase", [{ args: [(tsquery), (tsquery)], ret: (tsquery), isOperator: false }, { args: [(tsquery), (tsquery), (default_1$4)], ret: (tsquery), isOperator: false }], [this, ...args]);
    }
    ["@@"](...args) {
        return sqlFunction("@@", [{ args: [(tsquery), (tsvector)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["@@@"](...args) {
        return sqlFunction("@@@", [{ args: [(tsquery), (tsvector)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["@>"](...args) {
        return sqlFunction("@>", [{ args: [(tsquery), (tsquery)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["&&"](...args) {
        return sqlFunction("&&", [{ args: [(tsquery), (tsquery)], ret: (tsquery), isOperator: true }], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [{ args: [(tsquery), (tsquery)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">="](...args) {
        return sqlFunction(">=", [{ args: [(tsquery), (tsquery)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">"](...args) {
        return sqlFunction(">", [{ args: [(tsquery), (tsquery)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<="](...args) {
        return sqlFunction("<=", [{ args: [(tsquery), (tsquery)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<"](...args) {
        return sqlFunction("<", [{ args: [(tsquery), (tsquery)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<>"](...args) {
        return sqlFunction("<>", [{ args: [(tsquery), (tsquery)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<->"](...args) {
        return sqlFunction("<->", [{ args: [(tsquery), (tsquery)], ret: (tsquery), isOperator: true }], [this, ...args]);
    }
}

class tsrange$1 extends Any {
    static new(v) { return new tsrange$1(v); }
    static parse(v) { return v; }
    static typeString() { return "tsrange"; }
    asAggregate() {
        return undefined;
    }
    tsmultirange(...args) {
        return sqlFunction("tsmultirange", [{ args: [(tsrange$1)], ret: (tsmultirange$1), isOperator: false }], [this, ...args]);
    }
}

class tstzmultirange$1 extends Any {
    static new(v) { return new tstzmultirange$1(v); }
    static parse(v) { return v; }
    static typeString() { return "tstzmultirange"; }
    asAggregate() {
        return undefined;
    }
}

class tstzrange$1 extends Any {
    static new(v) { return new tstzrange$1(v); }
    static parse(v) { return v; }
    static typeString() { return "tstzrange"; }
    asAggregate() {
        return undefined;
    }
    tstzmultirange(...args) {
        return sqlFunction("tstzmultirange", [{ args: [(tstzrange$1)], ret: (tstzmultirange$1), isOperator: false }], [this, ...args]);
    }
}

class tsvector extends Any {
    static new(v) { return new tsvector(v); }
    static parse(v) { return v; }
    static typeString() { return "tsvector"; }
    asAggregate() {
        return undefined;
    }
    length(...args) {
        return sqlFunction("length", [{ args: [(tsvector)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    setweight(...args) {
        return sqlFunction("setweight", [{ args: [(tsvector), (char$1)], ret: (tsvector), isOperator: false }, { args: [(tsvector), (char$1), Array$1.of((default_1$1))], ret: (tsvector), isOperator: false }], [this, ...args]);
    }
    strip(...args) {
        return sqlFunction("strip", [{ args: [(tsvector)], ret: (tsvector), isOperator: false }], [this, ...args]);
    }
    tsDelete(...args) {
        return sqlFunction("ts_delete", [{ args: [(tsvector), Array$1.of((default_1$1))], ret: (tsvector), isOperator: false }, { args: [(tsvector), (default_1$1)], ret: (tsvector), isOperator: false }], [this, ...args]);
    }
    tsFilter(...args) {
        return sqlFunction("ts_filter", [{ args: [(tsvector), Array$1.of((char$1))], ret: (tsvector), isOperator: false }], [this, ...args]);
    }
    tsMatchVq(...args) {
        return sqlFunction("ts_match_vq", [{ args: [(tsvector), (tsquery)], ret: (default_1$8), isOperator: false }, { args: [(tsvector), (tsquery)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    tsRank(...args) {
        return sqlFunction("ts_rank", [{ args: [(tsvector), (tsquery)], ret: (default_1$7), isOperator: false }, { args: [(tsvector), (tsquery), (default_1$4)], ret: (default_1$7), isOperator: false }], [this, ...args]);
    }
    tsRankCd(...args) {
        return sqlFunction("ts_rank_cd", [{ args: [(tsvector), (tsquery)], ret: (default_1$7), isOperator: false }, { args: [(tsvector), (tsquery), (default_1$4)], ret: (default_1$7), isOperator: false }], [this, ...args]);
    }
    tsvectorCmp(...args) {
        return sqlFunction("tsvector_cmp", [{ args: [(tsvector), (tsvector)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    tsvectorConcat(...args) {
        return sqlFunction("tsvector_concat", [{ args: [(tsvector), (tsvector)], ret: (tsvector), isOperator: false }], [this, ...args]);
    }
    tsvectorEq(...args) {
        return sqlFunction("tsvector_eq", [{ args: [(tsvector), (tsvector)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    tsvectorGe(...args) {
        return sqlFunction("tsvector_ge", [{ args: [(tsvector), (tsvector)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    tsvectorGt(...args) {
        return sqlFunction("tsvector_gt", [{ args: [(tsvector), (tsvector)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    tsvectorLe(...args) {
        return sqlFunction("tsvector_le", [{ args: [(tsvector), (tsvector)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    tsvectorLt(...args) {
        return sqlFunction("tsvector_lt", [{ args: [(tsvector), (tsvector)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    tsvectorNe(...args) {
        return sqlFunction("tsvector_ne", [{ args: [(tsvector), (tsvector)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    tsvectorToArray(...args) {
        return sqlFunction("tsvector_to_array", [{ args: [(tsvector)], ret: Array$1.of((default_1$1)), isOperator: false }], [this, ...args]);
    }
    unnest(...args) {
        return sqlFunction("unnest", [{ args: [(tsvector)], ret: Setof.ofSchema({ lexeme: (default_1$1), positions: Array$1.of((default_1$5)), weights: Array$1.of((default_1$1)) }), isOperator: false }], [this, ...args]);
    }
    ["@@@"](...args) {
        return sqlFunction("@@@", [{ args: [(tsvector), (tsquery)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["@@"](...args) {
        return sqlFunction("@@", [{ args: [(tsvector), (tsquery)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [{ args: [(tsvector), (tsvector)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">="](...args) {
        return sqlFunction(">=", [{ args: [(tsvector), (tsvector)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">"](...args) {
        return sqlFunction(">", [{ args: [(tsvector), (tsvector)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<="](...args) {
        return sqlFunction("<=", [{ args: [(tsvector), (tsvector)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<"](...args) {
        return sqlFunction("<", [{ args: [(tsvector), (tsvector)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<>"](...args) {
        return sqlFunction("<>", [{ args: [(tsvector), (tsvector)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
}

class txid_snapshot extends Any {
    static new(v) { return new txid_snapshot(v); }
    static parse(v) { return v; }
    static typeString() { return "txid_snapshot"; }
    asAggregate() {
        return undefined;
    }
    txidSnapshotXip(...args) {
        return sqlFunction("txid_snapshot_xip", [{ args: [(txid_snapshot)], ret: Setof.ofSchema({}), isOperator: false }], [this, ...args]);
    }
    txidSnapshotXmax(...args) {
        return sqlFunction("txid_snapshot_xmax", [{ args: [(txid_snapshot)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
}

class uuid extends Any {
    static new(v) { return new uuid(v); }
    static parse(v) { return v; }
    static typeString() { return "uuid"; }
    asAggregate() {
        return undefined;
    }
    uuidCmp(...args) {
        return sqlFunction("uuid_cmp", [{ args: [(uuid), (uuid)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    uuidEq(...args) {
        return sqlFunction("uuid_eq", [{ args: [(uuid), (uuid)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    uuidExtractTimestamp(...args) {
        return sqlFunction("uuid_extract_timestamp", [{ args: [(uuid)], ret: (timestamptz$1), isOperator: false }], [this, ...args]);
    }
    uuidExtractVersion(...args) {
        return sqlFunction("uuid_extract_version", [{ args: [(uuid)], ret: (default_1$5), isOperator: false }], [this, ...args]);
    }
    uuidGe(...args) {
        return sqlFunction("uuid_ge", [{ args: [(uuid), (uuid)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    uuidGt(...args) {
        return sqlFunction("uuid_gt", [{ args: [(uuid), (uuid)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    uuidHash(...args) {
        return sqlFunction("uuid_hash", [{ args: [(uuid)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    uuidHashExtended(...args) {
        return sqlFunction("uuid_hash_extended", [{ args: [(uuid), (default_1$3)], ret: (default_1$3), isOperator: false }], [this, ...args]);
    }
    uuidLe(...args) {
        return sqlFunction("uuid_le", [{ args: [(uuid), (uuid)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    uuidLt(...args) {
        return sqlFunction("uuid_lt", [{ args: [(uuid), (uuid)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    uuidNe(...args) {
        return sqlFunction("uuid_ne", [{ args: [(uuid), (uuid)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [{ args: [(uuid), (uuid)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">="](...args) {
        return sqlFunction(">=", [{ args: [(uuid), (uuid)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">"](...args) {
        return sqlFunction(">", [{ args: [(uuid), (uuid)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<="](...args) {
        return sqlFunction("<=", [{ args: [(uuid), (uuid)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<"](...args) {
        return sqlFunction("<", [{ args: [(uuid), (uuid)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<>"](...args) {
        return sqlFunction("<>", [{ args: [(uuid), (uuid)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
}

class varbit$1 extends Any {
    static new(v) { return new varbit$1(v); }
    static parse(v) { return v; }
    static typeString() { return "varbit"; }
    asAggregate() {
        return undefined;
    }
    bitcat(...args) {
        return sqlFunction("bitcat", [{ args: [(varbit$1), (varbit$1)], ret: (varbit$1), isOperator: false }], [this, ...args]);
    }
    varbit(...args) {
        return sqlFunction("varbit", [{ args: [(varbit$1), (default_1$4), (default_1$8)], ret: (varbit$1), isOperator: false }], [this, ...args]);
    }
    varbitcmp(...args) {
        return sqlFunction("varbitcmp", [{ args: [(varbit$1), (varbit$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    varbiteq(...args) {
        return sqlFunction("varbiteq", [{ args: [(varbit$1), (varbit$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    varbitge(...args) {
        return sqlFunction("varbitge", [{ args: [(varbit$1), (varbit$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    varbitgt(...args) {
        return sqlFunction("varbitgt", [{ args: [(varbit$1), (varbit$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    varbitle(...args) {
        return sqlFunction("varbitle", [{ args: [(varbit$1), (varbit$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    varbitlt(...args) {
        return sqlFunction("varbitlt", [{ args: [(varbit$1), (varbit$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    varbitne(...args) {
        return sqlFunction("varbitne", [{ args: [(varbit$1), (varbit$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [{ args: [(varbit$1), (varbit$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">="](...args) {
        return sqlFunction(">=", [{ args: [(varbit$1), (varbit$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">"](...args) {
        return sqlFunction(">", [{ args: [(varbit$1), (varbit$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<="](...args) {
        return sqlFunction("<=", [{ args: [(varbit$1), (varbit$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<"](...args) {
        return sqlFunction("<", [{ args: [(varbit$1), (varbit$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<>"](...args) {
        return sqlFunction("<>", [{ args: [(varbit$1), (varbit$1)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
}

class varchar$1 extends Any {
    static new(v) { return new varchar$1(v); }
    static parse(v) { return v; }
    static typeString() { return "varchar"; }
    asAggregate() {
        return undefined;
    }
    name(...args) {
        return sqlFunction("name", [{ args: [(varchar$1)], ret: (name$1), isOperator: false }], [this, ...args]);
    }
    varchar(...args) {
        return sqlFunction("varchar", [{ args: [(varchar$1), (default_1$4), (default_1$8)], ret: (varchar$1), isOperator: false }], [this, ...args]);
    }
}

class _void extends Any {
    static new(v) { return new _void(v); }
    static parse(v) { return v; }
    static typeString() { return "void"; }
    asAggregate() {
        return undefined;
    }
}

class xid$1 extends Any {
    static new(v) { return new xid$1(v); }
    static parse(v) { return v; }
    static typeString() { return "xid"; }
    asAggregate() {
        return undefined;
    }
    age(...args) {
        return sqlFunction("age", [{ args: [(xid$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    mxidAge(...args) {
        return sqlFunction("mxid_age", [{ args: [(xid$1)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    pgGetMultixactMembers(...args) {
        return sqlFunction("pg_get_multixact_members", [{ args: [(xid$1)], ret: Setof.ofSchema({ xid: (xid$1), mode: (default_1$1) }), isOperator: false }], [this, ...args]);
    }
    pgXactCommitTimestamp(...args) {
        return sqlFunction("pg_xact_commit_timestamp", [{ args: [(xid$1)], ret: (timestamptz$1), isOperator: false }], [this, ...args]);
    }
    xideq(...args) {
        return sqlFunction("xideq", [{ args: [(xid$1), (xid$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    xideqint4(...args) {
        return sqlFunction("xideqint4", [{ args: [(xid$1), (default_1$4)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    xidneq(...args) {
        return sqlFunction("xidneq", [{ args: [(xid$1), (xid$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    xidneqint4(...args) {
        return sqlFunction("xidneqint4", [{ args: [(xid$1), (default_1$4)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [{ args: [(xid$1), (xid$1)], ret: (default_1$8), isOperator: true }, { args: [(xid$1), (default_1$4)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<>"](...args) {
        return sqlFunction("<>", [{ args: [(xid$1), (xid$1)], ret: (default_1$8), isOperator: true }, { args: [(xid$1), (default_1$4)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
}

class xid8 extends Any {
    static new(v) { return new xid8(v); }
    static parse(v) { return v; }
    static typeString() { return "xid8"; }
    asAggregate() {
        return undefined;
    }
    max(...args) {
        return sqlFunction("max", [{ args: [(xid8)], ret: (xid8), isOperator: false }], [this, ...args]);
    }
    pgVisibleInSnapshot(...args) {
        return sqlFunction("pg_visible_in_snapshot", [{ args: [(xid8), (pg_snapshot)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    pgXactStatus(...args) {
        return sqlFunction("pg_xact_status", [{ args: [(xid8)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    xid(...args) {
        return sqlFunction("xid", [{ args: [(xid8)], ret: (xid$1), isOperator: false }], [this, ...args]);
    }
    xid8Larger(...args) {
        return sqlFunction("xid8_larger", [{ args: [(xid8), (xid8)], ret: (xid8), isOperator: false }], [this, ...args]);
    }
    xid8Smaller(...args) {
        return sqlFunction("xid8_smaller", [{ args: [(xid8), (xid8)], ret: (xid8), isOperator: false }], [this, ...args]);
    }
    xid8Cmp(...args) {
        return sqlFunction("xid8cmp", [{ args: [(xid8), (xid8)], ret: (default_1$4), isOperator: false }], [this, ...args]);
    }
    xid8Eq(...args) {
        return sqlFunction("xid8eq", [{ args: [(xid8), (xid8)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    xid8Ge(...args) {
        return sqlFunction("xid8ge", [{ args: [(xid8), (xid8)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    xid8Gt(...args) {
        return sqlFunction("xid8gt", [{ args: [(xid8), (xid8)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    xid8Le(...args) {
        return sqlFunction("xid8le", [{ args: [(xid8), (xid8)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    xid8Lt(...args) {
        return sqlFunction("xid8lt", [{ args: [(xid8), (xid8)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    xid8Ne(...args) {
        return sqlFunction("xid8ne", [{ args: [(xid8), (xid8)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [{ args: [(xid8), (xid8)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">="](...args) {
        return sqlFunction(">=", [{ args: [(xid8), (xid8)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    [">"](...args) {
        return sqlFunction(">", [{ args: [(xid8), (xid8)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<="](...args) {
        return sqlFunction("<=", [{ args: [(xid8), (xid8)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<"](...args) {
        return sqlFunction("<", [{ args: [(xid8), (xid8)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
    ["<>"](...args) {
        return sqlFunction("<>", [{ args: [(xid8), (xid8)], ret: (default_1$8), isOperator: true }], [this, ...args]);
    }
}

class xml$1 extends Any {
    static new(v) { return new xml$1(v); }
    static parse(v) { return v; }
    static typeString() { return "xml"; }
    asAggregate() {
        return undefined;
    }
    text(...args) {
        return sqlFunction("text", [{ args: [(xml$1)], ret: (default_1$1), isOperator: false }], [this, ...args]);
    }
    xmlagg(...args) {
        return sqlFunction("xmlagg", [{ args: [(xml$1)], ret: (xml$1), isOperator: false }], [this, ...args]);
    }
    xmlconcat2(...args) {
        return sqlFunction("xmlconcat2", [{ args: [(xml$1), (xml$1)], ret: (xml$1), isOperator: false }], [this, ...args]);
    }
    xmlvalidate(...args) {
        return sqlFunction("xmlvalidate", [{ args: [(xml$1), (default_1$1)], ret: (default_1$8), isOperator: false }], [this, ...args]);
    }
}

class PgArray extends Any {
    static parse(v) { return v; }
    static typeString() { return "array"; }
    asAggregate() {
        return undefined;
    }
    arrayAgg(...args) {
        return sqlFunction("array_agg", [({ T }) => ({ args: [Array$1.of(T)], ret: Array$1.of(T), isOperator: false })], [this, ...args]);
    }
    arrayAppend(...args) {
        return sqlFunction("array_append", [({ T }) => ({ args: [Array$1.of(T), T], ret: Array$1.of(T), isOperator: false })], [this, ...args]);
    }
    arrayCat(...args) {
        return sqlFunction("array_cat", [({ T }) => ({ args: [Array$1.of(T), Array$1.of(T)], ret: Array$1.of(T), isOperator: false })], [this, ...args]);
    }
    arrayDims(...args) {
        return sqlFunction("array_dims", [({ T }) => ({ args: [Array$1.of(T)], ret: (default_1$1), isOperator: false })], [this, ...args]);
    }
    arrayEq(...args) {
        return sqlFunction("array_eq", [({ T }) => ({ args: [Array$1.of(T), Array$1.of(T)], ret: (default_1$8), isOperator: false })], [this, ...args]);
    }
    arrayGe(...args) {
        return sqlFunction("array_ge", [({ T }) => ({ args: [Array$1.of(T), Array$1.of(T)], ret: (default_1$8), isOperator: false })], [this, ...args]);
    }
    arrayGt(...args) {
        return sqlFunction("array_gt", [({ T }) => ({ args: [Array$1.of(T), Array$1.of(T)], ret: (default_1$8), isOperator: false })], [this, ...args]);
    }
    arrayLarger(...args) {
        return sqlFunction("array_larger", [({ T }) => ({ args: [Array$1.of(T), Array$1.of(T)], ret: Array$1.of(T), isOperator: false })], [this, ...args]);
    }
    arrayLe(...args) {
        return sqlFunction("array_le", [({ T }) => ({ args: [Array$1.of(T), Array$1.of(T)], ret: (default_1$8), isOperator: false })], [this, ...args]);
    }
    arrayLength(...args) {
        return sqlFunction("array_length", [({ T }) => ({ args: [Array$1.of(T), (default_1$4)], ret: (default_1$4), isOperator: false })], [this, ...args]);
    }
    arrayLower(...args) {
        return sqlFunction("array_lower", [({ T }) => ({ args: [Array$1.of(T), (default_1$4)], ret: (default_1$4), isOperator: false })], [this, ...args]);
    }
    arrayLt(...args) {
        return sqlFunction("array_lt", [({ T }) => ({ args: [Array$1.of(T), Array$1.of(T)], ret: (default_1$8), isOperator: false })], [this, ...args]);
    }
    arrayNdims(...args) {
        return sqlFunction("array_ndims", [({ T }) => ({ args: [Array$1.of(T)], ret: (default_1$4), isOperator: false })], [this, ...args]);
    }
    arrayNe(...args) {
        return sqlFunction("array_ne", [({ T }) => ({ args: [Array$1.of(T), Array$1.of(T)], ret: (default_1$8), isOperator: false })], [this, ...args]);
    }
    arrayPosition(...args) {
        return sqlFunction("array_position", [({ T }) => ({ args: [Array$1.of(T), T], ret: (default_1$4), isOperator: false }), ({ T }) => ({ args: [Array$1.of(T), T, (default_1$4)], ret: (default_1$4), isOperator: false })], [this, ...args]);
    }
    arrayPositions(...args) {
        return sqlFunction("array_positions", [({ T }) => ({ args: [Array$1.of(T), T], ret: Array$1.of((default_1$4)), isOperator: false })], [this, ...args]);
    }
    arrayRemove(...args) {
        return sqlFunction("array_remove", [({ T }) => ({ args: [Array$1.of(T), T], ret: Array$1.of(T), isOperator: false })], [this, ...args]);
    }
    arrayReplace(...args) {
        return sqlFunction("array_replace", [({ T }) => ({ args: [Array$1.of(T), T, T], ret: Array$1.of(T), isOperator: false })], [this, ...args]);
    }
    arraySample(...args) {
        return sqlFunction("array_sample", [({ T }) => ({ args: [Array$1.of(T), (default_1$4)], ret: Array$1.of(T), isOperator: false })], [this, ...args]);
    }
    arrayShuffle(...args) {
        return sqlFunction("array_shuffle", [({ T }) => ({ args: [Array$1.of(T)], ret: Array$1.of(T), isOperator: false })], [this, ...args]);
    }
    arraySmaller(...args) {
        return sqlFunction("array_smaller", [({ T }) => ({ args: [Array$1.of(T), Array$1.of(T)], ret: Array$1.of(T), isOperator: false })], [this, ...args]);
    }
    arrayToJson(...args) {
        return sqlFunction("array_to_json", [({ T }) => ({ args: [Array$1.of(T)], ret: (json), isOperator: false }), ({ T }) => ({ args: [Array$1.of(T), (default_1$8)], ret: (json), isOperator: false })], [this, ...args]);
    }
    arrayToString(...args) {
        return sqlFunction("array_to_string", [({ T }) => ({ args: [Array$1.of(T), (default_1$1)], ret: (default_1$1), isOperator: false }), ({ T }) => ({ args: [Array$1.of(T), (default_1$1), (default_1$1)], ret: (default_1$1), isOperator: false })], [this, ...args]);
    }
    arrayUpper(...args) {
        return sqlFunction("array_upper", [({ T }) => ({ args: [Array$1.of(T), (default_1$4)], ret: (default_1$4), isOperator: false })], [this, ...args]);
    }
    arraycontained(...args) {
        return sqlFunction("arraycontained", [({ T }) => ({ args: [Array$1.of(T), Array$1.of(T)], ret: (default_1$8), isOperator: false })], [this, ...args]);
    }
    arraycontains(...args) {
        return sqlFunction("arraycontains", [({ T }) => ({ args: [Array$1.of(T), Array$1.of(T)], ret: (default_1$8), isOperator: false })], [this, ...args]);
    }
    arrayoverlap(...args) {
        return sqlFunction("arrayoverlap", [({ T }) => ({ args: [Array$1.of(T), Array$1.of(T)], ret: (default_1$8), isOperator: false })], [this, ...args]);
    }
    btarraycmp(...args) {
        return sqlFunction("btarraycmp", [({ T }) => ({ args: [Array$1.of(T), Array$1.of(T)], ret: (default_1$4), isOperator: false })], [this, ...args]);
    }
    cardinality(...args) {
        return sqlFunction("cardinality", [({ T }) => ({ args: [Array$1.of(T)], ret: (default_1$4), isOperator: false })], [this, ...args]);
    }
    generateSubscripts(...args) {
        return sqlFunction("generate_subscripts", [({ T }) => ({ args: [Array$1.of(T), (default_1$4)], ret: Setof.ofSchema({}), isOperator: false }), ({ T }) => ({ args: [Array$1.of(T), (default_1$4), (default_1$8)], ret: Setof.ofSchema({}), isOperator: false })], [this, ...args]);
    }
    hashArray(...args) {
        return sqlFunction("hash_array", [({ T }) => ({ args: [Array$1.of(T)], ret: (default_1$4), isOperator: false })], [this, ...args]);
    }
    hashArrayExtended(...args) {
        return sqlFunction("hash_array_extended", [({ T }) => ({ args: [Array$1.of(T), (default_1$3)], ret: (default_1$3), isOperator: false })], [this, ...args]);
    }
    max(...args) {
        return sqlFunction("max", [({ T }) => ({ args: [Array$1.of(T)], ret: Array$1.of(T), isOperator: false })], [this, ...args]);
    }
    trimArray(...args) {
        return sqlFunction("trim_array", [({ T }) => ({ args: [Array$1.of(T), (default_1$4)], ret: Array$1.of(T), isOperator: false })], [this, ...args]);
    }
    unnest(...args) {
        return sqlFunction("unnest", [({ T }) => ({ args: [Array$1.of(T)], ret: Setof.ofSchema({}), isOperator: false })], [this, ...args]);
    }
    ["="](...args) {
        return sqlFunction("=", [({ T }) => ({ args: [Array$1.of(T), Array$1.of(T)], ret: (default_1$8), isOperator: true })], [this, ...args]);
    }
    [">="](...args) {
        return sqlFunction(">=", [({ T }) => ({ args: [Array$1.of(T), Array$1.of(T)], ret: (default_1$8), isOperator: true })], [this, ...args]);
    }
    [">"](...args) {
        return sqlFunction(">", [({ T }) => ({ args: [Array$1.of(T), Array$1.of(T)], ret: (default_1$8), isOperator: true })], [this, ...args]);
    }
    ["<="](...args) {
        return sqlFunction("<=", [({ T }) => ({ args: [Array$1.of(T), Array$1.of(T)], ret: (default_1$8), isOperator: true })], [this, ...args]);
    }
    ["<"](...args) {
        return sqlFunction("<", [({ T }) => ({ args: [Array$1.of(T), Array$1.of(T)], ret: (default_1$8), isOperator: true })], [this, ...args]);
    }
    ["<>"](...args) {
        return sqlFunction("<>", [({ T }) => ({ args: [Array$1.of(T), Array$1.of(T)], ret: (default_1$8), isOperator: true })], [this, ...args]);
    }
    ["@>"](...args) {
        return sqlFunction("@>", [({ T }) => ({ args: [Array$1.of(T), Array$1.of(T)], ret: (default_1$8), isOperator: true })], [this, ...args]);
    }
    ["&&"](...args) {
        return sqlFunction("&&", [({ T }) => ({ args: [Array$1.of(T), Array$1.of(T)], ret: (default_1$8), isOperator: true })], [this, ...args]);
    }
}

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var postgresArray = {};

var hasRequiredPostgresArray;

function requirePostgresArray () {
	if (hasRequiredPostgresArray) return postgresArray;
	hasRequiredPostgresArray = 1;

	postgresArray.parse = function (source, transform) {
	  return new ArrayParser(source, transform).parse()
	};

	class ArrayParser {
	  constructor (source, transform) {
	    this.source = source;
	    this.transform = transform || identity;
	    this.position = 0;
	    this.entries = [];
	    this.recorded = [];
	    this.dimension = 0;
	  }

	  isEof () {
	    return this.position >= this.source.length
	  }

	  nextCharacter () {
	    var character = this.source[this.position++];
	    if (character === '\\') {
	      return {
	        value: this.source[this.position++],
	        escaped: true
	      }
	    }
	    return {
	      value: character,
	      escaped: false
	    }
	  }

	  record (character) {
	    this.recorded.push(character);
	  }

	  newEntry (includeEmpty) {
	    var entry;
	    if (this.recorded.length > 0 || includeEmpty) {
	      entry = this.recorded.join('');
	      if (entry === 'NULL' && !includeEmpty) {
	        entry = null;
	      }
	      if (entry !== null) entry = this.transform(entry);
	      this.entries.push(entry);
	      this.recorded = [];
	    }
	  }

	  consumeDimensions () {
	    if (this.source[0] === '[') {
	      while (!this.isEof()) {
	        var char = this.nextCharacter();
	        if (char.value === '=') break
	      }
	    }
	  }

	  parse (nested) {
	    var character, parser, quote;
	    this.consumeDimensions();
	    while (!this.isEof()) {
	      character = this.nextCharacter();
	      if (character.value === '{' && !quote) {
	        this.dimension++;
	        if (this.dimension > 1) {
	          parser = new ArrayParser(this.source.substr(this.position - 1), this.transform);
	          this.entries.push(parser.parse(true));
	          this.position += parser.position - 2;
	        }
	      } else if (character.value === '}' && !quote) {
	        this.dimension--;
	        if (!this.dimension) {
	          this.newEntry();
	          if (nested) return this.entries
	        }
	      } else if (character.value === '"' && !character.escaped) {
	        if (quote) this.newEntry(true);
	        quote = !quote;
	      } else if (character.value === ',' && !quote) {
	        this.newEntry();
	      } else {
	        this.record(character.value);
	      }
	    }
	    if (this.dimension !== 0) {
	      throw new Error('array dimension not balanced')
	    }
	    return this.entries
	  }
	}

	function identity (value) {
	  return value
	}
	return postgresArray;
}

var postgresArrayExports = requirePostgresArray();
var array = /*@__PURE__*/getDefaultExportFromCjs(postgresArrayExports);

let Array$1 = class Array extends PgArray {
    static of(subtype) {
        return class ArrayImpl extends Array {
            static resultType;
            static typeString() {
                return `${subtype.typeString()}[]`;
            }
            static subtype() {
                return {
                    subtype: subtype,
                    withSubtype: Array.of,
                };
            }
            static parse(v) {
                return array.parse(v, subtype.parse);
            }
            constructor(v) {
                super(v);
            }
            static new(v) {
                return new ArrayImpl(v);
            }
        };
    }
};

const maybePrimitiveToSqlType = (value) => {
    if (typeof value === "string") {
        return default_1$1.new(value);
    }
    else if (typeof value === "number") {
        return default_1$6.new(value);
    }
    else if (typeof value === "boolean") {
        return default_1$8.new(value);
    }
    else if (typeof value === "bigint") {
        return default_1$2.new(value);
    }
    if (value instanceof Any) {
        return value;
    }
    if (typeof value === "object" && value !== null) {
        return Object.fromEntries(Object.entries(value).map(([key, val]) => [
            key,
            maybePrimitiveToSqlType(val),
        ]));
    }
    throw new Error(`Unsupported type for maybePrimitiveToSqlType: ${typeof value}`);
};

class LiteralRecordExpression extends Expression {
    value;
    schema;
    constructor(value, schema) {
        if (value === null) {
            throw new Error("Cannot create a null literal record");
        }
        super();
        this.value = value;
        this.schema = schema;
    }
    compile() {
        if (this.value === null) {
            throw new Error("Cannot create a null literal record");
        }
        // 1. Pretend the value is an array and parse the parts
        const parts = array.parse(`{${this.value.slice(1, -1)}}`, (v) => v);
        // 2. Then each part corresponds to a k/v in the schema:
        return sql `ROW(${sql.join(Object.values(this.schema).map((type, i) => {
            const instantiated = type.new("");
            return instantiated instanceof Record
                ? new LiteralRecordExpression(parts[i], instantiated.schema).compile()
                : new LiteralExpression(parts[i], type.typeString()).compile();
        }), sql.raw(", "))})`;
    }
}
class RecordAccessExpression extends Expression {
    base;
    key;
    constructor(base, key) {
        super();
        this.base = base;
        this.key = key;
    }
    compile(ctx) {
        return sql `(${this.base.compile(ctx)}).${sql.ref(this.key)}`;
    }
}
class Record extends PgRecord {
    static of(schema) {
        return class RecordImpl extends Record {
            schema = schema;
            static resultType;
            static typeString() {
                return `(${Object.entries(schema)
                    .map(([key, value]) => `${key} ${value.typeString()}`)
                    .join(", ")})`;
            }
            static subtype() {
                return {
                    subtype: schema,
                    withSubtype: Record.of,
                };
            }
            static parse(v) {
                // 1. Pretend the value is an array and parse the parts
                const parts = array.parse(`{${v.slice(1, -1)}}`, (v) => v);
                // 2. Then each part corresponds to a k/v in the schema:
                return Object.fromEntries(Object.entries(schema).map(([key, value], i) => [
                    key,
                    value.parse(parts[i]),
                ]));
            }
            constructor(v) {
                super(v);
                for (const [key, value] of Object.entries(schema)) {
                    if (key in this) {
                        throw new Error(`Record constructor: ${key} already defined ${JSON.stringify(this)}, cannot redefine`);
                    }
                    this[key] = value.new(this.v instanceof TableReferenceExpression
                        ? // This is the case where we're using reference to a table, so we don't use
                            // parens around the expression to access the column:
                            new ColumnAliasExpression(this.v.table, key)
                        : new RecordAccessExpression(this.toExpression(), key));
                }
            }
            toExpression() {
                if (this.v instanceof Expression) {
                    return super.toExpression();
                }
                if (typeof this.v !== "string") {
                    throw new Error(`Record.toExpression: expected string, got ${typeof this.v}`);
                }
                return new LiteralRecordExpression(this.v, schema);
            }
            static new(v) {
                return new RecordImpl(v);
            }
        };
    }
}
const row = (row, expression) => {
    const rowLike = maybePrimitiveToSqlType(row);
    return Record.of(Object.fromEntries(Object.entries(rowLike).map(([key, value]) => [
        key,
        value.getClass(),
    ]))).new(expression);
};

const dummyDb = new Kysely({
    dialect: {
        createAdapter: () => new PostgresAdapter(),
        createDriver: () => new DummyDriver(),
        createIntrospector: (db) => new PostgresIntrospector(db),
        createQueryCompiler: () => new PostgresQueryCompiler(),
    },
});

const isScalar = (value) => {
    return value instanceof Any;
};
const isScalarRelaxed = (value) => {
    return (isScalar(value) ||
        typeof value === "string" ||
        typeof value === "number" ||
        typeof value === "boolean" ||
        typeof value === "bigint");
};
class SelectableExpression extends Expression {
    schema;
    constructor(schema) {
        super();
        this.schema = schema;
    }
    tableColumnAlias() {
        const keys = Object.keys(this.schema)
            .toSorted((k1, k2) => k1.localeCompare(k2))
            .map((key) => sql.ref(key));
        return sql.join(keys);
    }
}
class TableReferenceExpression extends SelectableExpression {
    table;
    constructor(table, schema) {
        super(schema);
        this.table = table;
    }
    compile(ctx) {
        return sql.ref(ctx.getAlias(this.table));
    }
}
class ValuesExpression extends SelectableExpression {
    values;
    constructor(values) {
        super(values[0]);
        this.values = values;
    }
    compile(ctx) {
        return sql `(VALUES ${sql.join(this.values.map((value) => sql `(${sql.join(Object.entries(value)
            .toSorted(([k1], [k2]) => k1.localeCompare(k2))
            .map(([, value]) => sql `${value.toExpression().compile(ctx)}`))})`))})`;
    }
}
class SubqueryExpression extends SelectableExpression {
    subquery;
    constructor(subquery) {
        super(resultType(subquery.query));
        this.subquery = subquery;
    }
    compile(ctx) {
        return this.subquery.compile(ctx);
    }
}
const aliasRowLike = (queryAlias, row) => {
    return Object.fromEntries(Object.entries(row).map(([key, value]) => [
        key,
        value.getClass().new(new ColumnAliasExpression(queryAlias, key)),
    ]));
};
const aliasScalar = (queryAlias, scalar) => {
    return scalar.getClass().new(new ColumnAliasExpression(queryAlias, "value"));
};
class ColumnAliasExpression extends Expression {
    alias;
    column;
    constructor(alias, column) {
        super();
        this.alias = alias;
        this.column = column;
    }
    compile(ctx) {
        return sql.ref(`${ctx.getAlias(this.alias)}.${this.column}`);
    }
}
const parseRowLike = (rowLike, result) => {
    return Object.fromEntries(Object.entries(rowLike).map(([key, value]) => {
        const res = result[key];
        return [key, res === null ? res : value.getClass().parse(res)];
    }));
};
const resultType = (query) => {
    return (query.select ?? query.from);
};
class Setof extends Expression {
    rawFromExpr;
    fromAlias;
    joinAliases;
    query;
    fromRow;
    constructor(rawFromExpr, fromAlias, joinAliases, query, fromRow) {
        super();
        this.rawFromExpr = rawFromExpr;
        this.fromAlias = fromAlias;
        this.joinAliases = joinAliases;
        this.query = query;
        this.fromRow = fromRow;
    }
    static of(fromRow) {
        return class extends Setof {
            static new(fromExpr) {
                const alias = new QueryAlias("values");
                return new Setof(fromExpr, alias, {}, {
                    from: aliasRowLike(alias, fromRow),
                }, fromRow);
            }
        };
    }
    static ofSchema(fromRow) {
        return this.of(Object.fromEntries(Object.entries(fromRow).map(([k, Cls]) => [k, Cls.new("")])));
    }
    toSelectArgs() {
        return Array.isArray(this.query.groupBy)
            ? [this.query.from, this.query.groupBy]
            : [
                isScalar(this.query.from)
                    ? this.query.from
                    : row(this.query.from, new TableReferenceExpression(this.fromAlias, this.query.from)),
                this.joinTables(),
            ];
    }
    select(fn) {
        return new Setof(this.rawFromExpr, this.fromAlias, this.joinAliases, {
            ...this.query,
            select: maybePrimitiveToSqlType(fn(...this.toSelectArgs())),
        }, this.fromRow);
    }
    where(fn) {
        return new Setof(this.rawFromExpr, this.fromAlias, this.joinAliases, {
            ...this.query,
            wheres: [
                ...(this.query.wheres ?? []),
                maybePrimitiveToSqlType(fn(...this.toSelectArgs())),
            ],
        }, this.fromRow);
    }
    groupBy(fn) {
        return new Setof(this.rawFromExpr, this.fromAlias, this.joinAliases, {
            ...this.query,
            groupBy: [...(this.query.groupBy ?? []), ...fn(this.query.from)],
        }, this.fromRow);
    }
    joinTables() {
        return Object.fromEntries(Object.entries({ ...this.query.joins }).map(([key, value]) => [
            key,
            value.row,
        ]));
    }
    join(j, as, on) {
        const alias = new QueryAlias(as);
        const row = aliasRowLike(alias, resultType(j.query));
        return new Setof(this.rawFromExpr, this.fromAlias, {
            ...this.joinAliases,
            [as]: alias,
        }, {
            ...this.query,
            joins: {
                ...this.query.joins,
                [as]: {
                    table: j,
                    on: maybePrimitiveToSqlType(on(this.query.from, {
                        ...this.joinTables(),
                        ...{ [as]: row },
                    })),
                    row,
                },
            },
        }, this.fromRow);
    }
    subquery() {
        const alias = new QueryAlias("subquery");
        const res = resultType(this.query);
        return new Setof(new SubqueryExpression(this), alias, this.joinAliases, {
            from: isScalar(res)
                ? aliasScalar(alias, res)
                : aliasRowLike(alias, res),
        }, res);
    }
    tableColumnAlias() {
        const keys = Object.keys(this.query.from)
            .toSorted((k1, k2) => k1.localeCompare(k2))
            .map((key) => sql.ref(key));
        return sql.join(keys);
    }
    compile(ctxIn) {
        const ctx = ctxIn.withAliases([
            this.fromAlias,
            ...Object.values(this.joinAliases),
        ]);
        const from = sql `FROM ${this.rawFromExpr.compile(ctxIn)} as ${sql.ref(ctx.getAlias(this.fromAlias))}${this.rawFromExpr instanceof ValuesExpression
            ? sql `(${this.tableColumnAlias()})`
            : sql ``}`;
        const joins = this.query.joins
            ? sql.join(Object.entries(this.query.joins ?? {}).map(([alias, join]) => {
                return sql `JOIN ${join.table.compile(ctx)} as ${sql.ref(ctx.getAlias(this.joinAliases[alias]))} ON ${join.on.toExpression().compile(ctx)}`;
            }), sql ` `)
            : sql ``;
        const selectEntries = this.query.select
            ? isScalar(this.query.select)
                ? { value: this.query.select }
                : this.query.select
            : {};
        const select = this.query.select
            ? sql `SELECT ${sql.join(Object.entries(selectEntries).map(([key, value]) => sql `${value.toExpression().compile(ctx)} AS ${sql.ref(key)}`))}`
            : sql `SELECT *`;
        const where = this.query.wheres
            ? sql `WHERE ${sql.join(this.query.wheres.map((w) => sql `(${w.toExpression().compile(ctx)})`), sql ` AND `)}`
            : sql ``;
        const groupBy = this.query.groupBy
            ? sql `GROUP BY ${sql.join(this.query.groupBy.map((g) => sql `${g.toExpression().compile(ctx)}`), sql `, `)}`
            : sql ``;
        return sql `(${select} ${from} ${where} ${joins} ${groupBy})`;
    }
    debug() {
        console.log("debug", this.compile(Context.new()).compile(dummyDb));
        return this;
    }
    async execute(db) {
        const kexpr = db.executeQuery(this.compile(Context.new()).compile(db));
        const resultRowLike = this.query.select
            ? this.query.select
            : this.query.from;
        try {
            const result = await kexpr;
            return result.rows.map((row) => isScalar(resultRowLike)
                ? resultRowLike
                    .getClass()
                    .parse(Object.values(row)[0])
                : parseRowLike(resultRowLike, row));
        }
        catch (err) {
            console.error("Error executing query:", this.compile(Context.new()).compile(db), err);
            throw err;
        }
    }
    scalar() {
        return this.query.select.getClass().new(this);
    }
}
const values = (...input) => {
    return Setof.of(input[0]).new(new ValuesExpression(input));
};

const Generated = Symbol("Generated");
// Like `TableReferenceExpression` but referencing a table directly (not an alias)
class RawTableReferenceExpression extends SelectableExpression {
    table;
    constructor(table, schema) {
        super(schema);
        this.table = table;
    }
    compile(_ctx) {
        return sql.ref(this.table);
    }
}
const table = (name, columns) => {
    const rowLike = Object.fromEntries(Object.entries(columns).map(([name, col]) => [name, col.new("")]));
    return Table.of(rowLike).new(new RawTableReferenceExpression(name, rowLike));
};
const database = (schema) => {
    return Object.fromEntries(Object.entries(schema).map(([name, columns]) => [
        name,
        table(name, columns),
    ]));
};
class Table extends Setof {
    rawFromExpr;
    fromAlias;
    joinAliases;
    query;
    fromRow;
    constructor(rawFromExpr, fromAlias, joinAliases, query, fromRow) {
        super(rawFromExpr, fromAlias, joinAliases, query, fromRow);
        this.rawFromExpr = rawFromExpr;
        this.fromAlias = fromAlias;
        this.joinAliases = joinAliases;
        this.query = query;
        this.fromRow = fromRow;
    }
    static of(fromRow) {
        return class extends Table {
            static new(fromExpr) {
                const alias = new QueryAlias(fromExpr.table);
                return new Table(fromExpr, alias, {}, {
                    from: aliasRowLike(alias, fromRow),
                }, fromRow);
            }
        };
    }
    insert(expr) {
        const keys = sql.join(Object.keys(expr.query.from).toSorted().map(sql.ref), sql.raw(", "));
        const statement = sql `
      INSERT INTO ${sql.ref(this.rawFromExpr.table)} (${keys})
      (${expr.compile(Context.new().withReference(this.rawFromExpr.table))})
      RETURNING *
    `;
        return {
            execute: async (db) => {
                try {
                    const res = await db.executeQuery(statement.compile(db));
                    return res.rows;
                }
                catch (e) {
                    console.error("Error executing insert:", e, statement.compile(db));
                    throw e;
                }
            },
        };
    }
    update(arg) {
        return new UpdateBuilder(this, arg);
    }
}
class UpdateBuilder {
    table;
    arg;
    constructor(table, arg) {
        this.table = table;
        this.arg = arg;
    }
    set(setCb) {
        const builder = this;
        return {
            async execute(db) {
                const alias = new QueryAlias(builder.table.rawFromExpr.table);
                const asAlias = aliasRowLike(alias, resultType(builder.table.query));
                const where = "where" in builder.arg ? builder.arg.where(asAlias) : undefined;
                const from = "from" in builder.arg && builder.arg.from
                    ? builder.arg.from(asAlias)
                    : undefined;
                const wheres = [where, ...(from?.query.wheres ?? [])].filter((where) => where !== undefined);
                const { wheres: _fromWheres, ...rest } = from?.query ?? {};
                const fromWithoutWheres = from &&
                    "from" in rest &&
                    new Setof(from.rawFromExpr, from.fromAlias, from.joinAliases, rest, from.fromRow);
                const set = setCb(asAlias, ...(builder.arg.from && from ? from.toSelectArgs() : []));
                const ctx = Context.new().withAliases([
                    alias,
                    ...(from ? [from.fromAlias, ...Object.values(from.joinAliases)] : []),
                ]);
                const statement = sql `
        UPDATE ${sql.ref(builder.table.rawFromExpr.table)}
        SET ${sql.join(Object.entries(set).map(([key, value]) => sql `${sql.ref(key)} = ${value.toExpression().compile(ctx)}`), sql.raw(", "))}
        ${fromWithoutWheres
                    ? sql `FROM ${fromWithoutWheres.compile(ctx)} AS ${sql.ref(from.fromAlias.name)}`
                    : sql ``}
        ${wheres.length
                    ? sql `WHERE ${sql.join(wheres.map((where) => where.toExpression().compile(ctx)), sql.raw(" AND "))}`
                    : sql ``}
        RETURNING ${sql.ref(builder.table.rawFromExpr.table)}.*
      `;
                try {
                    const res = await db.executeQuery(statement.compile(db));
                    return res.rows;
                }
                catch (e) {
                    console.error("Error executing update:", e, statement.compile(db));
                    throw e;
                }
            },
        };
    }
}

function riFKeyCascadeDel(...args) {
    return sqlFunction("RI_FKey_cascade_del", [{ args: [], ret: (trigger), isOperator: false }], args);
}
function riFKeyCascadeUpd(...args) {
    return sqlFunction("RI_FKey_cascade_upd", [{ args: [], ret: (trigger), isOperator: false }], args);
}
function riFKeyCheckIns(...args) {
    return sqlFunction("RI_FKey_check_ins", [{ args: [], ret: (trigger), isOperator: false }], args);
}
function riFKeyCheckUpd(...args) {
    return sqlFunction("RI_FKey_check_upd", [{ args: [], ret: (trigger), isOperator: false }], args);
}
function riFKeyNoactionDel(...args) {
    return sqlFunction("RI_FKey_noaction_del", [{ args: [], ret: (trigger), isOperator: false }], args);
}
function riFKeyNoactionUpd(...args) {
    return sqlFunction("RI_FKey_noaction_upd", [{ args: [], ret: (trigger), isOperator: false }], args);
}
function riFKeyRestrictDel(...args) {
    return sqlFunction("RI_FKey_restrict_del", [{ args: [], ret: (trigger), isOperator: false }], args);
}
function riFKeyRestrictUpd(...args) {
    return sqlFunction("RI_FKey_restrict_upd", [{ args: [], ret: (trigger), isOperator: false }], args);
}
function riFKeySetdefaultDel(...args) {
    return sqlFunction("RI_FKey_setdefault_del", [{ args: [], ret: (trigger), isOperator: false }], args);
}
function riFKeySetdefaultUpd(...args) {
    return sqlFunction("RI_FKey_setdefault_upd", [{ args: [], ret: (trigger), isOperator: false }], args);
}
function riFKeySetnullDel(...args) {
    return sqlFunction("RI_FKey_setnull_del", [{ args: [], ret: (trigger), isOperator: false }], args);
}
function riFKeySetnullUpd(...args) {
    return sqlFunction("RI_FKey_setnull_upd", [{ args: [], ret: (trigger), isOperator: false }], args);
}
function abbrev(...args) {
    return sqlFunction("abbrev", [{ args: [(cidr$1)], ret: (default_1$1), isOperator: false }, { args: [(inet)], ret: (default_1$1), isOperator: false }], args);
}
function abs(...args) {
    return sqlFunction("abs", [{ args: [(default_1$7)], ret: (default_1$7), isOperator: false }, { args: [(default_1$6)], ret: (default_1$6), isOperator: false }, { args: [(default_1$5)], ret: (default_1$5), isOperator: false }, { args: [(default_1$4)], ret: (default_1$4), isOperator: false }, { args: [(default_1$3)], ret: (default_1$3), isOperator: false }, { args: [(default_1$2)], ret: (default_1$2), isOperator: false }], args);
}
function aclcontains(...args) {
    return sqlFunction("aclcontains", [{ args: [Array$1.of((aclitem)), (aclitem)], ret: (default_1$8), isOperator: false }], args);
}
function acldefault(...args) {
    return sqlFunction("acldefault", [{ args: [(char$1), (oid$1)], ret: Array$1.of((aclitem)), isOperator: false }], args);
}
function aclexplode(...args) {
    return sqlFunction("aclexplode", [{ args: [Array$1.of((aclitem))], ret: Setof.ofSchema({ grantor: (oid$1), grantee: (oid$1), privilege_type: (default_1$1), is_grantable: (default_1$8) }), isOperator: false }], args);
}
function aclinsert(...args) {
    return sqlFunction("aclinsert", [{ args: [Array$1.of((aclitem)), (aclitem)], ret: Array$1.of((aclitem)), isOperator: false }], args);
}
function aclitemeq(...args) {
    return sqlFunction("aclitemeq", [{ args: [(aclitem), (aclitem)], ret: (default_1$8), isOperator: false }], args);
}
function aclremove(...args) {
    return sqlFunction("aclremove", [{ args: [Array$1.of((aclitem)), (aclitem)], ret: Array$1.of((aclitem)), isOperator: false }], args);
}
function acos(...args) {
    return sqlFunction("acos", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function acosd(...args) {
    return sqlFunction("acosd", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function acosh(...args) {
    return sqlFunction("acosh", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function age(...args) {
    return sqlFunction("age", [{ args: [(xid$1)], ret: (default_1$4), isOperator: false }, { args: [(timestamp$1)], ret: (interval$1), isOperator: false }, { args: [(timestamp$1), (timestamp$1)], ret: (interval$1), isOperator: false }, { args: [(timestamptz$1)], ret: (interval$1), isOperator: false }, { args: [(timestamptz$1), (timestamptz$1)], ret: (interval$1), isOperator: false }], args);
}
function amvalidate(...args) {
    return sqlFunction("amvalidate", [{ args: [(oid$1)], ret: (default_1$8), isOperator: false }], args);
}
function anyValue(...args) {
    return sqlFunction("any_value", [({ T }) => ({ args: [T], ret: T, isOperator: false })], args);
}
function anyValueTransfn(...args) {
    return sqlFunction("any_value_transfn", [({ T }) => ({ args: [T, T], ret: T, isOperator: false })], args);
}
function anytextcat(...args) {
    return sqlFunction("anytextcat", [({ T }) => ({ args: [T, (default_1$1)], ret: (default_1$1), isOperator: false })], args);
}
function area(...args) {
    return sqlFunction("area", [{ args: [(box$1)], ret: (default_1$6), isOperator: false }, { args: [(circle$1)], ret: (default_1$6), isOperator: false }, { args: [(path$1)], ret: (default_1$6), isOperator: false }], args);
}
function arrayAgg(...args) {
    return sqlFunction("array_agg", [({ T }) => ({ args: [Array$1.of(T)], ret: Array$1.of(T), isOperator: false }), ({ T }) => ({ args: [T], ret: Array$1.of(T), isOperator: false })], args);
}
function arrayAppend(...args) {
    return sqlFunction("array_append", [({ T }) => ({ args: [Array$1.of(T), T], ret: Array$1.of(T), isOperator: false })], args);
}
function arrayCat(...args) {
    return sqlFunction("array_cat", [({ T }) => ({ args: [Array$1.of(T), Array$1.of(T)], ret: Array$1.of(T), isOperator: false })], args);
}
function arrayDims(...args) {
    return sqlFunction("array_dims", [({ T }) => ({ args: [Array$1.of(T)], ret: (default_1$1), isOperator: false })], args);
}
function arrayEq(...args) {
    return sqlFunction("array_eq", [({ T }) => ({ args: [Array$1.of(T), Array$1.of(T)], ret: (default_1$8), isOperator: false })], args);
}
function arrayFill(...args) {
    return sqlFunction("array_fill", [({ T }) => ({ args: [T, Array$1.of((default_1$4))], ret: Array$1.of(T), isOperator: false }), ({ T }) => ({ args: [T, Array$1.of((default_1$4)), Array$1.of((default_1$4))], ret: Array$1.of(T), isOperator: false })], args);
}
function arrayGe(...args) {
    return sqlFunction("array_ge", [({ T }) => ({ args: [Array$1.of(T), Array$1.of(T)], ret: (default_1$8), isOperator: false })], args);
}
function arrayGt(...args) {
    return sqlFunction("array_gt", [({ T }) => ({ args: [Array$1.of(T), Array$1.of(T)], ret: (default_1$8), isOperator: false })], args);
}
function arrayLarger(...args) {
    return sqlFunction("array_larger", [({ T }) => ({ args: [Array$1.of(T), Array$1.of(T)], ret: Array$1.of(T), isOperator: false })], args);
}
function arrayLe(...args) {
    return sqlFunction("array_le", [({ T }) => ({ args: [Array$1.of(T), Array$1.of(T)], ret: (default_1$8), isOperator: false })], args);
}
function arrayLength(...args) {
    return sqlFunction("array_length", [({ T }) => ({ args: [Array$1.of(T), (default_1$4)], ret: (default_1$4), isOperator: false })], args);
}
function arrayLower(...args) {
    return sqlFunction("array_lower", [({ T }) => ({ args: [Array$1.of(T), (default_1$4)], ret: (default_1$4), isOperator: false })], args);
}
function arrayLt(...args) {
    return sqlFunction("array_lt", [({ T }) => ({ args: [Array$1.of(T), Array$1.of(T)], ret: (default_1$8), isOperator: false })], args);
}
function arrayNdims(...args) {
    return sqlFunction("array_ndims", [({ T }) => ({ args: [Array$1.of(T)], ret: (default_1$4), isOperator: false })], args);
}
function arrayNe(...args) {
    return sqlFunction("array_ne", [({ T }) => ({ args: [Array$1.of(T), Array$1.of(T)], ret: (default_1$8), isOperator: false })], args);
}
function arrayPosition(...args) {
    return sqlFunction("array_position", [({ T }) => ({ args: [Array$1.of(T), T], ret: (default_1$4), isOperator: false }), ({ T }) => ({ args: [Array$1.of(T), T, (default_1$4)], ret: (default_1$4), isOperator: false })], args);
}
function arrayPositions(...args) {
    return sqlFunction("array_positions", [({ T }) => ({ args: [Array$1.of(T), T], ret: Array$1.of((default_1$4)), isOperator: false })], args);
}
function arrayPrepend(...args) {
    return sqlFunction("array_prepend", [({ T }) => ({ args: [T, Array$1.of(T)], ret: Array$1.of(T), isOperator: false })], args);
}
function arrayRemove(...args) {
    return sqlFunction("array_remove", [({ T }) => ({ args: [Array$1.of(T), T], ret: Array$1.of(T), isOperator: false })], args);
}
function arrayReplace(...args) {
    return sqlFunction("array_replace", [({ T }) => ({ args: [Array$1.of(T), T, T], ret: Array$1.of(T), isOperator: false })], args);
}
function arraySample(...args) {
    return sqlFunction("array_sample", [({ T }) => ({ args: [Array$1.of(T), (default_1$4)], ret: Array$1.of(T), isOperator: false })], args);
}
function arrayShuffle(...args) {
    return sqlFunction("array_shuffle", [({ T }) => ({ args: [Array$1.of(T)], ret: Array$1.of(T), isOperator: false })], args);
}
function arraySmaller(...args) {
    return sqlFunction("array_smaller", [({ T }) => ({ args: [Array$1.of(T), Array$1.of(T)], ret: Array$1.of(T), isOperator: false })], args);
}
function arrayToJson(...args) {
    return sqlFunction("array_to_json", [({ T }) => ({ args: [Array$1.of(T)], ret: (json), isOperator: false }), ({ T }) => ({ args: [Array$1.of(T), (default_1$8)], ret: (json), isOperator: false })], args);
}
function arrayToString(...args) {
    return sqlFunction("array_to_string", [({ T }) => ({ args: [Array$1.of(T), (default_1$1)], ret: (default_1$1), isOperator: false }), ({ T }) => ({ args: [Array$1.of(T), (default_1$1), (default_1$1)], ret: (default_1$1), isOperator: false })], args);
}
function arrayToTsvector(...args) {
    return sqlFunction("array_to_tsvector", [{ args: [Array$1.of((default_1$1))], ret: (tsvector), isOperator: false }], args);
}
function arrayUpper(...args) {
    return sqlFunction("array_upper", [({ T }) => ({ args: [Array$1.of(T), (default_1$4)], ret: (default_1$4), isOperator: false })], args);
}
function arraycontained(...args) {
    return sqlFunction("arraycontained", [({ T }) => ({ args: [Array$1.of(T), Array$1.of(T)], ret: (default_1$8), isOperator: false })], args);
}
function arraycontains(...args) {
    return sqlFunction("arraycontains", [({ T }) => ({ args: [Array$1.of(T), Array$1.of(T)], ret: (default_1$8), isOperator: false })], args);
}
function arrayoverlap(...args) {
    return sqlFunction("arrayoverlap", [({ T }) => ({ args: [Array$1.of(T), Array$1.of(T)], ret: (default_1$8), isOperator: false })], args);
}
function ascii(...args) {
    return sqlFunction("ascii", [{ args: [(default_1$1)], ret: (default_1$4), isOperator: false }], args);
}
function asind(...args) {
    return sqlFunction("asind", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function asinh(...args) {
    return sqlFunction("asinh", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function atan(...args) {
    return sqlFunction("atan", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function atan2(...args) {
    return sqlFunction("atan2", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function atan2D(...args) {
    return sqlFunction("atan2d", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function atand(...args) {
    return sqlFunction("atand", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function atanh(...args) {
    return sqlFunction("atanh", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function avg(...args) {
    return sqlFunction("avg", [{ args: [(default_1$7)], ret: (default_1$6), isOperator: false }, { args: [(default_1$6)], ret: (default_1$6), isOperator: false }, { args: [(interval$1)], ret: (interval$1), isOperator: false }, { args: [(default_1$5)], ret: (default_1$2), isOperator: false }, { args: [(default_1$4)], ret: (default_1$2), isOperator: false }, { args: [(default_1$3)], ret: (default_1$2), isOperator: false }, { args: [(default_1$2)], ret: (default_1$2), isOperator: false }], args);
}
function binaryUpgradeAddSubRelState(...args) {
    return sqlFunction("binary_upgrade_add_sub_rel_state", [{ args: [(default_1$1), (oid$1), (char$1), (pg_lsn)], ret: (_void), isOperator: false }], args);
}
function binaryUpgradeCreateEmptyExtension(...args) {
    return sqlFunction("binary_upgrade_create_empty_extension", [{ args: [(default_1$1), (default_1$1), (default_1$8), (default_1$1), Array$1.of((oid$1)), Array$1.of((default_1$1)), Array$1.of((default_1$1))], ret: (_void), isOperator: false }], args);
}
function binaryUpgradeLogicalSlotHasCaughtUp(...args) {
    return sqlFunction("binary_upgrade_logical_slot_has_caught_up", [{ args: [(name$1)], ret: (default_1$8), isOperator: false }], args);
}
function binaryUpgradeReploriginAdvance(...args) {
    return sqlFunction("binary_upgrade_replorigin_advance", [{ args: [(default_1$1), (pg_lsn)], ret: (_void), isOperator: false }], args);
}
function binaryUpgradeSetMissingValue(...args) {
    return sqlFunction("binary_upgrade_set_missing_value", [{ args: [(oid$1), (default_1$1), (default_1$1)], ret: (_void), isOperator: false }], args);
}
function binaryUpgradeSetNextArrayPgTypeOid(...args) {
    return sqlFunction("binary_upgrade_set_next_array_pg_type_oid", [{ args: [(oid$1)], ret: (_void), isOperator: false }], args);
}
function binaryUpgradeSetNextHeapPgClassOid(...args) {
    return sqlFunction("binary_upgrade_set_next_heap_pg_class_oid", [{ args: [(oid$1)], ret: (_void), isOperator: false }], args);
}
function binaryUpgradeSetNextHeapRelfilenode(...args) {
    return sqlFunction("binary_upgrade_set_next_heap_relfilenode", [{ args: [(oid$1)], ret: (_void), isOperator: false }], args);
}
function binaryUpgradeSetNextIndexPgClassOid(...args) {
    return sqlFunction("binary_upgrade_set_next_index_pg_class_oid", [{ args: [(oid$1)], ret: (_void), isOperator: false }], args);
}
function binaryUpgradeSetNextIndexRelfilenode(...args) {
    return sqlFunction("binary_upgrade_set_next_index_relfilenode", [{ args: [(oid$1)], ret: (_void), isOperator: false }], args);
}
function binaryUpgradeSetNextMultirangeArrayPgTypeOid(...args) {
    return sqlFunction("binary_upgrade_set_next_multirange_array_pg_type_oid", [{ args: [(oid$1)], ret: (_void), isOperator: false }], args);
}
function binaryUpgradeSetNextMultirangePgTypeOid(...args) {
    return sqlFunction("binary_upgrade_set_next_multirange_pg_type_oid", [{ args: [(oid$1)], ret: (_void), isOperator: false }], args);
}
function binaryUpgradeSetNextPgAuthidOid(...args) {
    return sqlFunction("binary_upgrade_set_next_pg_authid_oid", [{ args: [(oid$1)], ret: (_void), isOperator: false }], args);
}
function binaryUpgradeSetNextPgEnumOid(...args) {
    return sqlFunction("binary_upgrade_set_next_pg_enum_oid", [{ args: [(oid$1)], ret: (_void), isOperator: false }], args);
}
function binaryUpgradeSetNextPgTablespaceOid(...args) {
    return sqlFunction("binary_upgrade_set_next_pg_tablespace_oid", [{ args: [(oid$1)], ret: (_void), isOperator: false }], args);
}
function binaryUpgradeSetNextPgTypeOid(...args) {
    return sqlFunction("binary_upgrade_set_next_pg_type_oid", [{ args: [(oid$1)], ret: (_void), isOperator: false }], args);
}
function binaryUpgradeSetNextToastPgClassOid(...args) {
    return sqlFunction("binary_upgrade_set_next_toast_pg_class_oid", [{ args: [(oid$1)], ret: (_void), isOperator: false }], args);
}
function binaryUpgradeSetNextToastRelfilenode(...args) {
    return sqlFunction("binary_upgrade_set_next_toast_relfilenode", [{ args: [(oid$1)], ret: (_void), isOperator: false }], args);
}
function binaryUpgradeSetRecordInitPrivs(...args) {
    return sqlFunction("binary_upgrade_set_record_init_privs", [{ args: [(default_1$8)], ret: (_void), isOperator: false }], args);
}
function bit(...args) {
    return sqlFunction("bit", [{ args: [(bit$1), (default_1$4), (default_1$8)], ret: (bit$1), isOperator: false }, { args: [(default_1$4), (default_1$4)], ret: (bit$1), isOperator: false }, { args: [(default_1$3), (default_1$4)], ret: (bit$1), isOperator: false }], args);
}
function bitAnd(...args) {
    return sqlFunction("bit_and", [{ args: [(bit$1)], ret: (bit$1), isOperator: false }, { args: [(default_1$5)], ret: (default_1$5), isOperator: false }, { args: [(default_1$4)], ret: (default_1$4), isOperator: false }, { args: [(default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function bitCount(...args) {
    return sqlFunction("bit_count", [{ args: [(bit$1)], ret: (default_1$3), isOperator: false }, { args: [(bytea)], ret: (default_1$3), isOperator: false }], args);
}
function bitLength(...args) {
    return sqlFunction("bit_length", [{ args: [(bit$1)], ret: (default_1$4), isOperator: false }, { args: [(bytea)], ret: (default_1$4), isOperator: false }, { args: [(default_1$1)], ret: (default_1$4), isOperator: false }], args);
}
function bitOr(...args) {
    return sqlFunction("bit_or", [{ args: [(bit$1)], ret: (bit$1), isOperator: false }, { args: [(default_1$5)], ret: (default_1$5), isOperator: false }, { args: [(default_1$4)], ret: (default_1$4), isOperator: false }, { args: [(default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function bitXor(...args) {
    return sqlFunction("bit_xor", [{ args: [(bit$1)], ret: (bit$1), isOperator: false }, { args: [(default_1$5)], ret: (default_1$5), isOperator: false }, { args: [(default_1$4)], ret: (default_1$4), isOperator: false }, { args: [(default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function bitand(...args) {
    return sqlFunction("bitand", [{ args: [(bit$1), (bit$1)], ret: (bit$1), isOperator: false }], args);
}
function bitcat(...args) {
    return sqlFunction("bitcat", [{ args: [(varbit$1), (varbit$1)], ret: (varbit$1), isOperator: false }], args);
}
function bitcmp(...args) {
    return sqlFunction("bitcmp", [{ args: [(bit$1), (bit$1)], ret: (default_1$4), isOperator: false }], args);
}
function biteq(...args) {
    return sqlFunction("biteq", [{ args: [(bit$1), (bit$1)], ret: (default_1$8), isOperator: false }], args);
}
function bitge(...args) {
    return sqlFunction("bitge", [{ args: [(bit$1), (bit$1)], ret: (default_1$8), isOperator: false }], args);
}
function bitgt(...args) {
    return sqlFunction("bitgt", [{ args: [(bit$1), (bit$1)], ret: (default_1$8), isOperator: false }], args);
}
function bitle(...args) {
    return sqlFunction("bitle", [{ args: [(bit$1), (bit$1)], ret: (default_1$8), isOperator: false }], args);
}
function bitlt(...args) {
    return sqlFunction("bitlt", [{ args: [(bit$1), (bit$1)], ret: (default_1$8), isOperator: false }], args);
}
function bitne(...args) {
    return sqlFunction("bitne", [{ args: [(bit$1), (bit$1)], ret: (default_1$8), isOperator: false }], args);
}
function bitnot(...args) {
    return sqlFunction("bitnot", [{ args: [(bit$1)], ret: (bit$1), isOperator: false }], args);
}
function bitor(...args) {
    return sqlFunction("bitor", [{ args: [(bit$1), (bit$1)], ret: (bit$1), isOperator: false }], args);
}
function bitshiftleft(...args) {
    return sqlFunction("bitshiftleft", [{ args: [(bit$1), (default_1$4)], ret: (bit$1), isOperator: false }], args);
}
function bitshiftright(...args) {
    return sqlFunction("bitshiftright", [{ args: [(bit$1), (default_1$4)], ret: (bit$1), isOperator: false }], args);
}
function bitxor(...args) {
    return sqlFunction("bitxor", [{ args: [(bit$1), (bit$1)], ret: (bit$1), isOperator: false }], args);
}
function bool(...args) {
    return sqlFunction("bool", [{ args: [(default_1$4)], ret: (default_1$8), isOperator: false }, { args: [(jsonb)], ret: (default_1$8), isOperator: false }], args);
}
function boolAnd(...args) {
    return sqlFunction("bool_and", [{ args: [(default_1$8)], ret: (default_1$8), isOperator: false }], args);
}
function boolOr(...args) {
    return sqlFunction("bool_or", [{ args: [(default_1$8)], ret: (default_1$8), isOperator: false }], args);
}
function boolandStatefunc(...args) {
    return sqlFunction("booland_statefunc", [{ args: [(default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }], args);
}
function booleq(...args) {
    return sqlFunction("booleq", [{ args: [(default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }], args);
}
function boolge(...args) {
    return sqlFunction("boolge", [{ args: [(default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }], args);
}
function boolgt(...args) {
    return sqlFunction("boolgt", [{ args: [(default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }], args);
}
function boolle(...args) {
    return sqlFunction("boolle", [{ args: [(default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }], args);
}
function boollt(...args) {
    return sqlFunction("boollt", [{ args: [(default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }], args);
}
function boolne(...args) {
    return sqlFunction("boolne", [{ args: [(default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }], args);
}
function boolorStatefunc(...args) {
    return sqlFunction("boolor_statefunc", [{ args: [(default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }], args);
}
function boundBox(...args) {
    return sqlFunction("bound_box", [{ args: [(box$1), (box$1)], ret: (box$1), isOperator: false }], args);
}
function box(...args) {
    return sqlFunction("box", [{ args: [(circle$1)], ret: (box$1), isOperator: false }, { args: [(point$1)], ret: (box$1), isOperator: false }, { args: [(point$1), (point$1)], ret: (box$1), isOperator: false }, { args: [(polygon$1)], ret: (box$1), isOperator: false }], args);
}
function boxAbove(...args) {
    return sqlFunction("box_above", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: false }], args);
}
function boxAboveEq(...args) {
    return sqlFunction("box_above_eq", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: false }], args);
}
function boxAdd(...args) {
    return sqlFunction("box_add", [{ args: [(box$1), (point$1)], ret: (box$1), isOperator: false }], args);
}
function boxBelow(...args) {
    return sqlFunction("box_below", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: false }], args);
}
function boxBelowEq(...args) {
    return sqlFunction("box_below_eq", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: false }], args);
}
function boxCenter(...args) {
    return sqlFunction("box_center", [{ args: [(box$1)], ret: (point$1), isOperator: false }], args);
}
function boxContainPt(...args) {
    return sqlFunction("box_contain_pt", [{ args: [(box$1), (point$1)], ret: (default_1$8), isOperator: false }], args);
}
function boxContained(...args) {
    return sqlFunction("box_contained", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: false }], args);
}
function boxDistance(...args) {
    return sqlFunction("box_distance", [{ args: [(box$1), (box$1)], ret: (default_1$6), isOperator: false }], args);
}
function boxDiv(...args) {
    return sqlFunction("box_div", [{ args: [(box$1), (point$1)], ret: (box$1), isOperator: false }], args);
}
function boxEq(...args) {
    return sqlFunction("box_eq", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: false }], args);
}
function boxGe(...args) {
    return sqlFunction("box_ge", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: false }], args);
}
function boxGt(...args) {
    return sqlFunction("box_gt", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: false }], args);
}
function boxIntersect(...args) {
    return sqlFunction("box_intersect", [{ args: [(box$1), (box$1)], ret: (box$1), isOperator: false }], args);
}
function boxLe(...args) {
    return sqlFunction("box_le", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: false }], args);
}
function boxLeft(...args) {
    return sqlFunction("box_left", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: false }], args);
}
function boxLt(...args) {
    return sqlFunction("box_lt", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: false }], args);
}
function boxMul(...args) {
    return sqlFunction("box_mul", [{ args: [(box$1), (point$1)], ret: (box$1), isOperator: false }], args);
}
function boxOverabove(...args) {
    return sqlFunction("box_overabove", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: false }], args);
}
function boxOverbelow(...args) {
    return sqlFunction("box_overbelow", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: false }], args);
}
function boxOverlap(...args) {
    return sqlFunction("box_overlap", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: false }, { args: [(box$1), (box$1)], ret: (default_1$8), isOperator: false }], args);
}
function boxOverleft(...args) {
    return sqlFunction("box_overleft", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: false }], args);
}
function boxOverright(...args) {
    return sqlFunction("box_overright", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: false }], args);
}
function boxRight(...args) {
    return sqlFunction("box_right", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: false }], args);
}
function boxSame(...args) {
    return sqlFunction("box_same", [{ args: [(box$1), (box$1)], ret: (default_1$8), isOperator: false }], args);
}
function boxSub(...args) {
    return sqlFunction("box_sub", [{ args: [(box$1), (point$1)], ret: (box$1), isOperator: false }], args);
}
function bpchar(...args) {
    return sqlFunction("bpchar", [{ args: [(bpchar$1), (default_1$4), (default_1$8)], ret: (bpchar$1), isOperator: false }, { args: [(char$1)], ret: (bpchar$1), isOperator: false }, { args: [(name$1)], ret: (bpchar$1), isOperator: false }], args);
}
function bpcharLarger(...args) {
    return sqlFunction("bpchar_larger", [{ args: [(bpchar$1), (bpchar$1)], ret: (bpchar$1), isOperator: false }], args);
}
function bpcharPatternGe(...args) {
    return sqlFunction("bpchar_pattern_ge", [{ args: [(bpchar$1), (bpchar$1)], ret: (default_1$8), isOperator: false }], args);
}
function bpcharPatternGt(...args) {
    return sqlFunction("bpchar_pattern_gt", [{ args: [(bpchar$1), (bpchar$1)], ret: (default_1$8), isOperator: false }], args);
}
function bpcharPatternLe(...args) {
    return sqlFunction("bpchar_pattern_le", [{ args: [(bpchar$1), (bpchar$1)], ret: (default_1$8), isOperator: false }], args);
}
function bpcharPatternLt(...args) {
    return sqlFunction("bpchar_pattern_lt", [{ args: [(bpchar$1), (bpchar$1)], ret: (default_1$8), isOperator: false }], args);
}
function bpcharSmaller(...args) {
    return sqlFunction("bpchar_smaller", [{ args: [(bpchar$1), (bpchar$1)], ret: (bpchar$1), isOperator: false }], args);
}
function bpcharcmp(...args) {
    return sqlFunction("bpcharcmp", [{ args: [(bpchar$1), (bpchar$1)], ret: (default_1$4), isOperator: false }], args);
}
function bpchareq(...args) {
    return sqlFunction("bpchareq", [{ args: [(bpchar$1), (bpchar$1)], ret: (default_1$8), isOperator: false }], args);
}
function bpcharge(...args) {
    return sqlFunction("bpcharge", [{ args: [(bpchar$1), (bpchar$1)], ret: (default_1$8), isOperator: false }], args);
}
function bpchargt(...args) {
    return sqlFunction("bpchargt", [{ args: [(bpchar$1), (bpchar$1)], ret: (default_1$8), isOperator: false }], args);
}
function bpchariclike(...args) {
    return sqlFunction("bpchariclike", [{ args: [(bpchar$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function bpcharicnlike(...args) {
    return sqlFunction("bpcharicnlike", [{ args: [(bpchar$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function bpcharicregexeq(...args) {
    return sqlFunction("bpcharicregexeq", [{ args: [(bpchar$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function bpcharicregexne(...args) {
    return sqlFunction("bpcharicregexne", [{ args: [(bpchar$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function bpcharle(...args) {
    return sqlFunction("bpcharle", [{ args: [(bpchar$1), (bpchar$1)], ret: (default_1$8), isOperator: false }], args);
}
function bpcharlike(...args) {
    return sqlFunction("bpcharlike", [{ args: [(bpchar$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function bpcharlt(...args) {
    return sqlFunction("bpcharlt", [{ args: [(bpchar$1), (bpchar$1)], ret: (default_1$8), isOperator: false }], args);
}
function bpcharne(...args) {
    return sqlFunction("bpcharne", [{ args: [(bpchar$1), (bpchar$1)], ret: (default_1$8), isOperator: false }], args);
}
function bpcharnlike(...args) {
    return sqlFunction("bpcharnlike", [{ args: [(bpchar$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function bpcharregexeq(...args) {
    return sqlFunction("bpcharregexeq", [{ args: [(bpchar$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function bpcharregexne(...args) {
    return sqlFunction("bpcharregexne", [{ args: [(bpchar$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function brinDesummarizeRange(...args) {
    return sqlFunction("brin_desummarize_range", [{ args: [(regclass$1), (default_1$3)], ret: (_void), isOperator: false }], args);
}
function brinSummarizeNewValues(...args) {
    return sqlFunction("brin_summarize_new_values", [{ args: [(regclass$1)], ret: (default_1$4), isOperator: false }], args);
}
function brinSummarizeRange(...args) {
    return sqlFunction("brin_summarize_range", [{ args: [(regclass$1), (default_1$3)], ret: (default_1$4), isOperator: false }], args);
}
function broadcast(...args) {
    return sqlFunction("broadcast", [{ args: [(inet)], ret: (inet), isOperator: false }], args);
}
function btarraycmp(...args) {
    return sqlFunction("btarraycmp", [({ T }) => ({ args: [Array$1.of(T), Array$1.of(T)], ret: (default_1$4), isOperator: false })], args);
}
function btboolcmp(...args) {
    return sqlFunction("btboolcmp", [{ args: [(default_1$8), (default_1$8)], ret: (default_1$4), isOperator: false }], args);
}
function btbpcharPatternCmp(...args) {
    return sqlFunction("btbpchar_pattern_cmp", [{ args: [(bpchar$1), (bpchar$1)], ret: (default_1$4), isOperator: false }], args);
}
function btcharcmp(...args) {
    return sqlFunction("btcharcmp", [{ args: [(char$1), (char$1)], ret: (default_1$4), isOperator: false }], args);
}
function btequalimage(...args) {
    return sqlFunction("btequalimage", [{ args: [(oid$1)], ret: (default_1$8), isOperator: false }], args);
}
function btfloat48Cmp(...args) {
    return sqlFunction("btfloat48cmp", [{ args: [(default_1$7), (default_1$6)], ret: (default_1$4), isOperator: false }], args);
}
function btfloat4Cmp(...args) {
    return sqlFunction("btfloat4cmp", [{ args: [(default_1$7), (default_1$7)], ret: (default_1$4), isOperator: false }], args);
}
function btfloat84Cmp(...args) {
    return sqlFunction("btfloat84cmp", [{ args: [(default_1$6), (default_1$7)], ret: (default_1$4), isOperator: false }], args);
}
function btfloat8Cmp(...args) {
    return sqlFunction("btfloat8cmp", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$4), isOperator: false }], args);
}
function btint24Cmp(...args) {
    return sqlFunction("btint24cmp", [{ args: [(default_1$5), (default_1$4)], ret: (default_1$4), isOperator: false }], args);
}
function btint28Cmp(...args) {
    return sqlFunction("btint28cmp", [{ args: [(default_1$5), (default_1$3)], ret: (default_1$4), isOperator: false }], args);
}
function btint2Cmp(...args) {
    return sqlFunction("btint2cmp", [{ args: [(default_1$5), (default_1$5)], ret: (default_1$4), isOperator: false }], args);
}
function btint42Cmp(...args) {
    return sqlFunction("btint42cmp", [{ args: [(default_1$4), (default_1$5)], ret: (default_1$4), isOperator: false }], args);
}
function btint48Cmp(...args) {
    return sqlFunction("btint48cmp", [{ args: [(default_1$4), (default_1$3)], ret: (default_1$4), isOperator: false }], args);
}
function btint4Cmp(...args) {
    return sqlFunction("btint4cmp", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: false }], args);
}
function btint82Cmp(...args) {
    return sqlFunction("btint82cmp", [{ args: [(default_1$3), (default_1$5)], ret: (default_1$4), isOperator: false }], args);
}
function btint84Cmp(...args) {
    return sqlFunction("btint84cmp", [{ args: [(default_1$3), (default_1$4)], ret: (default_1$4), isOperator: false }], args);
}
function btint8Cmp(...args) {
    return sqlFunction("btint8cmp", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$4), isOperator: false }], args);
}
function btnamecmp(...args) {
    return sqlFunction("btnamecmp", [{ args: [(name$1), (name$1)], ret: (default_1$4), isOperator: false }], args);
}
function btnametextcmp(...args) {
    return sqlFunction("btnametextcmp", [{ args: [(name$1), (default_1$1)], ret: (default_1$4), isOperator: false }], args);
}
function btoidcmp(...args) {
    return sqlFunction("btoidcmp", [{ args: [(oid$1), (oid$1)], ret: (default_1$4), isOperator: false }], args);
}
function btoidvectorcmp(...args) {
    return sqlFunction("btoidvectorcmp", [{ args: [(oidvector), (oidvector)], ret: (default_1$4), isOperator: false }], args);
}
function btrecordcmp(...args) {
    return sqlFunction("btrecordcmp", [({ R }) => ({ args: [Record.of(R), Record.of(R)], ret: (default_1$4), isOperator: false })], args);
}
function btrecordimagecmp(...args) {
    return sqlFunction("btrecordimagecmp", [({ R }) => ({ args: [Record.of(R), Record.of(R)], ret: (default_1$4), isOperator: false })], args);
}
function btrim(...args) {
    return sqlFunction("btrim", [{ args: [(bytea), (bytea)], ret: (bytea), isOperator: false }, { args: [(default_1$1)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$1)], ret: (default_1$1), isOperator: false }], args);
}
function bttextPatternCmp(...args) {
    return sqlFunction("bttext_pattern_cmp", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$4), isOperator: false }], args);
}
function bttextcmp(...args) {
    return sqlFunction("bttextcmp", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$4), isOperator: false }], args);
}
function bttextnamecmp(...args) {
    return sqlFunction("bttextnamecmp", [{ args: [(default_1$1), (name$1)], ret: (default_1$4), isOperator: false }], args);
}
function bttidcmp(...args) {
    return sqlFunction("bttidcmp", [{ args: [(tid), (tid)], ret: (default_1$4), isOperator: false }], args);
}
function btvarstrequalimage(...args) {
    return sqlFunction("btvarstrequalimage", [{ args: [(oid$1)], ret: (default_1$8), isOperator: false }], args);
}
function byteacat(...args) {
    return sqlFunction("byteacat", [{ args: [(bytea), (bytea)], ret: (bytea), isOperator: false }], args);
}
function byteacmp(...args) {
    return sqlFunction("byteacmp", [{ args: [(bytea), (bytea)], ret: (default_1$4), isOperator: false }], args);
}
function byteaeq(...args) {
    return sqlFunction("byteaeq", [{ args: [(bytea), (bytea)], ret: (default_1$8), isOperator: false }], args);
}
function byteage(...args) {
    return sqlFunction("byteage", [{ args: [(bytea), (bytea)], ret: (default_1$8), isOperator: false }], args);
}
function byteagt(...args) {
    return sqlFunction("byteagt", [{ args: [(bytea), (bytea)], ret: (default_1$8), isOperator: false }], args);
}
function byteale(...args) {
    return sqlFunction("byteale", [{ args: [(bytea), (bytea)], ret: (default_1$8), isOperator: false }], args);
}
function bytealike(...args) {
    return sqlFunction("bytealike", [{ args: [(bytea), (bytea)], ret: (default_1$8), isOperator: false }], args);
}
function bytealt(...args) {
    return sqlFunction("bytealt", [{ args: [(bytea), (bytea)], ret: (default_1$8), isOperator: false }], args);
}
function byteane(...args) {
    return sqlFunction("byteane", [{ args: [(bytea), (bytea)], ret: (default_1$8), isOperator: false }], args);
}
function byteanlike(...args) {
    return sqlFunction("byteanlike", [{ args: [(bytea), (bytea)], ret: (default_1$8), isOperator: false }], args);
}
function cardinality(...args) {
    return sqlFunction("cardinality", [({ T }) => ({ args: [Array$1.of(T)], ret: (default_1$4), isOperator: false })], args);
}
function cashCmp(...args) {
    return sqlFunction("cash_cmp", [{ args: [(money$1), (money$1)], ret: (default_1$4), isOperator: false }], args);
}
function cashDivCash(...args) {
    return sqlFunction("cash_div_cash", [{ args: [(money$1), (money$1)], ret: (default_1$6), isOperator: false }], args);
}
function cashDivFlt4(...args) {
    return sqlFunction("cash_div_flt4", [{ args: [(money$1), (default_1$7)], ret: (money$1), isOperator: false }], args);
}
function cashDivFlt8(...args) {
    return sqlFunction("cash_div_flt8", [{ args: [(money$1), (default_1$6)], ret: (money$1), isOperator: false }], args);
}
function cashDivInt2(...args) {
    return sqlFunction("cash_div_int2", [{ args: [(money$1), (default_1$5)], ret: (money$1), isOperator: false }], args);
}
function cashDivInt4(...args) {
    return sqlFunction("cash_div_int4", [{ args: [(money$1), (default_1$4)], ret: (money$1), isOperator: false }], args);
}
function cashDivInt8(...args) {
    return sqlFunction("cash_div_int8", [{ args: [(money$1), (default_1$3)], ret: (money$1), isOperator: false }], args);
}
function cashEq(...args) {
    return sqlFunction("cash_eq", [{ args: [(money$1), (money$1)], ret: (default_1$8), isOperator: false }], args);
}
function cashGe(...args) {
    return sqlFunction("cash_ge", [{ args: [(money$1), (money$1)], ret: (default_1$8), isOperator: false }], args);
}
function cashGt(...args) {
    return sqlFunction("cash_gt", [{ args: [(money$1), (money$1)], ret: (default_1$8), isOperator: false }], args);
}
function cashLe(...args) {
    return sqlFunction("cash_le", [{ args: [(money$1), (money$1)], ret: (default_1$8), isOperator: false }], args);
}
function cashLt(...args) {
    return sqlFunction("cash_lt", [{ args: [(money$1), (money$1)], ret: (default_1$8), isOperator: false }], args);
}
function cashMi(...args) {
    return sqlFunction("cash_mi", [{ args: [(money$1), (money$1)], ret: (money$1), isOperator: false }], args);
}
function cashMulFlt4(...args) {
    return sqlFunction("cash_mul_flt4", [{ args: [(money$1), (default_1$7)], ret: (money$1), isOperator: false }], args);
}
function cashMulFlt8(...args) {
    return sqlFunction("cash_mul_flt8", [{ args: [(money$1), (default_1$6)], ret: (money$1), isOperator: false }], args);
}
function cashMulInt2(...args) {
    return sqlFunction("cash_mul_int2", [{ args: [(money$1), (default_1$5)], ret: (money$1), isOperator: false }], args);
}
function cashMulInt4(...args) {
    return sqlFunction("cash_mul_int4", [{ args: [(money$1), (default_1$4)], ret: (money$1), isOperator: false }], args);
}
function cashMulInt8(...args) {
    return sqlFunction("cash_mul_int8", [{ args: [(money$1), (default_1$3)], ret: (money$1), isOperator: false }], args);
}
function cashNe(...args) {
    return sqlFunction("cash_ne", [{ args: [(money$1), (money$1)], ret: (default_1$8), isOperator: false }], args);
}
function cashPl(...args) {
    return sqlFunction("cash_pl", [{ args: [(money$1), (money$1)], ret: (money$1), isOperator: false }], args);
}
function cashWords(...args) {
    return sqlFunction("cash_words", [{ args: [(money$1)], ret: (default_1$1), isOperator: false }], args);
}
function cashlarger(...args) {
    return sqlFunction("cashlarger", [{ args: [(money$1), (money$1)], ret: (money$1), isOperator: false }], args);
}
function cashsmaller(...args) {
    return sqlFunction("cashsmaller", [{ args: [(money$1), (money$1)], ret: (money$1), isOperator: false }], args);
}
function cbrt(...args) {
    return sqlFunction("cbrt", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function ceil(...args) {
    return sqlFunction("ceil", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }, { args: [(default_1$2)], ret: (default_1$2), isOperator: false }], args);
}
function ceiling(...args) {
    return sqlFunction("ceiling", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }, { args: [(default_1$2)], ret: (default_1$2), isOperator: false }], args);
}
function center(...args) {
    return sqlFunction("center", [{ args: [(box$1)], ret: (point$1), isOperator: false }, { args: [(circle$1)], ret: (point$1), isOperator: false }], args);
}
function char(...args) {
    return sqlFunction("char", [{ args: [(default_1$4)], ret: (char$1), isOperator: false }, { args: [(default_1$1)], ret: (char$1), isOperator: false }], args);
}
function charLength(...args) {
    return sqlFunction("char_length", [{ args: [(bpchar$1)], ret: (default_1$4), isOperator: false }, { args: [(default_1$1)], ret: (default_1$4), isOperator: false }], args);
}
function characterLength(...args) {
    return sqlFunction("character_length", [{ args: [(bpchar$1)], ret: (default_1$4), isOperator: false }, { args: [(default_1$1)], ret: (default_1$4), isOperator: false }], args);
}
function chareq(...args) {
    return sqlFunction("chareq", [{ args: [(char$1), (char$1)], ret: (default_1$8), isOperator: false }], args);
}
function charge(...args) {
    return sqlFunction("charge", [{ args: [(char$1), (char$1)], ret: (default_1$8), isOperator: false }], args);
}
function chargt(...args) {
    return sqlFunction("chargt", [{ args: [(char$1), (char$1)], ret: (default_1$8), isOperator: false }], args);
}
function charle(...args) {
    return sqlFunction("charle", [{ args: [(char$1), (char$1)], ret: (default_1$8), isOperator: false }], args);
}
function charlt(...args) {
    return sqlFunction("charlt", [{ args: [(char$1), (char$1)], ret: (default_1$8), isOperator: false }], args);
}
function charne(...args) {
    return sqlFunction("charne", [{ args: [(char$1), (char$1)], ret: (default_1$8), isOperator: false }], args);
}
function chr(...args) {
    return sqlFunction("chr", [{ args: [(default_1$4)], ret: (default_1$1), isOperator: false }], args);
}
function cideq(...args) {
    return sqlFunction("cideq", [{ args: [(cid), (cid)], ret: (default_1$8), isOperator: false }], args);
}
function cidr(...args) {
    return sqlFunction("cidr", [{ args: [(inet)], ret: (cidr$1), isOperator: false }], args);
}
function circle(...args) {
    return sqlFunction("circle", [{ args: [(box$1)], ret: (circle$1), isOperator: false }, { args: [(point$1), (default_1$6)], ret: (circle$1), isOperator: false }, { args: [(polygon$1)], ret: (circle$1), isOperator: false }], args);
}
function circleAbove(...args) {
    return sqlFunction("circle_above", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: false }], args);
}
function circleAddPt(...args) {
    return sqlFunction("circle_add_pt", [{ args: [(circle$1), (point$1)], ret: (circle$1), isOperator: false }], args);
}
function circleBelow(...args) {
    return sqlFunction("circle_below", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: false }], args);
}
function circleCenter(...args) {
    return sqlFunction("circle_center", [{ args: [(circle$1)], ret: (point$1), isOperator: false }], args);
}
function circleContainPt(...args) {
    return sqlFunction("circle_contain_pt", [{ args: [(circle$1), (point$1)], ret: (default_1$8), isOperator: false }], args);
}
function circleContained(...args) {
    return sqlFunction("circle_contained", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: false }], args);
}
function circleDistance(...args) {
    return sqlFunction("circle_distance", [{ args: [(circle$1), (circle$1)], ret: (default_1$6), isOperator: false }], args);
}
function circleDivPt(...args) {
    return sqlFunction("circle_div_pt", [{ args: [(circle$1), (point$1)], ret: (circle$1), isOperator: false }], args);
}
function circleEq(...args) {
    return sqlFunction("circle_eq", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: false }], args);
}
function circleGe(...args) {
    return sqlFunction("circle_ge", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: false }], args);
}
function circleGt(...args) {
    return sqlFunction("circle_gt", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: false }], args);
}
function circleLe(...args) {
    return sqlFunction("circle_le", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: false }], args);
}
function circleLeft(...args) {
    return sqlFunction("circle_left", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: false }], args);
}
function circleLt(...args) {
    return sqlFunction("circle_lt", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: false }], args);
}
function circleMulPt(...args) {
    return sqlFunction("circle_mul_pt", [{ args: [(circle$1), (point$1)], ret: (circle$1), isOperator: false }], args);
}
function circleNe(...args) {
    return sqlFunction("circle_ne", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: false }], args);
}
function circleOverabove(...args) {
    return sqlFunction("circle_overabove", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: false }], args);
}
function circleOverbelow(...args) {
    return sqlFunction("circle_overbelow", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: false }], args);
}
function circleOverlap(...args) {
    return sqlFunction("circle_overlap", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: false }], args);
}
function circleOverleft(...args) {
    return sqlFunction("circle_overleft", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: false }], args);
}
function circleOverright(...args) {
    return sqlFunction("circle_overright", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: false }], args);
}
function circleRight(...args) {
    return sqlFunction("circle_right", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: false }], args);
}
function circleSame(...args) {
    return sqlFunction("circle_same", [{ args: [(circle$1), (circle$1)], ret: (default_1$8), isOperator: false }], args);
}
function circleSubPt(...args) {
    return sqlFunction("circle_sub_pt", [{ args: [(circle$1), (point$1)], ret: (circle$1), isOperator: false }], args);
}
function clockTimestamp(...args) {
    return sqlFunction("clock_timestamp", [{ args: [], ret: (timestamptz$1), isOperator: false }], args);
}
function closeLs(...args) {
    return sqlFunction("close_ls", [{ args: [(line$1), (lseg$1)], ret: (point$1), isOperator: false }], args);
}
function closeLseg(...args) {
    return sqlFunction("close_lseg", [{ args: [(lseg$1), (lseg$1)], ret: (point$1), isOperator: false }], args);
}
function closePb(...args) {
    return sqlFunction("close_pb", [{ args: [(point$1), (box$1)], ret: (point$1), isOperator: false }], args);
}
function closePl(...args) {
    return sqlFunction("close_pl", [{ args: [(point$1), (line$1)], ret: (point$1), isOperator: false }], args);
}
function closePs(...args) {
    return sqlFunction("close_ps", [{ args: [(point$1), (lseg$1)], ret: (point$1), isOperator: false }], args);
}
function closeSb(...args) {
    return sqlFunction("close_sb", [{ args: [(lseg$1), (box$1)], ret: (point$1), isOperator: false }], args);
}
function colDescription(...args) {
    return sqlFunction("col_description", [{ args: [(oid$1), (default_1$4)], ret: (default_1$1), isOperator: false }], args);
}
function concat(...args) {
    return sqlFunction("concat", [{ args: [(Any)], ret: (default_1$1), isOperator: false }], args);
}
function concatWs(...args) {
    return sqlFunction("concat_ws", [{ args: [(default_1$1), (Any)], ret: (default_1$1), isOperator: false }], args);
}
function convert(...args) {
    return sqlFunction("convert", [{ args: [(bytea), (name$1), (name$1)], ret: (bytea), isOperator: false }], args);
}
function convertFrom(...args) {
    return sqlFunction("convert_from", [{ args: [(bytea), (name$1)], ret: (default_1$1), isOperator: false }], args);
}
function convertTo(...args) {
    return sqlFunction("convert_to", [{ args: [(default_1$1), (name$1)], ret: (bytea), isOperator: false }], args);
}
function corr(...args) {
    return sqlFunction("corr", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function cos(...args) {
    return sqlFunction("cos", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function cosd(...args) {
    return sqlFunction("cosd", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function cosh(...args) {
    return sqlFunction("cosh", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function cot(...args) {
    return sqlFunction("cot", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function cotd(...args) {
    return sqlFunction("cotd", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function count(...args) {
    return sqlFunction("count", [{ args: [], ret: (default_1$3), isOperator: false }, { args: [(Any)], ret: (default_1$3), isOperator: false }], args);
}
function covarPop(...args) {
    return sqlFunction("covar_pop", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function covarSamp(...args) {
    return sqlFunction("covar_samp", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function cumeDist(...args) {
    return sqlFunction("cume_dist", [{ args: [], ret: (default_1$6), isOperator: false }, { args: [(Any)], ret: (default_1$6), isOperator: false }], args);
}
function currentDatabase(...args) {
    return sqlFunction("current_database", [{ args: [], ret: (name$1), isOperator: false }], args);
}
function currentQuery(...args) {
    return sqlFunction("current_query", [{ args: [], ret: (default_1$1), isOperator: false }], args);
}
function currentSchema(...args) {
    return sqlFunction("current_schema", [{ args: [], ret: (name$1), isOperator: false }], args);
}
function currentSchemas(...args) {
    return sqlFunction("current_schemas", [{ args: [(default_1$8)], ret: Array$1.of((name$1)), isOperator: false }], args);
}
function currentSetting(...args) {
    return sqlFunction("current_setting", [{ args: [(default_1$1)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$8)], ret: (default_1$1), isOperator: false }], args);
}
function currentUser(...args) {
    return sqlFunction("current_user", [{ args: [], ret: (name$1), isOperator: false }], args);
}
function currtid2(...args) {
    return sqlFunction("currtid2", [{ args: [(default_1$1), (tid)], ret: (tid), isOperator: false }], args);
}
function currval(...args) {
    return sqlFunction("currval", [{ args: [(regclass$1)], ret: (default_1$3), isOperator: false }], args);
}
function cursorToXml(...args) {
    return sqlFunction("cursor_to_xml", [{ args: [(refcursor), (default_1$4), (default_1$8), (default_1$8), (default_1$1)], ret: (xml$1), isOperator: false }], args);
}
function cursorToXmlschema(...args) {
    return sqlFunction("cursor_to_xmlschema", [{ args: [(refcursor), (default_1$8), (default_1$8), (default_1$1)], ret: (xml$1), isOperator: false }], args);
}
function databaseToXml(...args) {
    return sqlFunction("database_to_xml", [{ args: [(default_1$8), (default_1$8), (default_1$1)], ret: (xml$1), isOperator: false }], args);
}
function databaseToXmlAndXmlschema(...args) {
    return sqlFunction("database_to_xml_and_xmlschema", [{ args: [(default_1$8), (default_1$8), (default_1$1)], ret: (xml$1), isOperator: false }], args);
}
function databaseToXmlschema(...args) {
    return sqlFunction("database_to_xmlschema", [{ args: [(default_1$8), (default_1$8), (default_1$1)], ret: (xml$1), isOperator: false }], args);
}
function date(...args) {
    return sqlFunction("date", [{ args: [(timestamp$1)], ret: (date$1), isOperator: false }, { args: [(timestamptz$1)], ret: (date$1), isOperator: false }], args);
}
function dateAdd(...args) {
    return sqlFunction("date_add", [{ args: [(timestamptz$1), (interval$1)], ret: (timestamptz$1), isOperator: false }, { args: [(timestamptz$1), (interval$1), (default_1$1)], ret: (timestamptz$1), isOperator: false }], args);
}
function dateCmp(...args) {
    return sqlFunction("date_cmp", [{ args: [(date$1), (date$1)], ret: (default_1$4), isOperator: false }], args);
}
function dateCmpTimestamp(...args) {
    return sqlFunction("date_cmp_timestamp", [{ args: [(date$1), (timestamp$1)], ret: (default_1$4), isOperator: false }], args);
}
function dateCmpTimestamptz(...args) {
    return sqlFunction("date_cmp_timestamptz", [{ args: [(date$1), (timestamptz$1)], ret: (default_1$4), isOperator: false }], args);
}
function dateEq(...args) {
    return sqlFunction("date_eq", [{ args: [(date$1), (date$1)], ret: (default_1$8), isOperator: false }], args);
}
function dateEqTimestamp(...args) {
    return sqlFunction("date_eq_timestamp", [{ args: [(date$1), (timestamp$1)], ret: (default_1$8), isOperator: false }], args);
}
function dateEqTimestamptz(...args) {
    return sqlFunction("date_eq_timestamptz", [{ args: [(date$1), (timestamptz$1)], ret: (default_1$8), isOperator: false }], args);
}
function dateGe(...args) {
    return sqlFunction("date_ge", [{ args: [(date$1), (date$1)], ret: (default_1$8), isOperator: false }], args);
}
function dateGeTimestamp(...args) {
    return sqlFunction("date_ge_timestamp", [{ args: [(date$1), (timestamp$1)], ret: (default_1$8), isOperator: false }], args);
}
function dateGeTimestamptz(...args) {
    return sqlFunction("date_ge_timestamptz", [{ args: [(date$1), (timestamptz$1)], ret: (default_1$8), isOperator: false }], args);
}
function dateGt(...args) {
    return sqlFunction("date_gt", [{ args: [(date$1), (date$1)], ret: (default_1$8), isOperator: false }], args);
}
function dateGtTimestamp(...args) {
    return sqlFunction("date_gt_timestamp", [{ args: [(date$1), (timestamp$1)], ret: (default_1$8), isOperator: false }], args);
}
function dateGtTimestamptz(...args) {
    return sqlFunction("date_gt_timestamptz", [{ args: [(date$1), (timestamptz$1)], ret: (default_1$8), isOperator: false }], args);
}
function dateLarger(...args) {
    return sqlFunction("date_larger", [{ args: [(date$1), (date$1)], ret: (date$1), isOperator: false }], args);
}
function dateLe(...args) {
    return sqlFunction("date_le", [{ args: [(date$1), (date$1)], ret: (default_1$8), isOperator: false }], args);
}
function dateLeTimestamp(...args) {
    return sqlFunction("date_le_timestamp", [{ args: [(date$1), (timestamp$1)], ret: (default_1$8), isOperator: false }], args);
}
function dateLeTimestamptz(...args) {
    return sqlFunction("date_le_timestamptz", [{ args: [(date$1), (timestamptz$1)], ret: (default_1$8), isOperator: false }], args);
}
function dateLt(...args) {
    return sqlFunction("date_lt", [{ args: [(date$1), (date$1)], ret: (default_1$8), isOperator: false }], args);
}
function dateLtTimestamp(...args) {
    return sqlFunction("date_lt_timestamp", [{ args: [(date$1), (timestamp$1)], ret: (default_1$8), isOperator: false }], args);
}
function dateLtTimestamptz(...args) {
    return sqlFunction("date_lt_timestamptz", [{ args: [(date$1), (timestamptz$1)], ret: (default_1$8), isOperator: false }], args);
}
function dateMi(...args) {
    return sqlFunction("date_mi", [{ args: [(date$1), (date$1)], ret: (default_1$4), isOperator: false }], args);
}
function dateMiInterval(...args) {
    return sqlFunction("date_mi_interval", [{ args: [(date$1), (interval$1)], ret: (timestamp$1), isOperator: false }], args);
}
function dateMii(...args) {
    return sqlFunction("date_mii", [{ args: [(date$1), (default_1$4)], ret: (date$1), isOperator: false }], args);
}
function dateNe(...args) {
    return sqlFunction("date_ne", [{ args: [(date$1), (date$1)], ret: (default_1$8), isOperator: false }], args);
}
function dateNeTimestamp(...args) {
    return sqlFunction("date_ne_timestamp", [{ args: [(date$1), (timestamp$1)], ret: (default_1$8), isOperator: false }], args);
}
function dateNeTimestamptz(...args) {
    return sqlFunction("date_ne_timestamptz", [{ args: [(date$1), (timestamptz$1)], ret: (default_1$8), isOperator: false }], args);
}
function datePart(...args) {
    return sqlFunction("date_part", [{ args: [(default_1$1), (date$1)], ret: (default_1$6), isOperator: false }, { args: [(default_1$1), (interval$1)], ret: (default_1$6), isOperator: false }, { args: [(default_1$1), (time$1)], ret: (default_1$6), isOperator: false }, { args: [(default_1$1), (timestamp$1)], ret: (default_1$6), isOperator: false }, { args: [(default_1$1), (timestamptz$1)], ret: (default_1$6), isOperator: false }, { args: [(default_1$1), (timetz$1)], ret: (default_1$6), isOperator: false }], args);
}
function datePlInterval(...args) {
    return sqlFunction("date_pl_interval", [{ args: [(date$1), (interval$1)], ret: (timestamp$1), isOperator: false }], args);
}
function datePli(...args) {
    return sqlFunction("date_pli", [{ args: [(date$1), (default_1$4)], ret: (date$1), isOperator: false }], args);
}
function dateSmaller(...args) {
    return sqlFunction("date_smaller", [{ args: [(date$1), (date$1)], ret: (date$1), isOperator: false }], args);
}
function dateSubtract(...args) {
    return sqlFunction("date_subtract", [{ args: [(timestamptz$1), (interval$1)], ret: (timestamptz$1), isOperator: false }, { args: [(timestamptz$1), (interval$1), (default_1$1)], ret: (timestamptz$1), isOperator: false }], args);
}
function dateTrunc(...args) {
    return sqlFunction("date_trunc", [{ args: [(default_1$1), (interval$1)], ret: (interval$1), isOperator: false }, { args: [(default_1$1), (timestamp$1)], ret: (timestamp$1), isOperator: false }, { args: [(default_1$1), (timestamptz$1)], ret: (timestamptz$1), isOperator: false }, { args: [(default_1$1), (timestamptz$1), (default_1$1)], ret: (timestamptz$1), isOperator: false }], args);
}
function datemultirange(...args) {
    return sqlFunction("datemultirange", [{ args: [], ret: (datemultirange$1), isOperator: false }, { args: [Array$1.of((daterange$1))], ret: (datemultirange$1), isOperator: false }, { args: [(daterange$1)], ret: (datemultirange$1), isOperator: false }], args);
}
function daterange(...args) {
    return sqlFunction("daterange", [{ args: [(date$1), (date$1)], ret: (daterange$1), isOperator: false }, { args: [(date$1), (date$1), (default_1$1)], ret: (daterange$1), isOperator: false }], args);
}
function daterangeCanonical(...args) {
    return sqlFunction("daterange_canonical", [{ args: [(daterange$1)], ret: (daterange$1), isOperator: false }], args);
}
function daterangeSubdiff(...args) {
    return sqlFunction("daterange_subdiff", [{ args: [(date$1), (date$1)], ret: (default_1$6), isOperator: false }], args);
}
function datetimePl(...args) {
    return sqlFunction("datetime_pl", [{ args: [(date$1), (time$1)], ret: (timestamp$1), isOperator: false }], args);
}
function datetimetzPl(...args) {
    return sqlFunction("datetimetz_pl", [{ args: [(date$1), (timetz$1)], ret: (timestamptz$1), isOperator: false }], args);
}
function dcbrt(...args) {
    return sqlFunction("dcbrt", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function decode(...args) {
    return sqlFunction("decode", [{ args: [(default_1$1), (default_1$1)], ret: (bytea), isOperator: false }], args);
}
function degrees(...args) {
    return sqlFunction("degrees", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function denseRank(...args) {
    return sqlFunction("dense_rank", [{ args: [], ret: (default_1$3), isOperator: false }, { args: [(Any)], ret: (default_1$3), isOperator: false }], args);
}
function dexp(...args) {
    return sqlFunction("dexp", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function diagonal(...args) {
    return sqlFunction("diagonal", [{ args: [(box$1)], ret: (lseg$1), isOperator: false }], args);
}
function diameter(...args) {
    return sqlFunction("diameter", [{ args: [(circle$1)], ret: (default_1$6), isOperator: false }], args);
}
function distBp(...args) {
    return sqlFunction("dist_bp", [{ args: [(box$1), (point$1)], ret: (default_1$6), isOperator: false }], args);
}
function distBs(...args) {
    return sqlFunction("dist_bs", [{ args: [(box$1), (lseg$1)], ret: (default_1$6), isOperator: false }], args);
}
function distCpoint(...args) {
    return sqlFunction("dist_cpoint", [{ args: [(circle$1), (point$1)], ret: (default_1$6), isOperator: false }], args);
}
function distCpoly(...args) {
    return sqlFunction("dist_cpoly", [{ args: [(circle$1), (polygon$1)], ret: (default_1$6), isOperator: false }], args);
}
function distLp(...args) {
    return sqlFunction("dist_lp", [{ args: [(line$1), (point$1)], ret: (default_1$6), isOperator: false }], args);
}
function distLs(...args) {
    return sqlFunction("dist_ls", [{ args: [(line$1), (lseg$1)], ret: (default_1$6), isOperator: false }], args);
}
function distPathp(...args) {
    return sqlFunction("dist_pathp", [{ args: [(path$1), (point$1)], ret: (default_1$6), isOperator: false }], args);
}
function distPb(...args) {
    return sqlFunction("dist_pb", [{ args: [(point$1), (box$1)], ret: (default_1$6), isOperator: false }], args);
}
function distPc(...args) {
    return sqlFunction("dist_pc", [{ args: [(point$1), (circle$1)], ret: (default_1$6), isOperator: false }], args);
}
function distPl(...args) {
    return sqlFunction("dist_pl", [{ args: [(point$1), (line$1)], ret: (default_1$6), isOperator: false }], args);
}
function distPolyc(...args) {
    return sqlFunction("dist_polyc", [{ args: [(polygon$1), (circle$1)], ret: (default_1$6), isOperator: false }], args);
}
function distPolyp(...args) {
    return sqlFunction("dist_polyp", [{ args: [(polygon$1), (point$1)], ret: (default_1$6), isOperator: false }], args);
}
function distPpath(...args) {
    return sqlFunction("dist_ppath", [{ args: [(point$1), (path$1)], ret: (default_1$6), isOperator: false }], args);
}
function distPpoly(...args) {
    return sqlFunction("dist_ppoly", [{ args: [(point$1), (polygon$1)], ret: (default_1$6), isOperator: false }], args);
}
function distPs(...args) {
    return sqlFunction("dist_ps", [{ args: [(point$1), (lseg$1)], ret: (default_1$6), isOperator: false }], args);
}
function distSb(...args) {
    return sqlFunction("dist_sb", [{ args: [(lseg$1), (box$1)], ret: (default_1$6), isOperator: false }], args);
}
function distSl(...args) {
    return sqlFunction("dist_sl", [{ args: [(lseg$1), (line$1)], ret: (default_1$6), isOperator: false }], args);
}
function distSp(...args) {
    return sqlFunction("dist_sp", [{ args: [(lseg$1), (point$1)], ret: (default_1$6), isOperator: false }], args);
}
function div(...args) {
    return sqlFunction("div", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$2), isOperator: false }], args);
}
function dlog1(...args) {
    return sqlFunction("dlog1", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function dlog10(...args) {
    return sqlFunction("dlog10", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function dpow(...args) {
    return sqlFunction("dpow", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function dround(...args) {
    return sqlFunction("dround", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function dsqrt(...args) {
    return sqlFunction("dsqrt", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function dtrunc(...args) {
    return sqlFunction("dtrunc", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function elemContainedByMultirange(...args) {
    return sqlFunction("elem_contained_by_multirange", [({ T }) => ({ args: [T, anymultirange], ret: (default_1$8), isOperator: false })], args);
}
function elemContainedByRange(...args) {
    return sqlFunction("elem_contained_by_range", [({ T }) => ({ args: [T, anyrange], ret: (default_1$8), isOperator: false })], args);
}
function encode(...args) {
    return sqlFunction("encode", [{ args: [(bytea), (default_1$1)], ret: (default_1$1), isOperator: false }], args);
}
function enumCmp(...args) {
    return sqlFunction("enum_cmp", [({ T }) => ({ args: [T, T], ret: (default_1$4), isOperator: false })], args);
}
function enumEq(...args) {
    return sqlFunction("enum_eq", [({ T }) => ({ args: [T, T], ret: (default_1$8), isOperator: false })], args);
}
function enumFirst(...args) {
    return sqlFunction("enum_first", [({ T }) => ({ args: [T], ret: T, isOperator: false })], args);
}
function enumGe(...args) {
    return sqlFunction("enum_ge", [({ T }) => ({ args: [T, T], ret: (default_1$8), isOperator: false })], args);
}
function enumGt(...args) {
    return sqlFunction("enum_gt", [({ T }) => ({ args: [T, T], ret: (default_1$8), isOperator: false })], args);
}
function enumLarger(...args) {
    return sqlFunction("enum_larger", [({ T }) => ({ args: [T, T], ret: T, isOperator: false })], args);
}
function enumLast(...args) {
    return sqlFunction("enum_last", [({ T }) => ({ args: [T], ret: T, isOperator: false })], args);
}
function enumLe(...args) {
    return sqlFunction("enum_le", [({ T }) => ({ args: [T, T], ret: (default_1$8), isOperator: false })], args);
}
function enumLt(...args) {
    return sqlFunction("enum_lt", [({ T }) => ({ args: [T, T], ret: (default_1$8), isOperator: false })], args);
}
function enumNe(...args) {
    return sqlFunction("enum_ne", [({ T }) => ({ args: [T, T], ret: (default_1$8), isOperator: false })], args);
}
function enumRange(...args) {
    return sqlFunction("enum_range", [({ T }) => ({ args: [T], ret: Array$1.of(T), isOperator: false }), ({ T }) => ({ args: [T, T], ret: Array$1.of(T), isOperator: false })], args);
}
function enumSmaller(...args) {
    return sqlFunction("enum_smaller", [({ T }) => ({ args: [T, T], ret: T, isOperator: false })], args);
}
function erf(...args) {
    return sqlFunction("erf", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function erfc(...args) {
    return sqlFunction("erfc", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function every(...args) {
    return sqlFunction("every", [{ args: [(default_1$8)], ret: (default_1$8), isOperator: false }], args);
}
function exp(...args) {
    return sqlFunction("exp", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }, { args: [(default_1$2)], ret: (default_1$2), isOperator: false }], args);
}
function extract(...args) {
    return sqlFunction("extract", [{ args: [(default_1$1), (date$1)], ret: (default_1$2), isOperator: false }, { args: [(default_1$1), (interval$1)], ret: (default_1$2), isOperator: false }, { args: [(default_1$1), (time$1)], ret: (default_1$2), isOperator: false }, { args: [(default_1$1), (timestamp$1)], ret: (default_1$2), isOperator: false }, { args: [(default_1$1), (timestamptz$1)], ret: (default_1$2), isOperator: false }, { args: [(default_1$1), (timetz$1)], ret: (default_1$2), isOperator: false }], args);
}
function factorial(...args) {
    return sqlFunction("factorial", [{ args: [(default_1$3)], ret: (default_1$2), isOperator: false }], args);
}
function family(...args) {
    return sqlFunction("family", [{ args: [(inet)], ret: (default_1$4), isOperator: false }], args);
}
function firstValue(...args) {
    return sqlFunction("first_value", [({ T }) => ({ args: [T], ret: T, isOperator: false })], args);
}
function float4(...args) {
    return sqlFunction("float4", [{ args: [(default_1$6)], ret: (default_1$7), isOperator: false }, { args: [(default_1$5)], ret: (default_1$7), isOperator: false }, { args: [(default_1$4)], ret: (default_1$7), isOperator: false }, { args: [(default_1$3)], ret: (default_1$7), isOperator: false }, { args: [(jsonb)], ret: (default_1$7), isOperator: false }, { args: [(default_1$2)], ret: (default_1$7), isOperator: false }], args);
}
function float48Div(...args) {
    return sqlFunction("float48div", [{ args: [(default_1$7), (default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function float48Eq(...args) {
    return sqlFunction("float48eq", [{ args: [(default_1$7), (default_1$6)], ret: (default_1$8), isOperator: false }], args);
}
function float48Ge(...args) {
    return sqlFunction("float48ge", [{ args: [(default_1$7), (default_1$6)], ret: (default_1$8), isOperator: false }], args);
}
function float48Gt(...args) {
    return sqlFunction("float48gt", [{ args: [(default_1$7), (default_1$6)], ret: (default_1$8), isOperator: false }], args);
}
function float48Le(...args) {
    return sqlFunction("float48le", [{ args: [(default_1$7), (default_1$6)], ret: (default_1$8), isOperator: false }], args);
}
function float48Lt(...args) {
    return sqlFunction("float48lt", [{ args: [(default_1$7), (default_1$6)], ret: (default_1$8), isOperator: false }], args);
}
function float48Mi(...args) {
    return sqlFunction("float48mi", [{ args: [(default_1$7), (default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function float48Mul(...args) {
    return sqlFunction("float48mul", [{ args: [(default_1$7), (default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function float48Ne(...args) {
    return sqlFunction("float48ne", [{ args: [(default_1$7), (default_1$6)], ret: (default_1$8), isOperator: false }], args);
}
function float48Pl(...args) {
    return sqlFunction("float48pl", [{ args: [(default_1$7), (default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function float4Accum(...args) {
    return sqlFunction("float4_accum", [{ args: [Array$1.of((default_1$6)), (default_1$7)], ret: Array$1.of((default_1$6)), isOperator: false }], args);
}
function float4Abs(...args) {
    return sqlFunction("float4abs", [{ args: [(default_1$7)], ret: (default_1$7), isOperator: false }], args);
}
function float4Div(...args) {
    return sqlFunction("float4div", [{ args: [(default_1$7), (default_1$7)], ret: (default_1$7), isOperator: false }], args);
}
function float4Eq(...args) {
    return sqlFunction("float4eq", [{ args: [(default_1$7), (default_1$7)], ret: (default_1$8), isOperator: false }], args);
}
function float4Ge(...args) {
    return sqlFunction("float4ge", [{ args: [(default_1$7), (default_1$7)], ret: (default_1$8), isOperator: false }], args);
}
function float4Gt(...args) {
    return sqlFunction("float4gt", [{ args: [(default_1$7), (default_1$7)], ret: (default_1$8), isOperator: false }], args);
}
function float4Larger(...args) {
    return sqlFunction("float4larger", [{ args: [(default_1$7), (default_1$7)], ret: (default_1$7), isOperator: false }], args);
}
function float4Le(...args) {
    return sqlFunction("float4le", [{ args: [(default_1$7), (default_1$7)], ret: (default_1$8), isOperator: false }], args);
}
function float4Lt(...args) {
    return sqlFunction("float4lt", [{ args: [(default_1$7), (default_1$7)], ret: (default_1$8), isOperator: false }], args);
}
function float4Mi(...args) {
    return sqlFunction("float4mi", [{ args: [(default_1$7), (default_1$7)], ret: (default_1$7), isOperator: false }], args);
}
function float4Mul(...args) {
    return sqlFunction("float4mul", [{ args: [(default_1$7), (default_1$7)], ret: (default_1$7), isOperator: false }], args);
}
function float4Ne(...args) {
    return sqlFunction("float4ne", [{ args: [(default_1$7), (default_1$7)], ret: (default_1$8), isOperator: false }], args);
}
function float4Pl(...args) {
    return sqlFunction("float4pl", [{ args: [(default_1$7), (default_1$7)], ret: (default_1$7), isOperator: false }], args);
}
function float4Smaller(...args) {
    return sqlFunction("float4smaller", [{ args: [(default_1$7), (default_1$7)], ret: (default_1$7), isOperator: false }], args);
}
function float4Um(...args) {
    return sqlFunction("float4um", [{ args: [(default_1$7)], ret: (default_1$7), isOperator: false }], args);
}
function float4Up(...args) {
    return sqlFunction("float4up", [{ args: [(default_1$7)], ret: (default_1$7), isOperator: false }], args);
}
function float8(...args) {
    return sqlFunction("float8", [{ args: [(default_1$7)], ret: (default_1$6), isOperator: false }, { args: [(default_1$5)], ret: (default_1$6), isOperator: false }, { args: [(default_1$4)], ret: (default_1$6), isOperator: false }, { args: [(default_1$3)], ret: (default_1$6), isOperator: false }, { args: [(jsonb)], ret: (default_1$6), isOperator: false }, { args: [(default_1$2)], ret: (default_1$6), isOperator: false }], args);
}
function float84Div(...args) {
    return sqlFunction("float84div", [{ args: [(default_1$6), (default_1$7)], ret: (default_1$6), isOperator: false }], args);
}
function float84Eq(...args) {
    return sqlFunction("float84eq", [{ args: [(default_1$6), (default_1$7)], ret: (default_1$8), isOperator: false }], args);
}
function float84Ge(...args) {
    return sqlFunction("float84ge", [{ args: [(default_1$6), (default_1$7)], ret: (default_1$8), isOperator: false }], args);
}
function float84Gt(...args) {
    return sqlFunction("float84gt", [{ args: [(default_1$6), (default_1$7)], ret: (default_1$8), isOperator: false }], args);
}
function float84Le(...args) {
    return sqlFunction("float84le", [{ args: [(default_1$6), (default_1$7)], ret: (default_1$8), isOperator: false }], args);
}
function float84Lt(...args) {
    return sqlFunction("float84lt", [{ args: [(default_1$6), (default_1$7)], ret: (default_1$8), isOperator: false }], args);
}
function float84Mi(...args) {
    return sqlFunction("float84mi", [{ args: [(default_1$6), (default_1$7)], ret: (default_1$6), isOperator: false }], args);
}
function float84Mul(...args) {
    return sqlFunction("float84mul", [{ args: [(default_1$6), (default_1$7)], ret: (default_1$6), isOperator: false }], args);
}
function float84Ne(...args) {
    return sqlFunction("float84ne", [{ args: [(default_1$6), (default_1$7)], ret: (default_1$8), isOperator: false }], args);
}
function float84Pl(...args) {
    return sqlFunction("float84pl", [{ args: [(default_1$6), (default_1$7)], ret: (default_1$6), isOperator: false }], args);
}
function float8Accum(...args) {
    return sqlFunction("float8_accum", [{ args: [Array$1.of((default_1$6)), (default_1$6)], ret: Array$1.of((default_1$6)), isOperator: false }], args);
}
function float8Avg(...args) {
    return sqlFunction("float8_avg", [{ args: [Array$1.of((default_1$6))], ret: (default_1$6), isOperator: false }], args);
}
function float8Combine(...args) {
    return sqlFunction("float8_combine", [{ args: [Array$1.of((default_1$6)), Array$1.of((default_1$6))], ret: Array$1.of((default_1$6)), isOperator: false }], args);
}
function float8Corr(...args) {
    return sqlFunction("float8_corr", [{ args: [Array$1.of((default_1$6))], ret: (default_1$6), isOperator: false }], args);
}
function float8CovarPop(...args) {
    return sqlFunction("float8_covar_pop", [{ args: [Array$1.of((default_1$6))], ret: (default_1$6), isOperator: false }], args);
}
function float8CovarSamp(...args) {
    return sqlFunction("float8_covar_samp", [{ args: [Array$1.of((default_1$6))], ret: (default_1$6), isOperator: false }], args);
}
function float8RegrAccum(...args) {
    return sqlFunction("float8_regr_accum", [{ args: [Array$1.of((default_1$6)), (default_1$6), (default_1$6)], ret: Array$1.of((default_1$6)), isOperator: false }], args);
}
function float8RegrAvgx(...args) {
    return sqlFunction("float8_regr_avgx", [{ args: [Array$1.of((default_1$6))], ret: (default_1$6), isOperator: false }], args);
}
function float8RegrAvgy(...args) {
    return sqlFunction("float8_regr_avgy", [{ args: [Array$1.of((default_1$6))], ret: (default_1$6), isOperator: false }], args);
}
function float8RegrCombine(...args) {
    return sqlFunction("float8_regr_combine", [{ args: [Array$1.of((default_1$6)), Array$1.of((default_1$6))], ret: Array$1.of((default_1$6)), isOperator: false }], args);
}
function float8RegrIntercept(...args) {
    return sqlFunction("float8_regr_intercept", [{ args: [Array$1.of((default_1$6))], ret: (default_1$6), isOperator: false }], args);
}
function float8RegrR2(...args) {
    return sqlFunction("float8_regr_r2", [{ args: [Array$1.of((default_1$6))], ret: (default_1$6), isOperator: false }], args);
}
function float8RegrSlope(...args) {
    return sqlFunction("float8_regr_slope", [{ args: [Array$1.of((default_1$6))], ret: (default_1$6), isOperator: false }], args);
}
function float8RegrSxx(...args) {
    return sqlFunction("float8_regr_sxx", [{ args: [Array$1.of((default_1$6))], ret: (default_1$6), isOperator: false }], args);
}
function float8RegrSxy(...args) {
    return sqlFunction("float8_regr_sxy", [{ args: [Array$1.of((default_1$6))], ret: (default_1$6), isOperator: false }], args);
}
function float8RegrSyy(...args) {
    return sqlFunction("float8_regr_syy", [{ args: [Array$1.of((default_1$6))], ret: (default_1$6), isOperator: false }], args);
}
function float8StddevPop(...args) {
    return sqlFunction("float8_stddev_pop", [{ args: [Array$1.of((default_1$6))], ret: (default_1$6), isOperator: false }], args);
}
function float8StddevSamp(...args) {
    return sqlFunction("float8_stddev_samp", [{ args: [Array$1.of((default_1$6))], ret: (default_1$6), isOperator: false }], args);
}
function float8VarPop(...args) {
    return sqlFunction("float8_var_pop", [{ args: [Array$1.of((default_1$6))], ret: (default_1$6), isOperator: false }], args);
}
function float8VarSamp(...args) {
    return sqlFunction("float8_var_samp", [{ args: [Array$1.of((default_1$6))], ret: (default_1$6), isOperator: false }], args);
}
function float8Abs(...args) {
    return sqlFunction("float8abs", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function float8Div(...args) {
    return sqlFunction("float8div", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function float8Eq(...args) {
    return sqlFunction("float8eq", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$8), isOperator: false }], args);
}
function float8Ge(...args) {
    return sqlFunction("float8ge", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$8), isOperator: false }], args);
}
function float8Gt(...args) {
    return sqlFunction("float8gt", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$8), isOperator: false }], args);
}
function float8Larger(...args) {
    return sqlFunction("float8larger", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function float8Le(...args) {
    return sqlFunction("float8le", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$8), isOperator: false }], args);
}
function float8Lt(...args) {
    return sqlFunction("float8lt", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$8), isOperator: false }], args);
}
function float8Mi(...args) {
    return sqlFunction("float8mi", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function float8Mul(...args) {
    return sqlFunction("float8mul", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function float8Ne(...args) {
    return sqlFunction("float8ne", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$8), isOperator: false }], args);
}
function float8Pl(...args) {
    return sqlFunction("float8pl", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function float8Smaller(...args) {
    return sqlFunction("float8smaller", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function float8Um(...args) {
    return sqlFunction("float8um", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function float8Up(...args) {
    return sqlFunction("float8up", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function floor(...args) {
    return sqlFunction("floor", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }, { args: [(default_1$2)], ret: (default_1$2), isOperator: false }], args);
}
function flt4MulCash(...args) {
    return sqlFunction("flt4_mul_cash", [{ args: [(default_1$7), (money$1)], ret: (money$1), isOperator: false }], args);
}
function flt8MulCash(...args) {
    return sqlFunction("flt8_mul_cash", [{ args: [(default_1$6), (money$1)], ret: (money$1), isOperator: false }], args);
}
function fmgrCValidator(...args) {
    return sqlFunction("fmgr_c_validator", [{ args: [(oid$1)], ret: (_void), isOperator: false }], args);
}
function fmgrInternalValidator(...args) {
    return sqlFunction("fmgr_internal_validator", [{ args: [(oid$1)], ret: (_void), isOperator: false }], args);
}
function fmgrSqlValidator(...args) {
    return sqlFunction("fmgr_sql_validator", [{ args: [(oid$1)], ret: (_void), isOperator: false }], args);
}
function format(...args) {
    return sqlFunction("format", [{ args: [(default_1$1)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (Any)], ret: (default_1$1), isOperator: false }], args);
}
function formatType(...args) {
    return sqlFunction("format_type", [{ args: [(oid$1), (default_1$4)], ret: (default_1$1), isOperator: false }], args);
}
function gcd(...args) {
    return sqlFunction("gcd", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: false }, { args: [(default_1$3), (default_1$3)], ret: (default_1$3), isOperator: false }, { args: [(default_1$2), (default_1$2)], ret: (default_1$2), isOperator: false }], args);
}
function genRandomUuid(...args) {
    return sqlFunction("gen_random_uuid", [{ args: [], ret: (uuid), isOperator: false }], args);
}
function generateSeries(...args) {
    return sqlFunction("generate_series", [{ args: [(default_1$4), (default_1$4)], ret: Setof.ofSchema({}), isOperator: false }, { args: [(default_1$4), (default_1$4), (default_1$4)], ret: Setof.ofSchema({}), isOperator: false }, { args: [(default_1$3), (default_1$3)], ret: Setof.ofSchema({}), isOperator: false }, { args: [(default_1$3), (default_1$3), (default_1$3)], ret: Setof.ofSchema({}), isOperator: false }, { args: [(default_1$2), (default_1$2)], ret: Setof.ofSchema({}), isOperator: false }, { args: [(default_1$2), (default_1$2), (default_1$2)], ret: Setof.ofSchema({}), isOperator: false }, { args: [(timestamp$1), (timestamp$1), (interval$1)], ret: Setof.ofSchema({}), isOperator: false }, { args: [(timestamptz$1), (timestamptz$1), (interval$1)], ret: Setof.ofSchema({}), isOperator: false }, { args: [(timestamptz$1), (timestamptz$1), (interval$1), (default_1$1)], ret: Setof.ofSchema({}), isOperator: false }], args);
}
function generateSubscripts(...args) {
    return sqlFunction("generate_subscripts", [({ T }) => ({ args: [Array$1.of(T), (default_1$4)], ret: Setof.ofSchema({}), isOperator: false }), ({ T }) => ({ args: [Array$1.of(T), (default_1$4), (default_1$8)], ret: Setof.ofSchema({}), isOperator: false })], args);
}
function getBit(...args) {
    return sqlFunction("get_bit", [{ args: [(bit$1), (default_1$4)], ret: (default_1$4), isOperator: false }, { args: [(bytea), (default_1$3)], ret: (default_1$4), isOperator: false }], args);
}
function getByte(...args) {
    return sqlFunction("get_byte", [{ args: [(bytea), (default_1$4)], ret: (default_1$4), isOperator: false }], args);
}
function getCurrentTsConfig(...args) {
    return sqlFunction("get_current_ts_config", [{ args: [], ret: (regconfig), isOperator: false }], args);
}
function getdatabaseencoding(...args) {
    return sqlFunction("getdatabaseencoding", [{ args: [], ret: (name$1), isOperator: false }], args);
}
function getpgusername(...args) {
    return sqlFunction("getpgusername", [{ args: [], ret: (name$1), isOperator: false }], args);
}
function ginCleanPendingList(...args) {
    return sqlFunction("gin_clean_pending_list", [{ args: [(regclass$1)], ret: (default_1$3), isOperator: false }], args);
}
function ginCmpTslexeme(...args) {
    return sqlFunction("gin_cmp_tslexeme", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$4), isOperator: false }], args);
}
function ginCompareJsonb(...args) {
    return sqlFunction("gin_compare_jsonb", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$4), isOperator: false }], args);
}
function hasAnyColumnPrivilege(...args) {
    return sqlFunction("has_any_column_privilege", [{ args: [(name$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(name$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function hasColumnPrivilege(...args) {
    return sqlFunction("has_column_privilege", [{ args: [(name$1), (oid$1), (default_1$5), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(name$1), (oid$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(name$1), (default_1$1), (default_1$5), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(name$1), (default_1$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$5), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (oid$1), (default_1$5), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (oid$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1), (default_1$5), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(default_1$1), (default_1$5), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function hasDatabasePrivilege(...args) {
    return sqlFunction("has_database_privilege", [{ args: [(name$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(name$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function hasForeignDataWrapperPrivilege(...args) {
    return sqlFunction("has_foreign_data_wrapper_privilege", [{ args: [(name$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(name$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function hasFunctionPrivilege(...args) {
    return sqlFunction("has_function_privilege", [{ args: [(name$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(name$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function hasLanguagePrivilege(...args) {
    return sqlFunction("has_language_privilege", [{ args: [(name$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(name$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function hasParameterPrivilege(...args) {
    return sqlFunction("has_parameter_privilege", [{ args: [(name$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function hasSchemaPrivilege(...args) {
    return sqlFunction("has_schema_privilege", [{ args: [(name$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(name$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function hasSequencePrivilege(...args) {
    return sqlFunction("has_sequence_privilege", [{ args: [(name$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(name$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function hasServerPrivilege(...args) {
    return sqlFunction("has_server_privilege", [{ args: [(name$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(name$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function hasTablePrivilege(...args) {
    return sqlFunction("has_table_privilege", [{ args: [(name$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(name$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function hasTablespacePrivilege(...args) {
    return sqlFunction("has_tablespace_privilege", [{ args: [(name$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(name$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function hasTypePrivilege(...args) {
    return sqlFunction("has_type_privilege", [{ args: [(name$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(name$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function hashAclitem(...args) {
    return sqlFunction("hash_aclitem", [{ args: [(aclitem)], ret: (default_1$4), isOperator: false }], args);
}
function hashAclitemExtended(...args) {
    return sqlFunction("hash_aclitem_extended", [{ args: [(aclitem), (default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function hashArray(...args) {
    return sqlFunction("hash_array", [({ T }) => ({ args: [Array$1.of(T)], ret: (default_1$4), isOperator: false })], args);
}
function hashArrayExtended(...args) {
    return sqlFunction("hash_array_extended", [({ T }) => ({ args: [Array$1.of(T), (default_1$3)], ret: (default_1$3), isOperator: false })], args);
}
function hashMultirange(...args) {
    return sqlFunction("hash_multirange", [{ args: [anymultirange], ret: (default_1$4), isOperator: false }], args);
}
function hashMultirangeExtended(...args) {
    return sqlFunction("hash_multirange_extended", [{ args: [anymultirange, (default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function hashNumeric(...args) {
    return sqlFunction("hash_numeric", [{ args: [(default_1$2)], ret: (default_1$4), isOperator: false }], args);
}
function hashNumericExtended(...args) {
    return sqlFunction("hash_numeric_extended", [{ args: [(default_1$2), (default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function hashRange(...args) {
    return sqlFunction("hash_range", [{ args: [anyrange], ret: (default_1$4), isOperator: false }], args);
}
function hashRangeExtended(...args) {
    return sqlFunction("hash_range_extended", [{ args: [anyrange, (default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function hashRecord(...args) {
    return sqlFunction("hash_record", [({ R }) => ({ args: [Record.of(R)], ret: (default_1$4), isOperator: false })], args);
}
function hashRecordExtended(...args) {
    return sqlFunction("hash_record_extended", [({ R }) => ({ args: [Record.of(R), (default_1$3)], ret: (default_1$3), isOperator: false })], args);
}
function hashbpchar(...args) {
    return sqlFunction("hashbpchar", [{ args: [(bpchar$1)], ret: (default_1$4), isOperator: false }], args);
}
function hashbpcharextended(...args) {
    return sqlFunction("hashbpcharextended", [{ args: [(bpchar$1), (default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function hashchar(...args) {
    return sqlFunction("hashchar", [{ args: [(char$1)], ret: (default_1$4), isOperator: false }], args);
}
function hashcharextended(...args) {
    return sqlFunction("hashcharextended", [{ args: [(char$1), (default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function hashenum(...args) {
    return sqlFunction("hashenum", [({ T }) => ({ args: [T], ret: (default_1$4), isOperator: false })], args);
}
function hashenumextended(...args) {
    return sqlFunction("hashenumextended", [({ T }) => ({ args: [T, (default_1$3)], ret: (default_1$3), isOperator: false })], args);
}
function hashfloat4(...args) {
    return sqlFunction("hashfloat4", [{ args: [(default_1$7)], ret: (default_1$4), isOperator: false }], args);
}
function hashfloat4Extended(...args) {
    return sqlFunction("hashfloat4extended", [{ args: [(default_1$7), (default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function hashfloat8(...args) {
    return sqlFunction("hashfloat8", [{ args: [(default_1$6)], ret: (default_1$4), isOperator: false }], args);
}
function hashfloat8Extended(...args) {
    return sqlFunction("hashfloat8extended", [{ args: [(default_1$6), (default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function hashinet(...args) {
    return sqlFunction("hashinet", [{ args: [(inet)], ret: (default_1$4), isOperator: false }], args);
}
function hashinetextended(...args) {
    return sqlFunction("hashinetextended", [{ args: [(inet), (default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function hashint2(...args) {
    return sqlFunction("hashint2", [{ args: [(default_1$5)], ret: (default_1$4), isOperator: false }], args);
}
function hashint2Extended(...args) {
    return sqlFunction("hashint2extended", [{ args: [(default_1$5), (default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function hashint4(...args) {
    return sqlFunction("hashint4", [{ args: [(default_1$4)], ret: (default_1$4), isOperator: false }], args);
}
function hashint4Extended(...args) {
    return sqlFunction("hashint4extended", [{ args: [(default_1$4), (default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function hashint8(...args) {
    return sqlFunction("hashint8", [{ args: [(default_1$3)], ret: (default_1$4), isOperator: false }], args);
}
function hashint8Extended(...args) {
    return sqlFunction("hashint8extended", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function hashmacaddr(...args) {
    return sqlFunction("hashmacaddr", [{ args: [(macaddr$1)], ret: (default_1$4), isOperator: false }], args);
}
function hashmacaddr8(...args) {
    return sqlFunction("hashmacaddr8", [{ args: [(macaddr8$1)], ret: (default_1$4), isOperator: false }], args);
}
function hashmacaddr8Extended(...args) {
    return sqlFunction("hashmacaddr8extended", [{ args: [(macaddr8$1), (default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function hashmacaddrextended(...args) {
    return sqlFunction("hashmacaddrextended", [{ args: [(macaddr$1), (default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function hashname(...args) {
    return sqlFunction("hashname", [{ args: [(name$1)], ret: (default_1$4), isOperator: false }], args);
}
function hashnameextended(...args) {
    return sqlFunction("hashnameextended", [{ args: [(name$1), (default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function hashoid(...args) {
    return sqlFunction("hashoid", [{ args: [(oid$1)], ret: (default_1$4), isOperator: false }], args);
}
function hashoidextended(...args) {
    return sqlFunction("hashoidextended", [{ args: [(oid$1), (default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function hashoidvector(...args) {
    return sqlFunction("hashoidvector", [{ args: [(oidvector)], ret: (default_1$4), isOperator: false }], args);
}
function hashoidvectorextended(...args) {
    return sqlFunction("hashoidvectorextended", [{ args: [(oidvector), (default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function hashtext(...args) {
    return sqlFunction("hashtext", [{ args: [(default_1$1)], ret: (default_1$4), isOperator: false }], args);
}
function hashtextextended(...args) {
    return sqlFunction("hashtextextended", [{ args: [(default_1$1), (default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function hashtid(...args) {
    return sqlFunction("hashtid", [{ args: [(tid)], ret: (default_1$4), isOperator: false }], args);
}
function hashtidextended(...args) {
    return sqlFunction("hashtidextended", [{ args: [(tid), (default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function height(...args) {
    return sqlFunction("height", [{ args: [(box$1)], ret: (default_1$6), isOperator: false }], args);
}
function host(...args) {
    return sqlFunction("host", [{ args: [(inet)], ret: (default_1$1), isOperator: false }], args);
}
function hostmask(...args) {
    return sqlFunction("hostmask", [{ args: [(inet)], ret: (inet), isOperator: false }], args);
}
function icuUnicodeVersion(...args) {
    return sqlFunction("icu_unicode_version", [{ args: [], ret: (default_1$1), isOperator: false }], args);
}
function inRange(...args) {
    return sqlFunction("in_range", [{ args: [(date$1), (date$1), (interval$1), (default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }, { args: [(default_1$7), (default_1$7), (default_1$6), (default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }, { args: [(default_1$6), (default_1$6), (default_1$6), (default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }, { args: [(default_1$5), (default_1$5), (default_1$5), (default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }, { args: [(default_1$5), (default_1$5), (default_1$4), (default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }, { args: [(default_1$5), (default_1$5), (default_1$3), (default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }, { args: [(default_1$4), (default_1$4), (default_1$5), (default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }, { args: [(default_1$4), (default_1$4), (default_1$4), (default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }, { args: [(default_1$4), (default_1$4), (default_1$3), (default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }, { args: [(default_1$3), (default_1$3), (default_1$3), (default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }, { args: [(interval$1), (interval$1), (interval$1), (default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }, { args: [(default_1$2), (default_1$2), (default_1$2), (default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }, { args: [(time$1), (time$1), (interval$1), (default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }, { args: [(timestamp$1), (timestamp$1), (interval$1), (default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }, { args: [(timestamptz$1), (timestamptz$1), (interval$1), (default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }, { args: [(timetz$1), (timetz$1), (interval$1), (default_1$8), (default_1$8)], ret: (default_1$8), isOperator: false }], args);
}
function inetClientAddr(...args) {
    return sqlFunction("inet_client_addr", [{ args: [], ret: (inet), isOperator: false }], args);
}
function inetClientPort(...args) {
    return sqlFunction("inet_client_port", [{ args: [], ret: (default_1$4), isOperator: false }], args);
}
function inetMerge(...args) {
    return sqlFunction("inet_merge", [{ args: [(inet), (inet)], ret: (cidr$1), isOperator: false }], args);
}
function inetSameFamily(...args) {
    return sqlFunction("inet_same_family", [{ args: [(inet), (inet)], ret: (default_1$8), isOperator: false }], args);
}
function inetServerAddr(...args) {
    return sqlFunction("inet_server_addr", [{ args: [], ret: (inet), isOperator: false }], args);
}
function inetServerPort(...args) {
    return sqlFunction("inet_server_port", [{ args: [], ret: (default_1$4), isOperator: false }], args);
}
function inetand(...args) {
    return sqlFunction("inetand", [{ args: [(inet), (inet)], ret: (inet), isOperator: false }], args);
}
function inetmi(...args) {
    return sqlFunction("inetmi", [{ args: [(inet), (inet)], ret: (default_1$3), isOperator: false }], args);
}
function inetmiInt8(...args) {
    return sqlFunction("inetmi_int8", [{ args: [(inet), (default_1$3)], ret: (inet), isOperator: false }], args);
}
function inetnot(...args) {
    return sqlFunction("inetnot", [{ args: [(inet)], ret: (inet), isOperator: false }], args);
}
function inetor(...args) {
    return sqlFunction("inetor", [{ args: [(inet), (inet)], ret: (inet), isOperator: false }], args);
}
function inetpl(...args) {
    return sqlFunction("inetpl", [{ args: [(inet), (default_1$3)], ret: (inet), isOperator: false }], args);
}
function initcap(...args) {
    return sqlFunction("initcap", [{ args: [(default_1$1)], ret: (default_1$1), isOperator: false }], args);
}
function int2(...args) {
    return sqlFunction("int2", [{ args: [(default_1$7)], ret: (default_1$5), isOperator: false }, { args: [(default_1$6)], ret: (default_1$5), isOperator: false }, { args: [(default_1$4)], ret: (default_1$5), isOperator: false }, { args: [(default_1$3)], ret: (default_1$5), isOperator: false }, { args: [(jsonb)], ret: (default_1$5), isOperator: false }, { args: [(default_1$2)], ret: (default_1$5), isOperator: false }], args);
}
function int24Div(...args) {
    return sqlFunction("int24div", [{ args: [(default_1$5), (default_1$4)], ret: (default_1$4), isOperator: false }], args);
}
function int24Eq(...args) {
    return sqlFunction("int24eq", [{ args: [(default_1$5), (default_1$4)], ret: (default_1$8), isOperator: false }], args);
}
function int24Ge(...args) {
    return sqlFunction("int24ge", [{ args: [(default_1$5), (default_1$4)], ret: (default_1$8), isOperator: false }], args);
}
function int24Gt(...args) {
    return sqlFunction("int24gt", [{ args: [(default_1$5), (default_1$4)], ret: (default_1$8), isOperator: false }], args);
}
function int24Le(...args) {
    return sqlFunction("int24le", [{ args: [(default_1$5), (default_1$4)], ret: (default_1$8), isOperator: false }], args);
}
function int24Lt(...args) {
    return sqlFunction("int24lt", [{ args: [(default_1$5), (default_1$4)], ret: (default_1$8), isOperator: false }], args);
}
function int24Mi(...args) {
    return sqlFunction("int24mi", [{ args: [(default_1$5), (default_1$4)], ret: (default_1$4), isOperator: false }], args);
}
function int24Mul(...args) {
    return sqlFunction("int24mul", [{ args: [(default_1$5), (default_1$4)], ret: (default_1$4), isOperator: false }], args);
}
function int24Ne(...args) {
    return sqlFunction("int24ne", [{ args: [(default_1$5), (default_1$4)], ret: (default_1$8), isOperator: false }], args);
}
function int24Pl(...args) {
    return sqlFunction("int24pl", [{ args: [(default_1$5), (default_1$4)], ret: (default_1$4), isOperator: false }], args);
}
function int28Div(...args) {
    return sqlFunction("int28div", [{ args: [(default_1$5), (default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function int28Eq(...args) {
    return sqlFunction("int28eq", [{ args: [(default_1$5), (default_1$3)], ret: (default_1$8), isOperator: false }], args);
}
function int28Ge(...args) {
    return sqlFunction("int28ge", [{ args: [(default_1$5), (default_1$3)], ret: (default_1$8), isOperator: false }], args);
}
function int28Gt(...args) {
    return sqlFunction("int28gt", [{ args: [(default_1$5), (default_1$3)], ret: (default_1$8), isOperator: false }], args);
}
function int28Le(...args) {
    return sqlFunction("int28le", [{ args: [(default_1$5), (default_1$3)], ret: (default_1$8), isOperator: false }], args);
}
function int28Lt(...args) {
    return sqlFunction("int28lt", [{ args: [(default_1$5), (default_1$3)], ret: (default_1$8), isOperator: false }], args);
}
function int28Mi(...args) {
    return sqlFunction("int28mi", [{ args: [(default_1$5), (default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function int28Mul(...args) {
    return sqlFunction("int28mul", [{ args: [(default_1$5), (default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function int28Ne(...args) {
    return sqlFunction("int28ne", [{ args: [(default_1$5), (default_1$3)], ret: (default_1$8), isOperator: false }], args);
}
function int28Pl(...args) {
    return sqlFunction("int28pl", [{ args: [(default_1$5), (default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function int2AvgAccum(...args) {
    return sqlFunction("int2_avg_accum", [{ args: [Array$1.of((default_1$3)), (default_1$5)], ret: Array$1.of((default_1$3)), isOperator: false }], args);
}
function int2AvgAccumInv(...args) {
    return sqlFunction("int2_avg_accum_inv", [{ args: [Array$1.of((default_1$3)), (default_1$5)], ret: Array$1.of((default_1$3)), isOperator: false }], args);
}
function int2MulCash(...args) {
    return sqlFunction("int2_mul_cash", [{ args: [(default_1$5), (money$1)], ret: (money$1), isOperator: false }], args);
}
function int2Sum(...args) {
    return sqlFunction("int2_sum", [{ args: [(default_1$3), (default_1$5)], ret: (default_1$3), isOperator: false }], args);
}
function int2Abs(...args) {
    return sqlFunction("int2abs", [{ args: [(default_1$5)], ret: (default_1$5), isOperator: false }], args);
}
function int2And(...args) {
    return sqlFunction("int2and", [{ args: [(default_1$5), (default_1$5)], ret: (default_1$5), isOperator: false }], args);
}
function int2Div(...args) {
    return sqlFunction("int2div", [{ args: [(default_1$5), (default_1$5)], ret: (default_1$5), isOperator: false }], args);
}
function int2Eq(...args) {
    return sqlFunction("int2eq", [{ args: [(default_1$5), (default_1$5)], ret: (default_1$8), isOperator: false }], args);
}
function int2Ge(...args) {
    return sqlFunction("int2ge", [{ args: [(default_1$5), (default_1$5)], ret: (default_1$8), isOperator: false }], args);
}
function int2Gt(...args) {
    return sqlFunction("int2gt", [{ args: [(default_1$5), (default_1$5)], ret: (default_1$8), isOperator: false }], args);
}
function int2Int4Sum(...args) {
    return sqlFunction("int2int4_sum", [{ args: [Array$1.of((default_1$3))], ret: (default_1$3), isOperator: false }], args);
}
function int2Larger(...args) {
    return sqlFunction("int2larger", [{ args: [(default_1$5), (default_1$5)], ret: (default_1$5), isOperator: false }], args);
}
function int2Le(...args) {
    return sqlFunction("int2le", [{ args: [(default_1$5), (default_1$5)], ret: (default_1$8), isOperator: false }], args);
}
function int2Lt(...args) {
    return sqlFunction("int2lt", [{ args: [(default_1$5), (default_1$5)], ret: (default_1$8), isOperator: false }], args);
}
function int2Mi(...args) {
    return sqlFunction("int2mi", [{ args: [(default_1$5), (default_1$5)], ret: (default_1$5), isOperator: false }], args);
}
function int2Mod(...args) {
    return sqlFunction("int2mod", [{ args: [(default_1$5), (default_1$5)], ret: (default_1$5), isOperator: false }], args);
}
function int2Mul(...args) {
    return sqlFunction("int2mul", [{ args: [(default_1$5), (default_1$5)], ret: (default_1$5), isOperator: false }], args);
}
function int2Ne(...args) {
    return sqlFunction("int2ne", [{ args: [(default_1$5), (default_1$5)], ret: (default_1$8), isOperator: false }], args);
}
function int2Not(...args) {
    return sqlFunction("int2not", [{ args: [(default_1$5)], ret: (default_1$5), isOperator: false }], args);
}
function int2Or(...args) {
    return sqlFunction("int2or", [{ args: [(default_1$5), (default_1$5)], ret: (default_1$5), isOperator: false }], args);
}
function int2Pl(...args) {
    return sqlFunction("int2pl", [{ args: [(default_1$5), (default_1$5)], ret: (default_1$5), isOperator: false }], args);
}
function int2Shl(...args) {
    return sqlFunction("int2shl", [{ args: [(default_1$5), (default_1$4)], ret: (default_1$5), isOperator: false }], args);
}
function int2Shr(...args) {
    return sqlFunction("int2shr", [{ args: [(default_1$5), (default_1$4)], ret: (default_1$5), isOperator: false }], args);
}
function int2Smaller(...args) {
    return sqlFunction("int2smaller", [{ args: [(default_1$5), (default_1$5)], ret: (default_1$5), isOperator: false }], args);
}
function int2Um(...args) {
    return sqlFunction("int2um", [{ args: [(default_1$5)], ret: (default_1$5), isOperator: false }], args);
}
function int2Up(...args) {
    return sqlFunction("int2up", [{ args: [(default_1$5)], ret: (default_1$5), isOperator: false }], args);
}
function int2Xor(...args) {
    return sqlFunction("int2xor", [{ args: [(default_1$5), (default_1$5)], ret: (default_1$5), isOperator: false }], args);
}
function int4(...args) {
    return sqlFunction("int4", [{ args: [(bit$1)], ret: (default_1$4), isOperator: false }, { args: [(default_1$8)], ret: (default_1$4), isOperator: false }, { args: [(char$1)], ret: (default_1$4), isOperator: false }, { args: [(default_1$7)], ret: (default_1$4), isOperator: false }, { args: [(default_1$6)], ret: (default_1$4), isOperator: false }, { args: [(default_1$5)], ret: (default_1$4), isOperator: false }, { args: [(default_1$3)], ret: (default_1$4), isOperator: false }, { args: [(jsonb)], ret: (default_1$4), isOperator: false }, { args: [(default_1$2)], ret: (default_1$4), isOperator: false }], args);
}
function int42Div(...args) {
    return sqlFunction("int42div", [{ args: [(default_1$4), (default_1$5)], ret: (default_1$4), isOperator: false }], args);
}
function int42Eq(...args) {
    return sqlFunction("int42eq", [{ args: [(default_1$4), (default_1$5)], ret: (default_1$8), isOperator: false }], args);
}
function int42Ge(...args) {
    return sqlFunction("int42ge", [{ args: [(default_1$4), (default_1$5)], ret: (default_1$8), isOperator: false }], args);
}
function int42Gt(...args) {
    return sqlFunction("int42gt", [{ args: [(default_1$4), (default_1$5)], ret: (default_1$8), isOperator: false }], args);
}
function int42Le(...args) {
    return sqlFunction("int42le", [{ args: [(default_1$4), (default_1$5)], ret: (default_1$8), isOperator: false }], args);
}
function int42Lt(...args) {
    return sqlFunction("int42lt", [{ args: [(default_1$4), (default_1$5)], ret: (default_1$8), isOperator: false }], args);
}
function int42Mi(...args) {
    return sqlFunction("int42mi", [{ args: [(default_1$4), (default_1$5)], ret: (default_1$4), isOperator: false }], args);
}
function int42Mul(...args) {
    return sqlFunction("int42mul", [{ args: [(default_1$4), (default_1$5)], ret: (default_1$4), isOperator: false }], args);
}
function int42Ne(...args) {
    return sqlFunction("int42ne", [{ args: [(default_1$4), (default_1$5)], ret: (default_1$8), isOperator: false }], args);
}
function int42Pl(...args) {
    return sqlFunction("int42pl", [{ args: [(default_1$4), (default_1$5)], ret: (default_1$4), isOperator: false }], args);
}
function int48Div(...args) {
    return sqlFunction("int48div", [{ args: [(default_1$4), (default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function int48Eq(...args) {
    return sqlFunction("int48eq", [{ args: [(default_1$4), (default_1$3)], ret: (default_1$8), isOperator: false }], args);
}
function int48Ge(...args) {
    return sqlFunction("int48ge", [{ args: [(default_1$4), (default_1$3)], ret: (default_1$8), isOperator: false }], args);
}
function int48Gt(...args) {
    return sqlFunction("int48gt", [{ args: [(default_1$4), (default_1$3)], ret: (default_1$8), isOperator: false }], args);
}
function int48Le(...args) {
    return sqlFunction("int48le", [{ args: [(default_1$4), (default_1$3)], ret: (default_1$8), isOperator: false }], args);
}
function int48Lt(...args) {
    return sqlFunction("int48lt", [{ args: [(default_1$4), (default_1$3)], ret: (default_1$8), isOperator: false }], args);
}
function int48Mi(...args) {
    return sqlFunction("int48mi", [{ args: [(default_1$4), (default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function int48Mul(...args) {
    return sqlFunction("int48mul", [{ args: [(default_1$4), (default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function int48Ne(...args) {
    return sqlFunction("int48ne", [{ args: [(default_1$4), (default_1$3)], ret: (default_1$8), isOperator: false }], args);
}
function int48Pl(...args) {
    return sqlFunction("int48pl", [{ args: [(default_1$4), (default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function int4AvgAccum(...args) {
    return sqlFunction("int4_avg_accum", [{ args: [Array$1.of((default_1$3)), (default_1$4)], ret: Array$1.of((default_1$3)), isOperator: false }], args);
}
function int4AvgAccumInv(...args) {
    return sqlFunction("int4_avg_accum_inv", [{ args: [Array$1.of((default_1$3)), (default_1$4)], ret: Array$1.of((default_1$3)), isOperator: false }], args);
}
function int4AvgCombine(...args) {
    return sqlFunction("int4_avg_combine", [{ args: [Array$1.of((default_1$3)), Array$1.of((default_1$3))], ret: Array$1.of((default_1$3)), isOperator: false }], args);
}
function int4MulCash(...args) {
    return sqlFunction("int4_mul_cash", [{ args: [(default_1$4), (money$1)], ret: (money$1), isOperator: false }], args);
}
function int4Sum(...args) {
    return sqlFunction("int4_sum", [{ args: [(default_1$3), (default_1$4)], ret: (default_1$3), isOperator: false }], args);
}
function int4Abs(...args) {
    return sqlFunction("int4abs", [{ args: [(default_1$4)], ret: (default_1$4), isOperator: false }], args);
}
function int4And(...args) {
    return sqlFunction("int4and", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: false }], args);
}
function int4Div(...args) {
    return sqlFunction("int4div", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: false }], args);
}
function int4Eq(...args) {
    return sqlFunction("int4eq", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$8), isOperator: false }], args);
}
function int4Ge(...args) {
    return sqlFunction("int4ge", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$8), isOperator: false }], args);
}
function int4Gt(...args) {
    return sqlFunction("int4gt", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$8), isOperator: false }], args);
}
function int4Inc(...args) {
    return sqlFunction("int4inc", [{ args: [(default_1$4)], ret: (default_1$4), isOperator: false }], args);
}
function int4Larger(...args) {
    return sqlFunction("int4larger", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: false }], args);
}
function int4Le(...args) {
    return sqlFunction("int4le", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$8), isOperator: false }], args);
}
function int4Lt(...args) {
    return sqlFunction("int4lt", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$8), isOperator: false }], args);
}
function int4Mi(...args) {
    return sqlFunction("int4mi", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: false }], args);
}
function int4Mod(...args) {
    return sqlFunction("int4mod", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: false }], args);
}
function int4Mul(...args) {
    return sqlFunction("int4mul", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: false }], args);
}
function int4Multirange(...args) {
    return sqlFunction("int4multirange", [{ args: [], ret: (int4multirange), isOperator: false }, { args: [Array$1.of((int4range))], ret: (int4multirange), isOperator: false }, { args: [(int4range)], ret: (int4multirange), isOperator: false }], args);
}
function int4Ne(...args) {
    return sqlFunction("int4ne", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$8), isOperator: false }], args);
}
function int4Not(...args) {
    return sqlFunction("int4not", [{ args: [(default_1$4)], ret: (default_1$4), isOperator: false }], args);
}
function int4Or(...args) {
    return sqlFunction("int4or", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: false }], args);
}
function int4Pl(...args) {
    return sqlFunction("int4pl", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: false }], args);
}
function int4Range(...args) {
    return sqlFunction("int4range", [{ args: [(default_1$4), (default_1$4)], ret: (int4range), isOperator: false }, { args: [(default_1$4), (default_1$4), (default_1$1)], ret: (int4range), isOperator: false }], args);
}
function int4RangeCanonical(...args) {
    return sqlFunction("int4range_canonical", [{ args: [(int4range)], ret: (int4range), isOperator: false }], args);
}
function int4RangeSubdiff(...args) {
    return sqlFunction("int4range_subdiff", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$6), isOperator: false }], args);
}
function int4Shl(...args) {
    return sqlFunction("int4shl", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: false }], args);
}
function int4Shr(...args) {
    return sqlFunction("int4shr", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: false }], args);
}
function int4Smaller(...args) {
    return sqlFunction("int4smaller", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: false }], args);
}
function int4Um(...args) {
    return sqlFunction("int4um", [{ args: [(default_1$4)], ret: (default_1$4), isOperator: false }], args);
}
function int4Up(...args) {
    return sqlFunction("int4up", [{ args: [(default_1$4)], ret: (default_1$4), isOperator: false }], args);
}
function int4Xor(...args) {
    return sqlFunction("int4xor", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: false }], args);
}
function int8(...args) {
    return sqlFunction("int8", [{ args: [(bit$1)], ret: (default_1$3), isOperator: false }, { args: [(default_1$7)], ret: (default_1$3), isOperator: false }, { args: [(default_1$6)], ret: (default_1$3), isOperator: false }, { args: [(default_1$5)], ret: (default_1$3), isOperator: false }, { args: [(default_1$4)], ret: (default_1$3), isOperator: false }, { args: [(jsonb)], ret: (default_1$3), isOperator: false }, { args: [(default_1$2)], ret: (default_1$3), isOperator: false }, { args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function int82Div(...args) {
    return sqlFunction("int82div", [{ args: [(default_1$3), (default_1$5)], ret: (default_1$3), isOperator: false }], args);
}
function int82Eq(...args) {
    return sqlFunction("int82eq", [{ args: [(default_1$3), (default_1$5)], ret: (default_1$8), isOperator: false }], args);
}
function int82Ge(...args) {
    return sqlFunction("int82ge", [{ args: [(default_1$3), (default_1$5)], ret: (default_1$8), isOperator: false }], args);
}
function int82Gt(...args) {
    return sqlFunction("int82gt", [{ args: [(default_1$3), (default_1$5)], ret: (default_1$8), isOperator: false }], args);
}
function int82Le(...args) {
    return sqlFunction("int82le", [{ args: [(default_1$3), (default_1$5)], ret: (default_1$8), isOperator: false }], args);
}
function int82Lt(...args) {
    return sqlFunction("int82lt", [{ args: [(default_1$3), (default_1$5)], ret: (default_1$8), isOperator: false }], args);
}
function int82Mi(...args) {
    return sqlFunction("int82mi", [{ args: [(default_1$3), (default_1$5)], ret: (default_1$3), isOperator: false }], args);
}
function int82Mul(...args) {
    return sqlFunction("int82mul", [{ args: [(default_1$3), (default_1$5)], ret: (default_1$3), isOperator: false }], args);
}
function int82Ne(...args) {
    return sqlFunction("int82ne", [{ args: [(default_1$3), (default_1$5)], ret: (default_1$8), isOperator: false }], args);
}
function int82Pl(...args) {
    return sqlFunction("int82pl", [{ args: [(default_1$3), (default_1$5)], ret: (default_1$3), isOperator: false }], args);
}
function int84Div(...args) {
    return sqlFunction("int84div", [{ args: [(default_1$3), (default_1$4)], ret: (default_1$3), isOperator: false }], args);
}
function int84Eq(...args) {
    return sqlFunction("int84eq", [{ args: [(default_1$3), (default_1$4)], ret: (default_1$8), isOperator: false }], args);
}
function int84Ge(...args) {
    return sqlFunction("int84ge", [{ args: [(default_1$3), (default_1$4)], ret: (default_1$8), isOperator: false }], args);
}
function int84Gt(...args) {
    return sqlFunction("int84gt", [{ args: [(default_1$3), (default_1$4)], ret: (default_1$8), isOperator: false }], args);
}
function int84Le(...args) {
    return sqlFunction("int84le", [{ args: [(default_1$3), (default_1$4)], ret: (default_1$8), isOperator: false }], args);
}
function int84Lt(...args) {
    return sqlFunction("int84lt", [{ args: [(default_1$3), (default_1$4)], ret: (default_1$8), isOperator: false }], args);
}
function int84Mi(...args) {
    return sqlFunction("int84mi", [{ args: [(default_1$3), (default_1$4)], ret: (default_1$3), isOperator: false }], args);
}
function int84Mul(...args) {
    return sqlFunction("int84mul", [{ args: [(default_1$3), (default_1$4)], ret: (default_1$3), isOperator: false }], args);
}
function int84Ne(...args) {
    return sqlFunction("int84ne", [{ args: [(default_1$3), (default_1$4)], ret: (default_1$8), isOperator: false }], args);
}
function int84Pl(...args) {
    return sqlFunction("int84pl", [{ args: [(default_1$3), (default_1$4)], ret: (default_1$3), isOperator: false }], args);
}
function int8Avg(...args) {
    return sqlFunction("int8_avg", [{ args: [Array$1.of((default_1$3))], ret: (default_1$2), isOperator: false }], args);
}
function int8MulCash(...args) {
    return sqlFunction("int8_mul_cash", [{ args: [(default_1$3), (money$1)], ret: (money$1), isOperator: false }], args);
}
function int8Sum(...args) {
    return sqlFunction("int8_sum", [{ args: [(default_1$2), (default_1$3)], ret: (default_1$2), isOperator: false }], args);
}
function int8Abs(...args) {
    return sqlFunction("int8abs", [{ args: [(default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function int8And(...args) {
    return sqlFunction("int8and", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function int8Dec(...args) {
    return sqlFunction("int8dec", [{ args: [(default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function int8DecAny(...args) {
    return sqlFunction("int8dec_any", [{ args: [(default_1$3), (Any)], ret: (default_1$3), isOperator: false }], args);
}
function int8Div(...args) {
    return sqlFunction("int8div", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function int8Eq(...args) {
    return sqlFunction("int8eq", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$8), isOperator: false }], args);
}
function int8Ge(...args) {
    return sqlFunction("int8ge", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$8), isOperator: false }], args);
}
function int8Gt(...args) {
    return sqlFunction("int8gt", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$8), isOperator: false }], args);
}
function int8Inc(...args) {
    return sqlFunction("int8inc", [{ args: [(default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function int8IncAny(...args) {
    return sqlFunction("int8inc_any", [{ args: [(default_1$3), (Any)], ret: (default_1$3), isOperator: false }], args);
}
function int8IncFloat8Float8(...args) {
    return sqlFunction("int8inc_float8_float8", [{ args: [(default_1$3), (default_1$6), (default_1$6)], ret: (default_1$3), isOperator: false }], args);
}
function int8Larger(...args) {
    return sqlFunction("int8larger", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function int8Le(...args) {
    return sqlFunction("int8le", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$8), isOperator: false }], args);
}
function int8Lt(...args) {
    return sqlFunction("int8lt", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$8), isOperator: false }], args);
}
function int8Mi(...args) {
    return sqlFunction("int8mi", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function int8Mod(...args) {
    return sqlFunction("int8mod", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function int8Mul(...args) {
    return sqlFunction("int8mul", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function int8Multirange(...args) {
    return sqlFunction("int8multirange", [{ args: [], ret: (int8multirange), isOperator: false }, { args: [Array$1.of((int8range))], ret: (int8multirange), isOperator: false }, { args: [(int8range)], ret: (int8multirange), isOperator: false }], args);
}
function int8Ne(...args) {
    return sqlFunction("int8ne", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$8), isOperator: false }], args);
}
function int8Not(...args) {
    return sqlFunction("int8not", [{ args: [(default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function int8Or(...args) {
    return sqlFunction("int8or", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function int8Pl(...args) {
    return sqlFunction("int8pl", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function int8PlInet(...args) {
    return sqlFunction("int8pl_inet", [{ args: [(default_1$3), (inet)], ret: (inet), isOperator: false }], args);
}
function int8Range(...args) {
    return sqlFunction("int8range", [{ args: [(default_1$3), (default_1$3)], ret: (int8range), isOperator: false }, { args: [(default_1$3), (default_1$3), (default_1$1)], ret: (int8range), isOperator: false }], args);
}
function int8RangeCanonical(...args) {
    return sqlFunction("int8range_canonical", [{ args: [(int8range)], ret: (int8range), isOperator: false }], args);
}
function int8RangeSubdiff(...args) {
    return sqlFunction("int8range_subdiff", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$6), isOperator: false }], args);
}
function int8Shl(...args) {
    return sqlFunction("int8shl", [{ args: [(default_1$3), (default_1$4)], ret: (default_1$3), isOperator: false }], args);
}
function int8Shr(...args) {
    return sqlFunction("int8shr", [{ args: [(default_1$3), (default_1$4)], ret: (default_1$3), isOperator: false }], args);
}
function int8Smaller(...args) {
    return sqlFunction("int8smaller", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function int8Um(...args) {
    return sqlFunction("int8um", [{ args: [(default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function int8Up(...args) {
    return sqlFunction("int8up", [{ args: [(default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function int8Xor(...args) {
    return sqlFunction("int8xor", [{ args: [(default_1$3), (default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function integerPlDate(...args) {
    return sqlFunction("integer_pl_date", [{ args: [(default_1$4), (date$1)], ret: (date$1), isOperator: false }], args);
}
function interLb(...args) {
    return sqlFunction("inter_lb", [{ args: [(line$1), (box$1)], ret: (default_1$8), isOperator: false }], args);
}
function interSb(...args) {
    return sqlFunction("inter_sb", [{ args: [(lseg$1), (box$1)], ret: (default_1$8), isOperator: false }], args);
}
function interSl(...args) {
    return sqlFunction("inter_sl", [{ args: [(lseg$1), (line$1)], ret: (default_1$8), isOperator: false }], args);
}
function interval(...args) {
    return sqlFunction("interval", [{ args: [(interval$1), (default_1$4)], ret: (interval$1), isOperator: false }, { args: [(time$1)], ret: (interval$1), isOperator: false }], args);
}
function intervalCmp(...args) {
    return sqlFunction("interval_cmp", [{ args: [(interval$1), (interval$1)], ret: (default_1$4), isOperator: false }], args);
}
function intervalDiv(...args) {
    return sqlFunction("interval_div", [{ args: [(interval$1), (default_1$6)], ret: (interval$1), isOperator: false }], args);
}
function intervalEq(...args) {
    return sqlFunction("interval_eq", [{ args: [(interval$1), (interval$1)], ret: (default_1$8), isOperator: false }], args);
}
function intervalGe(...args) {
    return sqlFunction("interval_ge", [{ args: [(interval$1), (interval$1)], ret: (default_1$8), isOperator: false }], args);
}
function intervalGt(...args) {
    return sqlFunction("interval_gt", [{ args: [(interval$1), (interval$1)], ret: (default_1$8), isOperator: false }], args);
}
function intervalHash(...args) {
    return sqlFunction("interval_hash", [{ args: [(interval$1)], ret: (default_1$4), isOperator: false }], args);
}
function intervalHashExtended(...args) {
    return sqlFunction("interval_hash_extended", [{ args: [(interval$1), (default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function intervalLarger(...args) {
    return sqlFunction("interval_larger", [{ args: [(interval$1), (interval$1)], ret: (interval$1), isOperator: false }], args);
}
function intervalLe(...args) {
    return sqlFunction("interval_le", [{ args: [(interval$1), (interval$1)], ret: (default_1$8), isOperator: false }], args);
}
function intervalLt(...args) {
    return sqlFunction("interval_lt", [{ args: [(interval$1), (interval$1)], ret: (default_1$8), isOperator: false }], args);
}
function intervalMi(...args) {
    return sqlFunction("interval_mi", [{ args: [(interval$1), (interval$1)], ret: (interval$1), isOperator: false }], args);
}
function intervalMul(...args) {
    return sqlFunction("interval_mul", [{ args: [(interval$1), (default_1$6)], ret: (interval$1), isOperator: false }], args);
}
function intervalNe(...args) {
    return sqlFunction("interval_ne", [{ args: [(interval$1), (interval$1)], ret: (default_1$8), isOperator: false }], args);
}
function intervalPl(...args) {
    return sqlFunction("interval_pl", [{ args: [(interval$1), (interval$1)], ret: (interval$1), isOperator: false }], args);
}
function intervalPlDate(...args) {
    return sqlFunction("interval_pl_date", [{ args: [(interval$1), (date$1)], ret: (timestamp$1), isOperator: false }], args);
}
function intervalPlTime(...args) {
    return sqlFunction("interval_pl_time", [{ args: [(interval$1), (time$1)], ret: (time$1), isOperator: false }], args);
}
function intervalPlTimestamp(...args) {
    return sqlFunction("interval_pl_timestamp", [{ args: [(interval$1), (timestamp$1)], ret: (timestamp$1), isOperator: false }], args);
}
function intervalPlTimestamptz(...args) {
    return sqlFunction("interval_pl_timestamptz", [{ args: [(interval$1), (timestamptz$1)], ret: (timestamptz$1), isOperator: false }], args);
}
function intervalPlTimetz(...args) {
    return sqlFunction("interval_pl_timetz", [{ args: [(interval$1), (timetz$1)], ret: (timetz$1), isOperator: false }], args);
}
function intervalSmaller(...args) {
    return sqlFunction("interval_smaller", [{ args: [(interval$1), (interval$1)], ret: (interval$1), isOperator: false }], args);
}
function intervalUm(...args) {
    return sqlFunction("interval_um", [{ args: [(interval$1)], ret: (interval$1), isOperator: false }], args);
}
function isNormalized(...args) {
    return sqlFunction("is_normalized", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function isclosed(...args) {
    return sqlFunction("isclosed", [{ args: [(path$1)], ret: (default_1$8), isOperator: false }], args);
}
function isempty(...args) {
    return sqlFunction("isempty", [{ args: [anymultirange], ret: (default_1$8), isOperator: false }, { args: [anyrange], ret: (default_1$8), isOperator: false }], args);
}
function isfinite(...args) {
    return sqlFunction("isfinite", [{ args: [(date$1)], ret: (default_1$8), isOperator: false }, { args: [(interval$1)], ret: (default_1$8), isOperator: false }, { args: [(timestamp$1)], ret: (default_1$8), isOperator: false }, { args: [(timestamptz$1)], ret: (default_1$8), isOperator: false }], args);
}
function ishorizontal(...args) {
    return sqlFunction("ishorizontal", [{ args: [(line$1)], ret: (default_1$8), isOperator: false }, { args: [(lseg$1)], ret: (default_1$8), isOperator: false }, { args: [(point$1), (point$1)], ret: (default_1$8), isOperator: false }], args);
}
function isopen(...args) {
    return sqlFunction("isopen", [{ args: [(path$1)], ret: (default_1$8), isOperator: false }], args);
}
function isparallel(...args) {
    return sqlFunction("isparallel", [{ args: [(line$1), (line$1)], ret: (default_1$8), isOperator: false }, { args: [(lseg$1), (lseg$1)], ret: (default_1$8), isOperator: false }], args);
}
function isperp(...args) {
    return sqlFunction("isperp", [{ args: [(line$1), (line$1)], ret: (default_1$8), isOperator: false }, { args: [(lseg$1), (lseg$1)], ret: (default_1$8), isOperator: false }], args);
}
function isvertical(...args) {
    return sqlFunction("isvertical", [{ args: [(line$1)], ret: (default_1$8), isOperator: false }, { args: [(lseg$1)], ret: (default_1$8), isOperator: false }, { args: [(point$1), (point$1)], ret: (default_1$8), isOperator: false }], args);
}
function jsonAgg(...args) {
    return sqlFunction("json_agg", [({ T }) => ({ args: [T], ret: (json), isOperator: false })], args);
}
function jsonAggStrict(...args) {
    return sqlFunction("json_agg_strict", [({ T }) => ({ args: [T], ret: (json), isOperator: false })], args);
}
function jsonArrayElement(...args) {
    return sqlFunction("json_array_element", [{ args: [(json), (default_1$4)], ret: (json), isOperator: false }], args);
}
function jsonArrayElementText(...args) {
    return sqlFunction("json_array_element_text", [{ args: [(json), (default_1$4)], ret: (default_1$1), isOperator: false }], args);
}
function jsonArrayElements(...args) {
    return sqlFunction("json_array_elements", [{ args: [(json)], ret: Setof.ofSchema({ value: (json) }), isOperator: false }], args);
}
function jsonArrayElementsText(...args) {
    return sqlFunction("json_array_elements_text", [{ args: [(json)], ret: Setof.ofSchema({ value: (default_1$1) }), isOperator: false }], args);
}
function jsonArrayLength(...args) {
    return sqlFunction("json_array_length", [{ args: [(json)], ret: (default_1$4), isOperator: false }], args);
}
function jsonBuildArray(...args) {
    return sqlFunction("json_build_array", [{ args: [], ret: (json), isOperator: false }, { args: [(Any)], ret: (json), isOperator: false }], args);
}
function jsonBuildObject(...args) {
    return sqlFunction("json_build_object", [{ args: [], ret: (json), isOperator: false }, { args: [(Any)], ret: (json), isOperator: false }], args);
}
function jsonEach(...args) {
    return sqlFunction("json_each", [{ args: [(json)], ret: Setof.ofSchema({ key: (default_1$1), value: (json) }), isOperator: false }], args);
}
function jsonEachText(...args) {
    return sqlFunction("json_each_text", [{ args: [(json)], ret: Setof.ofSchema({ key: (default_1$1), value: (default_1$1) }), isOperator: false }], args);
}
function jsonExtractPath(...args) {
    return sqlFunction("json_extract_path", [{ args: [(json), Array$1.of((default_1$1))], ret: (json), isOperator: false }], args);
}
function jsonExtractPathText(...args) {
    return sqlFunction("json_extract_path_text", [{ args: [(json), Array$1.of((default_1$1))], ret: (default_1$1), isOperator: false }], args);
}
function jsonObject(...args) {
    return sqlFunction("json_object", [{ args: [Array$1.of((default_1$1))], ret: (json), isOperator: false }, { args: [Array$1.of((default_1$1)), Array$1.of((default_1$1))], ret: (json), isOperator: false }], args);
}
function jsonObjectAgg(...args) {
    return sqlFunction("json_object_agg", [{ args: [(Any), (Any)], ret: (json), isOperator: false }], args);
}
function jsonObjectAggStrict(...args) {
    return sqlFunction("json_object_agg_strict", [{ args: [(Any), (Any)], ret: (json), isOperator: false }], args);
}
function jsonObjectAggUnique(...args) {
    return sqlFunction("json_object_agg_unique", [{ args: [(Any), (Any)], ret: (json), isOperator: false }], args);
}
function jsonObjectAggUniqueStrict(...args) {
    return sqlFunction("json_object_agg_unique_strict", [{ args: [(Any), (Any)], ret: (json), isOperator: false }], args);
}
function jsonObjectField(...args) {
    return sqlFunction("json_object_field", [{ args: [(json), (default_1$1)], ret: (json), isOperator: false }], args);
}
function jsonObjectFieldText(...args) {
    return sqlFunction("json_object_field_text", [{ args: [(json), (default_1$1)], ret: (default_1$1), isOperator: false }], args);
}
function jsonObjectKeys(...args) {
    return sqlFunction("json_object_keys", [{ args: [(json)], ret: Setof.ofSchema({}), isOperator: false }], args);
}
function jsonPopulateRecord(...args) {
    return sqlFunction("json_populate_record", [({ T }) => ({ args: [T, (json), (default_1$8)], ret: T, isOperator: false })], args);
}
function jsonPopulateRecordset(...args) {
    return sqlFunction("json_populate_recordset", [({ T }) => ({ args: [T, (json), (default_1$8)], ret: Setof.ofSchema({}), isOperator: false })], args);
}
function jsonStripNulls(...args) {
    return sqlFunction("json_strip_nulls", [{ args: [(json)], ret: (json), isOperator: false }], args);
}
function jsonToRecord(...args) {
    return sqlFunction("json_to_record", [({ R }) => ({ args: [(json)], ret: Record.of(R), isOperator: false })], args);
}
function jsonToRecordset(...args) {
    return sqlFunction("json_to_recordset", [{ args: [(json)], ret: Setof.ofSchema({}), isOperator: false }], args);
}
function jsonToTsvector(...args) {
    return sqlFunction("json_to_tsvector", [{ args: [(json), (jsonb)], ret: (tsvector), isOperator: false }, { args: [(regconfig), (json), (jsonb)], ret: (tsvector), isOperator: false }], args);
}
function jsonTypeof(...args) {
    return sqlFunction("json_typeof", [{ args: [(json)], ret: (default_1$1), isOperator: false }], args);
}
function jsonbAgg(...args) {
    return sqlFunction("jsonb_agg", [({ T }) => ({ args: [T], ret: (jsonb), isOperator: false })], args);
}
function jsonbAggStrict(...args) {
    return sqlFunction("jsonb_agg_strict", [({ T }) => ({ args: [T], ret: (jsonb), isOperator: false })], args);
}
function jsonbArrayElement(...args) {
    return sqlFunction("jsonb_array_element", [{ args: [(jsonb), (default_1$4)], ret: (jsonb), isOperator: false }], args);
}
function jsonbArrayElementText(...args) {
    return sqlFunction("jsonb_array_element_text", [{ args: [(jsonb), (default_1$4)], ret: (default_1$1), isOperator: false }], args);
}
function jsonbArrayElements(...args) {
    return sqlFunction("jsonb_array_elements", [{ args: [(jsonb)], ret: Setof.ofSchema({ value: (jsonb) }), isOperator: false }], args);
}
function jsonbArrayElementsText(...args) {
    return sqlFunction("jsonb_array_elements_text", [{ args: [(jsonb)], ret: Setof.ofSchema({ value: (default_1$1) }), isOperator: false }], args);
}
function jsonbArrayLength(...args) {
    return sqlFunction("jsonb_array_length", [{ args: [(jsonb)], ret: (default_1$4), isOperator: false }], args);
}
function jsonbBuildArray(...args) {
    return sqlFunction("jsonb_build_array", [{ args: [], ret: (jsonb), isOperator: false }, { args: [(Any)], ret: (jsonb), isOperator: false }], args);
}
function jsonbBuildObject(...args) {
    return sqlFunction("jsonb_build_object", [{ args: [], ret: (jsonb), isOperator: false }, { args: [(Any)], ret: (jsonb), isOperator: false }], args);
}
function jsonbCmp(...args) {
    return sqlFunction("jsonb_cmp", [{ args: [(jsonb), (jsonb)], ret: (default_1$4), isOperator: false }], args);
}
function jsonbConcat(...args) {
    return sqlFunction("jsonb_concat", [{ args: [(jsonb), (jsonb)], ret: (jsonb), isOperator: false }], args);
}
function jsonbContained(...args) {
    return sqlFunction("jsonb_contained", [{ args: [(jsonb), (jsonb)], ret: (default_1$8), isOperator: false }], args);
}
function jsonbContains(...args) {
    return sqlFunction("jsonb_contains", [{ args: [(jsonb), (jsonb)], ret: (default_1$8), isOperator: false }], args);
}
function jsonbDelete(...args) {
    return sqlFunction("jsonb_delete", [{ args: [(jsonb), Array$1.of((default_1$1))], ret: (jsonb), isOperator: false }, { args: [(jsonb), (default_1$4)], ret: (jsonb), isOperator: false }, { args: [(jsonb), (default_1$1)], ret: (jsonb), isOperator: false }], args);
}
function jsonbDeletePath(...args) {
    return sqlFunction("jsonb_delete_path", [{ args: [(jsonb), Array$1.of((default_1$1))], ret: (jsonb), isOperator: false }], args);
}
function jsonbEach(...args) {
    return sqlFunction("jsonb_each", [{ args: [(jsonb)], ret: Setof.ofSchema({ key: (default_1$1), value: (jsonb) }), isOperator: false }], args);
}
function jsonbEachText(...args) {
    return sqlFunction("jsonb_each_text", [{ args: [(jsonb)], ret: Setof.ofSchema({ key: (default_1$1), value: (default_1$1) }), isOperator: false }], args);
}
function jsonbEq(...args) {
    return sqlFunction("jsonb_eq", [{ args: [(jsonb), (jsonb)], ret: (default_1$8), isOperator: false }], args);
}
function jsonbExists(...args) {
    return sqlFunction("jsonb_exists", [{ args: [(jsonb), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function jsonbExistsAll(...args) {
    return sqlFunction("jsonb_exists_all", [{ args: [(jsonb), Array$1.of((default_1$1))], ret: (default_1$8), isOperator: false }], args);
}
function jsonbExistsAny(...args) {
    return sqlFunction("jsonb_exists_any", [{ args: [(jsonb), Array$1.of((default_1$1))], ret: (default_1$8), isOperator: false }], args);
}
function jsonbExtractPath(...args) {
    return sqlFunction("jsonb_extract_path", [{ args: [(jsonb), Array$1.of((default_1$1))], ret: (jsonb), isOperator: false }], args);
}
function jsonbExtractPathText(...args) {
    return sqlFunction("jsonb_extract_path_text", [{ args: [(jsonb), Array$1.of((default_1$1))], ret: (default_1$1), isOperator: false }], args);
}
function jsonbGe(...args) {
    return sqlFunction("jsonb_ge", [{ args: [(jsonb), (jsonb)], ret: (default_1$8), isOperator: false }], args);
}
function jsonbGt(...args) {
    return sqlFunction("jsonb_gt", [{ args: [(jsonb), (jsonb)], ret: (default_1$8), isOperator: false }], args);
}
function jsonbHash(...args) {
    return sqlFunction("jsonb_hash", [{ args: [(jsonb)], ret: (default_1$4), isOperator: false }], args);
}
function jsonbHashExtended(...args) {
    return sqlFunction("jsonb_hash_extended", [{ args: [(jsonb), (default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function jsonbInsert(...args) {
    return sqlFunction("jsonb_insert", [{ args: [(jsonb), Array$1.of((default_1$1)), (jsonb), (default_1$8)], ret: (jsonb), isOperator: false }], args);
}
function jsonbLe(...args) {
    return sqlFunction("jsonb_le", [{ args: [(jsonb), (jsonb)], ret: (default_1$8), isOperator: false }], args);
}
function jsonbLt(...args) {
    return sqlFunction("jsonb_lt", [{ args: [(jsonb), (jsonb)], ret: (default_1$8), isOperator: false }], args);
}
function jsonbNe(...args) {
    return sqlFunction("jsonb_ne", [{ args: [(jsonb), (jsonb)], ret: (default_1$8), isOperator: false }], args);
}
function jsonbObject(...args) {
    return sqlFunction("jsonb_object", [{ args: [Array$1.of((default_1$1))], ret: (jsonb), isOperator: false }, { args: [Array$1.of((default_1$1)), Array$1.of((default_1$1))], ret: (jsonb), isOperator: false }], args);
}
function jsonbObjectAgg(...args) {
    return sqlFunction("jsonb_object_agg", [{ args: [(Any), (Any)], ret: (jsonb), isOperator: false }], args);
}
function jsonbObjectAggStrict(...args) {
    return sqlFunction("jsonb_object_agg_strict", [{ args: [(Any), (Any)], ret: (jsonb), isOperator: false }], args);
}
function jsonbObjectAggUnique(...args) {
    return sqlFunction("jsonb_object_agg_unique", [{ args: [(Any), (Any)], ret: (jsonb), isOperator: false }], args);
}
function jsonbObjectAggUniqueStrict(...args) {
    return sqlFunction("jsonb_object_agg_unique_strict", [{ args: [(Any), (Any)], ret: (jsonb), isOperator: false }], args);
}
function jsonbObjectField(...args) {
    return sqlFunction("jsonb_object_field", [{ args: [(jsonb), (default_1$1)], ret: (jsonb), isOperator: false }], args);
}
function jsonbObjectFieldText(...args) {
    return sqlFunction("jsonb_object_field_text", [{ args: [(jsonb), (default_1$1)], ret: (default_1$1), isOperator: false }], args);
}
function jsonbObjectKeys(...args) {
    return sqlFunction("jsonb_object_keys", [{ args: [(jsonb)], ret: Setof.ofSchema({}), isOperator: false }], args);
}
function jsonbPathExists(...args) {
    return sqlFunction("jsonb_path_exists", [{ args: [(jsonb), (jsonpath), (jsonb), (default_1$8)], ret: (default_1$8), isOperator: false }], args);
}
function jsonbPathExistsOpr(...args) {
    return sqlFunction("jsonb_path_exists_opr", [{ args: [(jsonb), (jsonpath)], ret: (default_1$8), isOperator: false }], args);
}
function jsonbPathExistsTz(...args) {
    return sqlFunction("jsonb_path_exists_tz", [{ args: [(jsonb), (jsonpath), (jsonb), (default_1$8)], ret: (default_1$8), isOperator: false }], args);
}
function jsonbPathMatch(...args) {
    return sqlFunction("jsonb_path_match", [{ args: [(jsonb), (jsonpath), (jsonb), (default_1$8)], ret: (default_1$8), isOperator: false }], args);
}
function jsonbPathMatchOpr(...args) {
    return sqlFunction("jsonb_path_match_opr", [{ args: [(jsonb), (jsonpath)], ret: (default_1$8), isOperator: false }], args);
}
function jsonbPathMatchTz(...args) {
    return sqlFunction("jsonb_path_match_tz", [{ args: [(jsonb), (jsonpath), (jsonb), (default_1$8)], ret: (default_1$8), isOperator: false }], args);
}
function jsonbPathQuery(...args) {
    return sqlFunction("jsonb_path_query", [{ args: [(jsonb), (jsonpath), (jsonb), (default_1$8)], ret: Setof.ofSchema({}), isOperator: false }], args);
}
function jsonbPathQueryArray(...args) {
    return sqlFunction("jsonb_path_query_array", [{ args: [(jsonb), (jsonpath), (jsonb), (default_1$8)], ret: (jsonb), isOperator: false }], args);
}
function jsonbPathQueryArrayTz(...args) {
    return sqlFunction("jsonb_path_query_array_tz", [{ args: [(jsonb), (jsonpath), (jsonb), (default_1$8)], ret: (jsonb), isOperator: false }], args);
}
function jsonbPathQueryFirst(...args) {
    return sqlFunction("jsonb_path_query_first", [{ args: [(jsonb), (jsonpath), (jsonb), (default_1$8)], ret: (jsonb), isOperator: false }], args);
}
function jsonbPathQueryFirstTz(...args) {
    return sqlFunction("jsonb_path_query_first_tz", [{ args: [(jsonb), (jsonpath), (jsonb), (default_1$8)], ret: (jsonb), isOperator: false }], args);
}
function jsonbPathQueryTz(...args) {
    return sqlFunction("jsonb_path_query_tz", [{ args: [(jsonb), (jsonpath), (jsonb), (default_1$8)], ret: Setof.ofSchema({}), isOperator: false }], args);
}
function jsonbPopulateRecord(...args) {
    return sqlFunction("jsonb_populate_record", [({ T }) => ({ args: [T, (jsonb)], ret: T, isOperator: false })], args);
}
function jsonbPopulateRecordValid(...args) {
    return sqlFunction("jsonb_populate_record_valid", [({ T }) => ({ args: [T, (jsonb)], ret: (default_1$8), isOperator: false })], args);
}
function jsonbPopulateRecordset(...args) {
    return sqlFunction("jsonb_populate_recordset", [({ T }) => ({ args: [T, (jsonb)], ret: Setof.ofSchema({}), isOperator: false })], args);
}
function jsonbPretty(...args) {
    return sqlFunction("jsonb_pretty", [{ args: [(jsonb)], ret: (default_1$1), isOperator: false }], args);
}
function jsonbSet(...args) {
    return sqlFunction("jsonb_set", [{ args: [(jsonb), Array$1.of((default_1$1)), (jsonb), (default_1$8)], ret: (jsonb), isOperator: false }], args);
}
function jsonbSetLax(...args) {
    return sqlFunction("jsonb_set_lax", [{ args: [(jsonb), Array$1.of((default_1$1)), (jsonb), (default_1$8), (default_1$1)], ret: (jsonb), isOperator: false }], args);
}
function jsonbStripNulls(...args) {
    return sqlFunction("jsonb_strip_nulls", [{ args: [(jsonb)], ret: (jsonb), isOperator: false }], args);
}
function jsonbToRecord(...args) {
    return sqlFunction("jsonb_to_record", [({ R }) => ({ args: [(jsonb)], ret: Record.of(R), isOperator: false })], args);
}
function jsonbToRecordset(...args) {
    return sqlFunction("jsonb_to_recordset", [{ args: [(jsonb)], ret: Setof.ofSchema({}), isOperator: false }], args);
}
function jsonbToTsvector(...args) {
    return sqlFunction("jsonb_to_tsvector", [{ args: [(jsonb), (jsonb)], ret: (tsvector), isOperator: false }, { args: [(regconfig), (jsonb), (jsonb)], ret: (tsvector), isOperator: false }], args);
}
function jsonbTypeof(...args) {
    return sqlFunction("jsonb_typeof", [{ args: [(jsonb)], ret: (default_1$1), isOperator: false }], args);
}
function justifyDays(...args) {
    return sqlFunction("justify_days", [{ args: [(interval$1)], ret: (interval$1), isOperator: false }], args);
}
function justifyHours(...args) {
    return sqlFunction("justify_hours", [{ args: [(interval$1)], ret: (interval$1), isOperator: false }], args);
}
function justifyInterval(...args) {
    return sqlFunction("justify_interval", [{ args: [(interval$1)], ret: (interval$1), isOperator: false }], args);
}
function lag(...args) {
    return sqlFunction("lag", [({ T }) => ({ args: [T, (default_1$4), T], ret: T, isOperator: false }), ({ T }) => ({ args: [T], ret: T, isOperator: false }), ({ T }) => ({ args: [T, (default_1$4)], ret: T, isOperator: false })], args);
}
function lastValue(...args) {
    return sqlFunction("last_value", [({ T }) => ({ args: [T], ret: T, isOperator: false })], args);
}
function lastval(...args) {
    return sqlFunction("lastval", [{ args: [], ret: (default_1$3), isOperator: false }], args);
}
function lcm(...args) {
    return sqlFunction("lcm", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: false }, { args: [(default_1$3), (default_1$3)], ret: (default_1$3), isOperator: false }, { args: [(default_1$2), (default_1$2)], ret: (default_1$2), isOperator: false }], args);
}
function lead(...args) {
    return sqlFunction("lead", [({ T }) => ({ args: [T, (default_1$4), T], ret: T, isOperator: false }), ({ T }) => ({ args: [T], ret: T, isOperator: false }), ({ T }) => ({ args: [T, (default_1$4)], ret: T, isOperator: false })], args);
}
function left(...args) {
    return sqlFunction("left", [{ args: [(default_1$1), (default_1$4)], ret: (default_1$1), isOperator: false }], args);
}
function length(...args) {
    return sqlFunction("length", [{ args: [(lseg$1)], ret: (default_1$6), isOperator: false }, { args: [(path$1)], ret: (default_1$6), isOperator: false }, { args: [(bit$1)], ret: (default_1$4), isOperator: false }, { args: [(bpchar$1)], ret: (default_1$4), isOperator: false }, { args: [(bytea)], ret: (default_1$4), isOperator: false }, { args: [(bytea), (name$1)], ret: (default_1$4), isOperator: false }, { args: [(default_1$1)], ret: (default_1$4), isOperator: false }, { args: [(tsvector)], ret: (default_1$4), isOperator: false }], args);
}
function like(...args) {
    return sqlFunction("like", [{ args: [(bytea), (bytea)], ret: (default_1$8), isOperator: false }, { args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function likeEscape(...args) {
    return sqlFunction("like_escape", [{ args: [(bytea), (bytea)], ret: (bytea), isOperator: false }, { args: [(default_1$1), (default_1$1)], ret: (default_1$1), isOperator: false }], args);
}
function line(...args) {
    return sqlFunction("line", [{ args: [(point$1), (point$1)], ret: (line$1), isOperator: false }], args);
}
function lineDistance(...args) {
    return sqlFunction("line_distance", [{ args: [(line$1), (line$1)], ret: (default_1$6), isOperator: false }], args);
}
function lineEq(...args) {
    return sqlFunction("line_eq", [{ args: [(line$1), (line$1)], ret: (default_1$8), isOperator: false }], args);
}
function lineHorizontal(...args) {
    return sqlFunction("line_horizontal", [{ args: [(line$1)], ret: (default_1$8), isOperator: false }], args);
}
function lineInterpt(...args) {
    return sqlFunction("line_interpt", [{ args: [(line$1), (line$1)], ret: (point$1), isOperator: false }], args);
}
function lineIntersect(...args) {
    return sqlFunction("line_intersect", [{ args: [(line$1), (line$1)], ret: (default_1$8), isOperator: false }], args);
}
function lineParallel(...args) {
    return sqlFunction("line_parallel", [{ args: [(line$1), (line$1)], ret: (default_1$8), isOperator: false }], args);
}
function linePerp(...args) {
    return sqlFunction("line_perp", [{ args: [(line$1), (line$1)], ret: (default_1$8), isOperator: false }], args);
}
function lineVertical(...args) {
    return sqlFunction("line_vertical", [{ args: [(line$1)], ret: (default_1$8), isOperator: false }], args);
}
function ln(...args) {
    return sqlFunction("ln", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }, { args: [(default_1$2)], ret: (default_1$2), isOperator: false }], args);
}
function loClose(...args) {
    return sqlFunction("lo_close", [{ args: [(default_1$4)], ret: (default_1$4), isOperator: false }], args);
}
function loCreat(...args) {
    return sqlFunction("lo_creat", [{ args: [(default_1$4)], ret: (oid$1), isOperator: false }], args);
}
function loCreate(...args) {
    return sqlFunction("lo_create", [{ args: [(oid$1)], ret: (oid$1), isOperator: false }], args);
}
function loExport(...args) {
    return sqlFunction("lo_export", [{ args: [(oid$1), (default_1$1)], ret: (default_1$4), isOperator: false }], args);
}
function loFromBytea(...args) {
    return sqlFunction("lo_from_bytea", [{ args: [(oid$1), (bytea)], ret: (oid$1), isOperator: false }], args);
}
function loGet(...args) {
    return sqlFunction("lo_get", [{ args: [(oid$1)], ret: (bytea), isOperator: false }, { args: [(oid$1), (default_1$3), (default_1$4)], ret: (bytea), isOperator: false }], args);
}
function loImport(...args) {
    return sqlFunction("lo_import", [{ args: [(default_1$1)], ret: (oid$1), isOperator: false }, { args: [(default_1$1), (oid$1)], ret: (oid$1), isOperator: false }], args);
}
function loLseek(...args) {
    return sqlFunction("lo_lseek", [{ args: [(default_1$4), (default_1$4), (default_1$4)], ret: (default_1$4), isOperator: false }], args);
}
function loLseek64(...args) {
    return sqlFunction("lo_lseek64", [{ args: [(default_1$4), (default_1$3), (default_1$4)], ret: (default_1$3), isOperator: false }], args);
}
function loOpen(...args) {
    return sqlFunction("lo_open", [{ args: [(oid$1), (default_1$4)], ret: (default_1$4), isOperator: false }], args);
}
function loPut(...args) {
    return sqlFunction("lo_put", [{ args: [(oid$1), (default_1$3), (bytea)], ret: (_void), isOperator: false }], args);
}
function loTell(...args) {
    return sqlFunction("lo_tell", [{ args: [(default_1$4)], ret: (default_1$4), isOperator: false }], args);
}
function loTell64(...args) {
    return sqlFunction("lo_tell64", [{ args: [(default_1$4)], ret: (default_1$3), isOperator: false }], args);
}
function loTruncate(...args) {
    return sqlFunction("lo_truncate", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: false }], args);
}
function loTruncate64(...args) {
    return sqlFunction("lo_truncate64", [{ args: [(default_1$4), (default_1$3)], ret: (default_1$4), isOperator: false }], args);
}
function loUnlink(...args) {
    return sqlFunction("lo_unlink", [{ args: [(oid$1)], ret: (default_1$4), isOperator: false }], args);
}
function log(...args) {
    return sqlFunction("log", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }, { args: [(default_1$2)], ret: (default_1$2), isOperator: false }, { args: [(default_1$2), (default_1$2)], ret: (default_1$2), isOperator: false }], args);
}
function log10(...args) {
    return sqlFunction("log10", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }, { args: [(default_1$2)], ret: (default_1$2), isOperator: false }], args);
}
function loread(...args) {
    return sqlFunction("loread", [{ args: [(default_1$4), (default_1$4)], ret: (bytea), isOperator: false }], args);
}
function lower(...args) {
    return sqlFunction("lower", [({ T }) => ({ args: [anymultirange], ret: T, isOperator: false }), ({ T }) => ({ args: [anyrange], ret: T, isOperator: false }), { args: [(default_1$1)], ret: (default_1$1), isOperator: false }], args);
}
function lowerInc(...args) {
    return sqlFunction("lower_inc", [{ args: [anymultirange], ret: (default_1$8), isOperator: false }, { args: [anyrange], ret: (default_1$8), isOperator: false }], args);
}
function lowerInf(...args) {
    return sqlFunction("lower_inf", [{ args: [anymultirange], ret: (default_1$8), isOperator: false }, { args: [anyrange], ret: (default_1$8), isOperator: false }], args);
}
function lowrite(...args) {
    return sqlFunction("lowrite", [{ args: [(default_1$4), (bytea)], ret: (default_1$4), isOperator: false }], args);
}
function lpad(...args) {
    return sqlFunction("lpad", [{ args: [(default_1$1), (default_1$4)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$4), (default_1$1)], ret: (default_1$1), isOperator: false }], args);
}
function lseg(...args) {
    return sqlFunction("lseg", [{ args: [(box$1)], ret: (lseg$1), isOperator: false }, { args: [(point$1), (point$1)], ret: (lseg$1), isOperator: false }], args);
}
function lsegCenter(...args) {
    return sqlFunction("lseg_center", [{ args: [(lseg$1)], ret: (point$1), isOperator: false }], args);
}
function lsegDistance(...args) {
    return sqlFunction("lseg_distance", [{ args: [(lseg$1), (lseg$1)], ret: (default_1$6), isOperator: false }], args);
}
function lsegEq(...args) {
    return sqlFunction("lseg_eq", [{ args: [(lseg$1), (lseg$1)], ret: (default_1$8), isOperator: false }], args);
}
function lsegGe(...args) {
    return sqlFunction("lseg_ge", [{ args: [(lseg$1), (lseg$1)], ret: (default_1$8), isOperator: false }], args);
}
function lsegGt(...args) {
    return sqlFunction("lseg_gt", [{ args: [(lseg$1), (lseg$1)], ret: (default_1$8), isOperator: false }], args);
}
function lsegHorizontal(...args) {
    return sqlFunction("lseg_horizontal", [{ args: [(lseg$1)], ret: (default_1$8), isOperator: false }], args);
}
function lsegInterpt(...args) {
    return sqlFunction("lseg_interpt", [{ args: [(lseg$1), (lseg$1)], ret: (point$1), isOperator: false }], args);
}
function lsegIntersect(...args) {
    return sqlFunction("lseg_intersect", [{ args: [(lseg$1), (lseg$1)], ret: (default_1$8), isOperator: false }], args);
}
function lsegLe(...args) {
    return sqlFunction("lseg_le", [{ args: [(lseg$1), (lseg$1)], ret: (default_1$8), isOperator: false }], args);
}
function lsegLength(...args) {
    return sqlFunction("lseg_length", [{ args: [(lseg$1)], ret: (default_1$6), isOperator: false }], args);
}
function lsegLt(...args) {
    return sqlFunction("lseg_lt", [{ args: [(lseg$1), (lseg$1)], ret: (default_1$8), isOperator: false }], args);
}
function lsegNe(...args) {
    return sqlFunction("lseg_ne", [{ args: [(lseg$1), (lseg$1)], ret: (default_1$8), isOperator: false }], args);
}
function lsegParallel(...args) {
    return sqlFunction("lseg_parallel", [{ args: [(lseg$1), (lseg$1)], ret: (default_1$8), isOperator: false }], args);
}
function lsegPerp(...args) {
    return sqlFunction("lseg_perp", [{ args: [(lseg$1), (lseg$1)], ret: (default_1$8), isOperator: false }], args);
}
function lsegVertical(...args) {
    return sqlFunction("lseg_vertical", [{ args: [(lseg$1)], ret: (default_1$8), isOperator: false }], args);
}
function ltrim(...args) {
    return sqlFunction("ltrim", [{ args: [(bytea), (bytea)], ret: (bytea), isOperator: false }, { args: [(default_1$1)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$1)], ret: (default_1$1), isOperator: false }], args);
}
function macaddr(...args) {
    return sqlFunction("macaddr", [{ args: [(macaddr8$1)], ret: (macaddr$1), isOperator: false }], args);
}
function macaddr8(...args) {
    return sqlFunction("macaddr8", [{ args: [(macaddr$1)], ret: (macaddr8$1), isOperator: false }], args);
}
function macaddr8And(...args) {
    return sqlFunction("macaddr8_and", [{ args: [(macaddr8$1), (macaddr8$1)], ret: (macaddr8$1), isOperator: false }], args);
}
function macaddr8Cmp(...args) {
    return sqlFunction("macaddr8_cmp", [{ args: [(macaddr8$1), (macaddr8$1)], ret: (default_1$4), isOperator: false }], args);
}
function macaddr8Eq(...args) {
    return sqlFunction("macaddr8_eq", [{ args: [(macaddr8$1), (macaddr8$1)], ret: (default_1$8), isOperator: false }], args);
}
function macaddr8Ge(...args) {
    return sqlFunction("macaddr8_ge", [{ args: [(macaddr8$1), (macaddr8$1)], ret: (default_1$8), isOperator: false }], args);
}
function macaddr8Gt(...args) {
    return sqlFunction("macaddr8_gt", [{ args: [(macaddr8$1), (macaddr8$1)], ret: (default_1$8), isOperator: false }], args);
}
function macaddr8Le(...args) {
    return sqlFunction("macaddr8_le", [{ args: [(macaddr8$1), (macaddr8$1)], ret: (default_1$8), isOperator: false }], args);
}
function macaddr8Lt(...args) {
    return sqlFunction("macaddr8_lt", [{ args: [(macaddr8$1), (macaddr8$1)], ret: (default_1$8), isOperator: false }], args);
}
function macaddr8Ne(...args) {
    return sqlFunction("macaddr8_ne", [{ args: [(macaddr8$1), (macaddr8$1)], ret: (default_1$8), isOperator: false }], args);
}
function macaddr8Not(...args) {
    return sqlFunction("macaddr8_not", [{ args: [(macaddr8$1)], ret: (macaddr8$1), isOperator: false }], args);
}
function macaddr8Or(...args) {
    return sqlFunction("macaddr8_or", [{ args: [(macaddr8$1), (macaddr8$1)], ret: (macaddr8$1), isOperator: false }], args);
}
function macaddr8Set7Bit(...args) {
    return sqlFunction("macaddr8_set7bit", [{ args: [(macaddr8$1)], ret: (macaddr8$1), isOperator: false }], args);
}
function macaddrAnd(...args) {
    return sqlFunction("macaddr_and", [{ args: [(macaddr$1), (macaddr$1)], ret: (macaddr$1), isOperator: false }], args);
}
function macaddrCmp(...args) {
    return sqlFunction("macaddr_cmp", [{ args: [(macaddr$1), (macaddr$1)], ret: (default_1$4), isOperator: false }], args);
}
function macaddrEq(...args) {
    return sqlFunction("macaddr_eq", [{ args: [(macaddr$1), (macaddr$1)], ret: (default_1$8), isOperator: false }], args);
}
function macaddrGe(...args) {
    return sqlFunction("macaddr_ge", [{ args: [(macaddr$1), (macaddr$1)], ret: (default_1$8), isOperator: false }], args);
}
function macaddrGt(...args) {
    return sqlFunction("macaddr_gt", [{ args: [(macaddr$1), (macaddr$1)], ret: (default_1$8), isOperator: false }], args);
}
function macaddrLe(...args) {
    return sqlFunction("macaddr_le", [{ args: [(macaddr$1), (macaddr$1)], ret: (default_1$8), isOperator: false }], args);
}
function macaddrLt(...args) {
    return sqlFunction("macaddr_lt", [{ args: [(macaddr$1), (macaddr$1)], ret: (default_1$8), isOperator: false }], args);
}
function macaddrNe(...args) {
    return sqlFunction("macaddr_ne", [{ args: [(macaddr$1), (macaddr$1)], ret: (default_1$8), isOperator: false }], args);
}
function macaddrNot(...args) {
    return sqlFunction("macaddr_not", [{ args: [(macaddr$1)], ret: (macaddr$1), isOperator: false }], args);
}
function macaddrOr(...args) {
    return sqlFunction("macaddr_or", [{ args: [(macaddr$1), (macaddr$1)], ret: (macaddr$1), isOperator: false }], args);
}
function makeDate(...args) {
    return sqlFunction("make_date", [{ args: [(default_1$4), (default_1$4), (default_1$4)], ret: (date$1), isOperator: false }], args);
}
function makeInterval(...args) {
    return sqlFunction("make_interval", [{ args: [(default_1$4), (default_1$4), (default_1$4), (default_1$4), (default_1$4), (default_1$4), (default_1$6)], ret: (interval$1), isOperator: false }], args);
}
function makeTime(...args) {
    return sqlFunction("make_time", [{ args: [(default_1$4), (default_1$4), (default_1$6)], ret: (time$1), isOperator: false }], args);
}
function makeTimestamp(...args) {
    return sqlFunction("make_timestamp", [{ args: [(default_1$4), (default_1$4), (default_1$4), (default_1$4), (default_1$4), (default_1$6)], ret: (timestamp$1), isOperator: false }], args);
}
function makeTimestamptz(...args) {
    return sqlFunction("make_timestamptz", [{ args: [(default_1$4), (default_1$4), (default_1$4), (default_1$4), (default_1$4), (default_1$6)], ret: (timestamptz$1), isOperator: false }, { args: [(default_1$4), (default_1$4), (default_1$4), (default_1$4), (default_1$4), (default_1$6), (default_1$1)], ret: (timestamptz$1), isOperator: false }], args);
}
function makeaclitem(...args) {
    return sqlFunction("makeaclitem", [{ args: [(oid$1), (oid$1), (default_1$1), (default_1$8)], ret: (aclitem), isOperator: false }], args);
}
function masklen(...args) {
    return sqlFunction("masklen", [{ args: [(inet)], ret: (default_1$4), isOperator: false }], args);
}
function max(...args) {
    return sqlFunction("max", [({ T }) => ({ args: [Array$1.of(T)], ret: Array$1.of(T), isOperator: false }), ({ T }) => ({ args: [T], ret: T, isOperator: false }), { args: [(bpchar$1)], ret: (bpchar$1), isOperator: false }, { args: [(date$1)], ret: (date$1), isOperator: false }, { args: [(default_1$7)], ret: (default_1$7), isOperator: false }, { args: [(default_1$6)], ret: (default_1$6), isOperator: false }, { args: [(inet)], ret: (inet), isOperator: false }, { args: [(default_1$5)], ret: (default_1$5), isOperator: false }, { args: [(default_1$4)], ret: (default_1$4), isOperator: false }, { args: [(default_1$3)], ret: (default_1$3), isOperator: false }, { args: [(interval$1)], ret: (interval$1), isOperator: false }, { args: [(money$1)], ret: (money$1), isOperator: false }, { args: [(default_1$2)], ret: (default_1$2), isOperator: false }, { args: [(oid$1)], ret: (oid$1), isOperator: false }, { args: [(pg_lsn)], ret: (pg_lsn), isOperator: false }, { args: [(default_1$1)], ret: (default_1$1), isOperator: false }, { args: [(tid)], ret: (tid), isOperator: false }, { args: [(time$1)], ret: (time$1), isOperator: false }, { args: [(timestamp$1)], ret: (timestamp$1), isOperator: false }, { args: [(timestamptz$1)], ret: (timestamptz$1), isOperator: false }, { args: [(timetz$1)], ret: (timetz$1), isOperator: false }, { args: [(xid8)], ret: (xid8), isOperator: false }], args);
}
function md5(...args) {
    return sqlFunction("md5", [{ args: [(bytea)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1)], ret: (default_1$1), isOperator: false }], args);
}
function minScale(...args) {
    return sqlFunction("min_scale", [{ args: [(default_1$2)], ret: (default_1$4), isOperator: false }], args);
}
function mod(...args) {
    return sqlFunction("mod", [{ args: [(default_1$5), (default_1$5)], ret: (default_1$5), isOperator: false }, { args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: false }, { args: [(default_1$3), (default_1$3)], ret: (default_1$3), isOperator: false }, { args: [(default_1$2), (default_1$2)], ret: (default_1$2), isOperator: false }], args);
}
function mode(...args) {
    return sqlFunction("mode", [({ T }) => ({ args: [T], ret: T, isOperator: false })], args);
}
function money(...args) {
    return sqlFunction("money", [{ args: [(default_1$4)], ret: (money$1), isOperator: false }, { args: [(default_1$3)], ret: (money$1), isOperator: false }, { args: [(default_1$2)], ret: (money$1), isOperator: false }], args);
}
function mulDInterval(...args) {
    return sqlFunction("mul_d_interval", [{ args: [(default_1$6), (interval$1)], ret: (interval$1), isOperator: false }], args);
}
function multirange(...args) {
    return sqlFunction("multirange", [{ args: [anyrange], ret: anymultirange, isOperator: false }], args);
}
function multirangeAdjacentMultirange(...args) {
    return sqlFunction("multirange_adjacent_multirange", [{ args: [anymultirange, anymultirange], ret: (default_1$8), isOperator: false }], args);
}
function multirangeAdjacentRange(...args) {
    return sqlFunction("multirange_adjacent_range", [{ args: [anymultirange, anyrange], ret: (default_1$8), isOperator: false }], args);
}
function multirangeAfterMultirange(...args) {
    return sqlFunction("multirange_after_multirange", [{ args: [anymultirange, anymultirange], ret: (default_1$8), isOperator: false }], args);
}
function multirangeAfterRange(...args) {
    return sqlFunction("multirange_after_range", [{ args: [anymultirange, anyrange], ret: (default_1$8), isOperator: false }], args);
}
function multirangeBeforeMultirange(...args) {
    return sqlFunction("multirange_before_multirange", [{ args: [anymultirange, anymultirange], ret: (default_1$8), isOperator: false }], args);
}
function multirangeBeforeRange(...args) {
    return sqlFunction("multirange_before_range", [{ args: [anymultirange, anyrange], ret: (default_1$8), isOperator: false }], args);
}
function multirangeCmp(...args) {
    return sqlFunction("multirange_cmp", [{ args: [anymultirange, anymultirange], ret: (default_1$4), isOperator: false }], args);
}
function multirangeContainedByMultirange(...args) {
    return sqlFunction("multirange_contained_by_multirange", [{ args: [anymultirange, anymultirange], ret: (default_1$8), isOperator: false }], args);
}
function multirangeContainedByRange(...args) {
    return sqlFunction("multirange_contained_by_range", [{ args: [anymultirange, anyrange], ret: (default_1$8), isOperator: false }], args);
}
function multirangeContainsElem(...args) {
    return sqlFunction("multirange_contains_elem", [({ T }) => ({ args: [anymultirange, T], ret: (default_1$8), isOperator: false })], args);
}
function multirangeContainsMultirange(...args) {
    return sqlFunction("multirange_contains_multirange", [{ args: [anymultirange, anymultirange], ret: (default_1$8), isOperator: false }], args);
}
function multirangeContainsRange(...args) {
    return sqlFunction("multirange_contains_range", [{ args: [anymultirange, anyrange], ret: (default_1$8), isOperator: false }], args);
}
function multirangeEq(...args) {
    return sqlFunction("multirange_eq", [{ args: [anymultirange, anymultirange], ret: (default_1$8), isOperator: false }], args);
}
function multirangeGe(...args) {
    return sqlFunction("multirange_ge", [{ args: [anymultirange, anymultirange], ret: (default_1$8), isOperator: false }], args);
}
function multirangeGt(...args) {
    return sqlFunction("multirange_gt", [{ args: [anymultirange, anymultirange], ret: (default_1$8), isOperator: false }], args);
}
function multirangeIntersect(...args) {
    return sqlFunction("multirange_intersect", [{ args: [anymultirange, anymultirange], ret: anymultirange, isOperator: false }], args);
}
function multirangeIntersectAggTransfn(...args) {
    return sqlFunction("multirange_intersect_agg_transfn", [{ args: [anymultirange, anymultirange], ret: anymultirange, isOperator: false }], args);
}
function multirangeLe(...args) {
    return sqlFunction("multirange_le", [{ args: [anymultirange, anymultirange], ret: (default_1$8), isOperator: false }], args);
}
function multirangeLt(...args) {
    return sqlFunction("multirange_lt", [{ args: [anymultirange, anymultirange], ret: (default_1$8), isOperator: false }], args);
}
function multirangeMinus(...args) {
    return sqlFunction("multirange_minus", [{ args: [anymultirange, anymultirange], ret: anymultirange, isOperator: false }], args);
}
function multirangeNe(...args) {
    return sqlFunction("multirange_ne", [{ args: [anymultirange, anymultirange], ret: (default_1$8), isOperator: false }], args);
}
function multirangeOverlapsMultirange(...args) {
    return sqlFunction("multirange_overlaps_multirange", [{ args: [anymultirange, anymultirange], ret: (default_1$8), isOperator: false }], args);
}
function multirangeOverlapsRange(...args) {
    return sqlFunction("multirange_overlaps_range", [{ args: [anymultirange, anyrange], ret: (default_1$8), isOperator: false }], args);
}
function multirangeOverleftMultirange(...args) {
    return sqlFunction("multirange_overleft_multirange", [{ args: [anymultirange, anymultirange], ret: (default_1$8), isOperator: false }], args);
}
function multirangeOverleftRange(...args) {
    return sqlFunction("multirange_overleft_range", [{ args: [anymultirange, anyrange], ret: (default_1$8), isOperator: false }], args);
}
function multirangeOverrightMultirange(...args) {
    return sqlFunction("multirange_overright_multirange", [{ args: [anymultirange, anymultirange], ret: (default_1$8), isOperator: false }], args);
}
function multirangeOverrightRange(...args) {
    return sqlFunction("multirange_overright_range", [{ args: [anymultirange, anyrange], ret: (default_1$8), isOperator: false }], args);
}
function multirangeUnion(...args) {
    return sqlFunction("multirange_union", [{ args: [anymultirange, anymultirange], ret: anymultirange, isOperator: false }], args);
}
function mxidAge(...args) {
    return sqlFunction("mxid_age", [{ args: [(xid$1)], ret: (default_1$4), isOperator: false }], args);
}
function name(...args) {
    return sqlFunction("name", [{ args: [(bpchar$1)], ret: (name$1), isOperator: false }, { args: [(default_1$1)], ret: (name$1), isOperator: false }, { args: [(varchar$1)], ret: (name$1), isOperator: false }], args);
}
function nameconcatoid(...args) {
    return sqlFunction("nameconcatoid", [{ args: [(name$1), (oid$1)], ret: (name$1), isOperator: false }], args);
}
function nameeq(...args) {
    return sqlFunction("nameeq", [{ args: [(name$1), (name$1)], ret: (default_1$8), isOperator: false }], args);
}
function nameeqtext(...args) {
    return sqlFunction("nameeqtext", [{ args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function namege(...args) {
    return sqlFunction("namege", [{ args: [(name$1), (name$1)], ret: (default_1$8), isOperator: false }], args);
}
function namegetext(...args) {
    return sqlFunction("namegetext", [{ args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function namegt(...args) {
    return sqlFunction("namegt", [{ args: [(name$1), (name$1)], ret: (default_1$8), isOperator: false }], args);
}
function namegttext(...args) {
    return sqlFunction("namegttext", [{ args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function nameiclike(...args) {
    return sqlFunction("nameiclike", [{ args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function nameicnlike(...args) {
    return sqlFunction("nameicnlike", [{ args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function nameicregexeq(...args) {
    return sqlFunction("nameicregexeq", [{ args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function nameicregexne(...args) {
    return sqlFunction("nameicregexne", [{ args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function namele(...args) {
    return sqlFunction("namele", [{ args: [(name$1), (name$1)], ret: (default_1$8), isOperator: false }], args);
}
function nameletext(...args) {
    return sqlFunction("nameletext", [{ args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function namelike(...args) {
    return sqlFunction("namelike", [{ args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function namelt(...args) {
    return sqlFunction("namelt", [{ args: [(name$1), (name$1)], ret: (default_1$8), isOperator: false }], args);
}
function namelttext(...args) {
    return sqlFunction("namelttext", [{ args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function namene(...args) {
    return sqlFunction("namene", [{ args: [(name$1), (name$1)], ret: (default_1$8), isOperator: false }], args);
}
function namenetext(...args) {
    return sqlFunction("namenetext", [{ args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function namenlike(...args) {
    return sqlFunction("namenlike", [{ args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function nameregexeq(...args) {
    return sqlFunction("nameregexeq", [{ args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function nameregexne(...args) {
    return sqlFunction("nameregexne", [{ args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function netmask(...args) {
    return sqlFunction("netmask", [{ args: [(inet)], ret: (inet), isOperator: false }], args);
}
function network(...args) {
    return sqlFunction("network", [{ args: [(inet)], ret: (cidr$1), isOperator: false }], args);
}
function networkCmp(...args) {
    return sqlFunction("network_cmp", [{ args: [(inet), (inet)], ret: (default_1$4), isOperator: false }], args);
}
function networkEq(...args) {
    return sqlFunction("network_eq", [{ args: [(inet), (inet)], ret: (default_1$8), isOperator: false }], args);
}
function networkGe(...args) {
    return sqlFunction("network_ge", [{ args: [(inet), (inet)], ret: (default_1$8), isOperator: false }], args);
}
function networkGt(...args) {
    return sqlFunction("network_gt", [{ args: [(inet), (inet)], ret: (default_1$8), isOperator: false }], args);
}
function networkLarger(...args) {
    return sqlFunction("network_larger", [{ args: [(inet), (inet)], ret: (inet), isOperator: false }], args);
}
function networkLe(...args) {
    return sqlFunction("network_le", [{ args: [(inet), (inet)], ret: (default_1$8), isOperator: false }], args);
}
function networkLt(...args) {
    return sqlFunction("network_lt", [{ args: [(inet), (inet)], ret: (default_1$8), isOperator: false }], args);
}
function networkNe(...args) {
    return sqlFunction("network_ne", [{ args: [(inet), (inet)], ret: (default_1$8), isOperator: false }], args);
}
function networkOverlap(...args) {
    return sqlFunction("network_overlap", [{ args: [(inet), (inet)], ret: (default_1$8), isOperator: false }], args);
}
function networkSmaller(...args) {
    return sqlFunction("network_smaller", [{ args: [(inet), (inet)], ret: (inet), isOperator: false }], args);
}
function networkSub(...args) {
    return sqlFunction("network_sub", [{ args: [(inet), (inet)], ret: (default_1$8), isOperator: false }], args);
}
function networkSubeq(...args) {
    return sqlFunction("network_subeq", [{ args: [(inet), (inet)], ret: (default_1$8), isOperator: false }], args);
}
function networkSup(...args) {
    return sqlFunction("network_sup", [{ args: [(inet), (inet)], ret: (default_1$8), isOperator: false }], args);
}
function networkSupeq(...args) {
    return sqlFunction("network_supeq", [{ args: [(inet), (inet)], ret: (default_1$8), isOperator: false }], args);
}
function nextval(...args) {
    return sqlFunction("nextval", [{ args: [(regclass$1)], ret: (default_1$3), isOperator: false }], args);
}
function normalize(...args) {
    return sqlFunction("normalize", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$1), isOperator: false }], args);
}
function notlike(...args) {
    return sqlFunction("notlike", [{ args: [(bytea), (bytea)], ret: (default_1$8), isOperator: false }, { args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function now(...args) {
    return sqlFunction("now", [{ args: [], ret: (timestamptz$1), isOperator: false }], args);
}
function npoints(...args) {
    return sqlFunction("npoints", [{ args: [(path$1)], ret: (default_1$4), isOperator: false }, { args: [(polygon$1)], ret: (default_1$4), isOperator: false }], args);
}
function nthValue(...args) {
    return sqlFunction("nth_value", [({ T }) => ({ args: [T, (default_1$4)], ret: T, isOperator: false })], args);
}
function ntile(...args) {
    return sqlFunction("ntile", [{ args: [(default_1$4)], ret: (default_1$4), isOperator: false }], args);
}
function numNonnulls(...args) {
    return sqlFunction("num_nonnulls", [{ args: [(Any)], ret: (default_1$4), isOperator: false }], args);
}
function numNulls(...args) {
    return sqlFunction("num_nulls", [{ args: [(Any)], ret: (default_1$4), isOperator: false }], args);
}
function numeric(...args) {
    return sqlFunction("numeric", [{ args: [(default_1$7)], ret: (default_1$2), isOperator: false }, { args: [(default_1$6)], ret: (default_1$2), isOperator: false }, { args: [(default_1$5)], ret: (default_1$2), isOperator: false }, { args: [(default_1$4)], ret: (default_1$2), isOperator: false }, { args: [(default_1$3)], ret: (default_1$2), isOperator: false }, { args: [(jsonb)], ret: (default_1$2), isOperator: false }, { args: [(money$1)], ret: (default_1$2), isOperator: false }, { args: [(default_1$2), (default_1$4)], ret: (default_1$2), isOperator: false }], args);
}
function numericAbs(...args) {
    return sqlFunction("numeric_abs", [{ args: [(default_1$2)], ret: (default_1$2), isOperator: false }], args);
}
function numericAdd(...args) {
    return sqlFunction("numeric_add", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$2), isOperator: false }], args);
}
function numericCmp(...args) {
    return sqlFunction("numeric_cmp", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$4), isOperator: false }], args);
}
function numericDiv(...args) {
    return sqlFunction("numeric_div", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$2), isOperator: false }], args);
}
function numericDivTrunc(...args) {
    return sqlFunction("numeric_div_trunc", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$2), isOperator: false }], args);
}
function numericEq(...args) {
    return sqlFunction("numeric_eq", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$8), isOperator: false }], args);
}
function numericExp(...args) {
    return sqlFunction("numeric_exp", [{ args: [(default_1$2)], ret: (default_1$2), isOperator: false }], args);
}
function numericGe(...args) {
    return sqlFunction("numeric_ge", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$8), isOperator: false }], args);
}
function numericGt(...args) {
    return sqlFunction("numeric_gt", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$8), isOperator: false }], args);
}
function numericInc(...args) {
    return sqlFunction("numeric_inc", [{ args: [(default_1$2)], ret: (default_1$2), isOperator: false }], args);
}
function numericLarger(...args) {
    return sqlFunction("numeric_larger", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$2), isOperator: false }], args);
}
function numericLe(...args) {
    return sqlFunction("numeric_le", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$8), isOperator: false }], args);
}
function numericLn(...args) {
    return sqlFunction("numeric_ln", [{ args: [(default_1$2)], ret: (default_1$2), isOperator: false }], args);
}
function numericLog(...args) {
    return sqlFunction("numeric_log", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$2), isOperator: false }], args);
}
function numericLt(...args) {
    return sqlFunction("numeric_lt", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$8), isOperator: false }], args);
}
function numericMod(...args) {
    return sqlFunction("numeric_mod", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$2), isOperator: false }], args);
}
function numericMul(...args) {
    return sqlFunction("numeric_mul", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$2), isOperator: false }], args);
}
function numericNe(...args) {
    return sqlFunction("numeric_ne", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$8), isOperator: false }], args);
}
function numericPlPgLsn(...args) {
    return sqlFunction("numeric_pl_pg_lsn", [{ args: [(default_1$2), (pg_lsn)], ret: (pg_lsn), isOperator: false }], args);
}
function numericPower(...args) {
    return sqlFunction("numeric_power", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$2), isOperator: false }], args);
}
function numericSmaller(...args) {
    return sqlFunction("numeric_smaller", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$2), isOperator: false }], args);
}
function numericSqrt(...args) {
    return sqlFunction("numeric_sqrt", [{ args: [(default_1$2)], ret: (default_1$2), isOperator: false }], args);
}
function numericSub(...args) {
    return sqlFunction("numeric_sub", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$2), isOperator: false }], args);
}
function numericUminus(...args) {
    return sqlFunction("numeric_uminus", [{ args: [(default_1$2)], ret: (default_1$2), isOperator: false }], args);
}
function numericUplus(...args) {
    return sqlFunction("numeric_uplus", [{ args: [(default_1$2)], ret: (default_1$2), isOperator: false }], args);
}
function nummultirange(...args) {
    return sqlFunction("nummultirange", [{ args: [], ret: (nummultirange$1), isOperator: false }, { args: [Array$1.of((numrange$1))], ret: (nummultirange$1), isOperator: false }, { args: [(numrange$1)], ret: (nummultirange$1), isOperator: false }], args);
}
function numnode(...args) {
    return sqlFunction("numnode", [{ args: [(tsquery)], ret: (default_1$4), isOperator: false }], args);
}
function numrange(...args) {
    return sqlFunction("numrange", [{ args: [(default_1$2), (default_1$2)], ret: (numrange$1), isOperator: false }, { args: [(default_1$2), (default_1$2), (default_1$1)], ret: (numrange$1), isOperator: false }], args);
}
function numrangeSubdiff(...args) {
    return sqlFunction("numrange_subdiff", [{ args: [(default_1$2), (default_1$2)], ret: (default_1$6), isOperator: false }], args);
}
function objDescription(...args) {
    return sqlFunction("obj_description", [{ args: [(oid$1)], ret: (default_1$1), isOperator: false }, { args: [(oid$1), (name$1)], ret: (default_1$1), isOperator: false }], args);
}
function octetLength(...args) {
    return sqlFunction("octet_length", [{ args: [(bit$1)], ret: (default_1$4), isOperator: false }, { args: [(bpchar$1)], ret: (default_1$4), isOperator: false }, { args: [(bytea)], ret: (default_1$4), isOperator: false }, { args: [(default_1$1)], ret: (default_1$4), isOperator: false }], args);
}
function oid(...args) {
    return sqlFunction("oid", [{ args: [(default_1$3)], ret: (oid$1), isOperator: false }], args);
}
function oideq(...args) {
    return sqlFunction("oideq", [{ args: [(oid$1), (oid$1)], ret: (default_1$8), isOperator: false }], args);
}
function oidge(...args) {
    return sqlFunction("oidge", [{ args: [(oid$1), (oid$1)], ret: (default_1$8), isOperator: false }], args);
}
function oidgt(...args) {
    return sqlFunction("oidgt", [{ args: [(oid$1), (oid$1)], ret: (default_1$8), isOperator: false }], args);
}
function oidlarger(...args) {
    return sqlFunction("oidlarger", [{ args: [(oid$1), (oid$1)], ret: (oid$1), isOperator: false }], args);
}
function oidle(...args) {
    return sqlFunction("oidle", [{ args: [(oid$1), (oid$1)], ret: (default_1$8), isOperator: false }], args);
}
function oidlt(...args) {
    return sqlFunction("oidlt", [{ args: [(oid$1), (oid$1)], ret: (default_1$8), isOperator: false }], args);
}
function oidne(...args) {
    return sqlFunction("oidne", [{ args: [(oid$1), (oid$1)], ret: (default_1$8), isOperator: false }], args);
}
function oidsmaller(...args) {
    return sqlFunction("oidsmaller", [{ args: [(oid$1), (oid$1)], ret: (oid$1), isOperator: false }], args);
}
function oidvectoreq(...args) {
    return sqlFunction("oidvectoreq", [{ args: [(oidvector), (oidvector)], ret: (default_1$8), isOperator: false }], args);
}
function oidvectorge(...args) {
    return sqlFunction("oidvectorge", [{ args: [(oidvector), (oidvector)], ret: (default_1$8), isOperator: false }], args);
}
function oidvectorgt(...args) {
    return sqlFunction("oidvectorgt", [{ args: [(oidvector), (oidvector)], ret: (default_1$8), isOperator: false }], args);
}
function oidvectorle(...args) {
    return sqlFunction("oidvectorle", [{ args: [(oidvector), (oidvector)], ret: (default_1$8), isOperator: false }], args);
}
function oidvectorlt(...args) {
    return sqlFunction("oidvectorlt", [{ args: [(oidvector), (oidvector)], ret: (default_1$8), isOperator: false }], args);
}
function oidvectorne(...args) {
    return sqlFunction("oidvectorne", [{ args: [(oidvector), (oidvector)], ret: (default_1$8), isOperator: false }], args);
}
function oidvectortypes(...args) {
    return sqlFunction("oidvectortypes", [{ args: [(oidvector)], ret: (default_1$1), isOperator: false }], args);
}
function onPb(...args) {
    return sqlFunction("on_pb", [{ args: [(point$1), (box$1)], ret: (default_1$8), isOperator: false }], args);
}
function onPl(...args) {
    return sqlFunction("on_pl", [{ args: [(point$1), (line$1)], ret: (default_1$8), isOperator: false }], args);
}
function onPpath(...args) {
    return sqlFunction("on_ppath", [{ args: [(point$1), (path$1)], ret: (default_1$8), isOperator: false }], args);
}
function onPs(...args) {
    return sqlFunction("on_ps", [{ args: [(point$1), (lseg$1)], ret: (default_1$8), isOperator: false }], args);
}
function onSb(...args) {
    return sqlFunction("on_sb", [{ args: [(lseg$1), (box$1)], ret: (default_1$8), isOperator: false }], args);
}
function onSl(...args) {
    return sqlFunction("on_sl", [{ args: [(lseg$1), (line$1)], ret: (default_1$8), isOperator: false }], args);
}
function overlaps(...args) {
    return sqlFunction("overlaps", [{ args: [(time$1), (interval$1), (time$1), (interval$1)], ret: (default_1$8), isOperator: false }, { args: [(time$1), (interval$1), (time$1), (time$1)], ret: (default_1$8), isOperator: false }, { args: [(time$1), (time$1), (time$1), (interval$1)], ret: (default_1$8), isOperator: false }, { args: [(time$1), (time$1), (time$1), (time$1)], ret: (default_1$8), isOperator: false }, { args: [(timestamp$1), (interval$1), (timestamp$1), (interval$1)], ret: (default_1$8), isOperator: false }, { args: [(timestamp$1), (interval$1), (timestamp$1), (timestamp$1)], ret: (default_1$8), isOperator: false }, { args: [(timestamp$1), (timestamp$1), (timestamp$1), (interval$1)], ret: (default_1$8), isOperator: false }, { args: [(timestamp$1), (timestamp$1), (timestamp$1), (timestamp$1)], ret: (default_1$8), isOperator: false }, { args: [(timestamptz$1), (interval$1), (timestamptz$1), (interval$1)], ret: (default_1$8), isOperator: false }, { args: [(timestamptz$1), (interval$1), (timestamptz$1), (timestamptz$1)], ret: (default_1$8), isOperator: false }, { args: [(timestamptz$1), (timestamptz$1), (timestamptz$1), (interval$1)], ret: (default_1$8), isOperator: false }, { args: [(timestamptz$1), (timestamptz$1), (timestamptz$1), (timestamptz$1)], ret: (default_1$8), isOperator: false }, { args: [(timetz$1), (timetz$1), (timetz$1), (timetz$1)], ret: (default_1$8), isOperator: false }], args);
}
function overlay(...args) {
    return sqlFunction("overlay", [{ args: [(bit$1), (bit$1), (default_1$4)], ret: (bit$1), isOperator: false }, { args: [(bit$1), (bit$1), (default_1$4), (default_1$4)], ret: (bit$1), isOperator: false }, { args: [(bytea), (bytea), (default_1$4)], ret: (bytea), isOperator: false }, { args: [(bytea), (bytea), (default_1$4), (default_1$4)], ret: (bytea), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$4)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$4), (default_1$4)], ret: (default_1$1), isOperator: false }], args);
}
function parseIdent(...args) {
    return sqlFunction("parse_ident", [{ args: [(default_1$1), (default_1$8)], ret: Array$1.of((default_1$1)), isOperator: false }], args);
}
function path(...args) {
    return sqlFunction("path", [{ args: [(polygon$1)], ret: (path$1), isOperator: false }], args);
}
function pathAdd(...args) {
    return sqlFunction("path_add", [{ args: [(path$1), (path$1)], ret: (path$1), isOperator: false }], args);
}
function pathAddPt(...args) {
    return sqlFunction("path_add_pt", [{ args: [(path$1), (point$1)], ret: (path$1), isOperator: false }], args);
}
function pathContainPt(...args) {
    return sqlFunction("path_contain_pt", [{ args: [(path$1), (point$1)], ret: (default_1$8), isOperator: false }], args);
}
function pathDistance(...args) {
    return sqlFunction("path_distance", [{ args: [(path$1), (path$1)], ret: (default_1$6), isOperator: false }], args);
}
function pathDivPt(...args) {
    return sqlFunction("path_div_pt", [{ args: [(path$1), (point$1)], ret: (path$1), isOperator: false }], args);
}
function pathInter(...args) {
    return sqlFunction("path_inter", [{ args: [(path$1), (path$1)], ret: (default_1$8), isOperator: false }], args);
}
function pathLength(...args) {
    return sqlFunction("path_length", [{ args: [(path$1)], ret: (default_1$6), isOperator: false }], args);
}
function pathMulPt(...args) {
    return sqlFunction("path_mul_pt", [{ args: [(path$1), (point$1)], ret: (path$1), isOperator: false }], args);
}
function pathNEq(...args) {
    return sqlFunction("path_n_eq", [{ args: [(path$1), (path$1)], ret: (default_1$8), isOperator: false }], args);
}
function pathNGe(...args) {
    return sqlFunction("path_n_ge", [{ args: [(path$1), (path$1)], ret: (default_1$8), isOperator: false }], args);
}
function pathNGt(...args) {
    return sqlFunction("path_n_gt", [{ args: [(path$1), (path$1)], ret: (default_1$8), isOperator: false }], args);
}
function pathNLe(...args) {
    return sqlFunction("path_n_le", [{ args: [(path$1), (path$1)], ret: (default_1$8), isOperator: false }], args);
}
function pathNLt(...args) {
    return sqlFunction("path_n_lt", [{ args: [(path$1), (path$1)], ret: (default_1$8), isOperator: false }], args);
}
function pathNpoints(...args) {
    return sqlFunction("path_npoints", [{ args: [(path$1)], ret: (default_1$4), isOperator: false }], args);
}
function pathSubPt(...args) {
    return sqlFunction("path_sub_pt", [{ args: [(path$1), (point$1)], ret: (path$1), isOperator: false }], args);
}
function pclose(...args) {
    return sqlFunction("pclose", [{ args: [(path$1)], ret: (path$1), isOperator: false }], args);
}
function percentRank(...args) {
    return sqlFunction("percent_rank", [{ args: [], ret: (default_1$6), isOperator: false }, { args: [(Any)], ret: (default_1$6), isOperator: false }], args);
}
function percentileCont(...args) {
    return sqlFunction("percentile_cont", [{ args: [Array$1.of((default_1$6)), (default_1$6)], ret: Array$1.of((default_1$6)), isOperator: false }, { args: [Array$1.of((default_1$6)), (interval$1)], ret: Array$1.of((interval$1)), isOperator: false }, { args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }, { args: [(default_1$6), (interval$1)], ret: (interval$1), isOperator: false }], args);
}
function percentileDisc(...args) {
    return sqlFunction("percentile_disc", [({ T }) => ({ args: [Array$1.of((default_1$6)), T], ret: Array$1.of(T), isOperator: false }), ({ T }) => ({ args: [(default_1$6), T], ret: T, isOperator: false })], args);
}
function pgAdvisoryLock(...args) {
    return sqlFunction("pg_advisory_lock", [{ args: [(default_1$4), (default_1$4)], ret: (_void), isOperator: false }, { args: [(default_1$3)], ret: (_void), isOperator: false }], args);
}
function pgAdvisoryLockShared(...args) {
    return sqlFunction("pg_advisory_lock_shared", [{ args: [(default_1$4), (default_1$4)], ret: (_void), isOperator: false }, { args: [(default_1$3)], ret: (_void), isOperator: false }], args);
}
function pgAdvisoryUnlock(...args) {
    return sqlFunction("pg_advisory_unlock", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$8), isOperator: false }, { args: [(default_1$3)], ret: (default_1$8), isOperator: false }], args);
}
function pgAdvisoryUnlockAll(...args) {
    return sqlFunction("pg_advisory_unlock_all", [{ args: [], ret: (_void), isOperator: false }], args);
}
function pgAdvisoryUnlockShared(...args) {
    return sqlFunction("pg_advisory_unlock_shared", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$8), isOperator: false }, { args: [(default_1$3)], ret: (default_1$8), isOperator: false }], args);
}
function pgAdvisoryXactLock(...args) {
    return sqlFunction("pg_advisory_xact_lock", [{ args: [(default_1$4), (default_1$4)], ret: (_void), isOperator: false }, { args: [(default_1$3)], ret: (_void), isOperator: false }], args);
}
function pgAdvisoryXactLockShared(...args) {
    return sqlFunction("pg_advisory_xact_lock_shared", [{ args: [(default_1$4), (default_1$4)], ret: (_void), isOperator: false }, { args: [(default_1$3)], ret: (_void), isOperator: false }], args);
}
function pgAvailableExtensionVersions(...args) {
    return sqlFunction("pg_available_extension_versions", [{ args: [], ret: Setof.ofSchema({ name: (name$1), version: (default_1$1), superuser: (default_1$8), trusted: (default_1$8), relocatable: (default_1$8), schema: (name$1), requires: Array$1.of((name$1)), comment: (default_1$1) }), isOperator: false }], args);
}
function pgAvailableExtensions(...args) {
    return sqlFunction("pg_available_extensions", [{ args: [], ret: Setof.ofSchema({ name: (name$1), default_version: (default_1$1), comment: (default_1$1) }), isOperator: false }], args);
}
function pgAvailableWalSummaries(...args) {
    return sqlFunction("pg_available_wal_summaries", [{ args: [], ret: Setof.ofSchema({ tli: (default_1$3), start_lsn: (pg_lsn), end_lsn: (pg_lsn) }), isOperator: false }], args);
}
function pgBackendPid(...args) {
    return sqlFunction("pg_backend_pid", [{ args: [], ret: (default_1$4), isOperator: false }], args);
}
function pgBackupStart(...args) {
    return sqlFunction("pg_backup_start", [{ args: [(default_1$1), (default_1$8)], ret: (pg_lsn), isOperator: false }], args);
}
function pgBackupStop(...args) {
    return sqlFunction("pg_backup_stop", [{ args: [(default_1$8)], ret: Record.of({ lsn: (pg_lsn), labelfile: (default_1$1), spcmapfile: (default_1$1) }), isOperator: false }], args);
}
function pgBasetype(...args) {
    return sqlFunction("pg_basetype", [{ args: [(regtype)], ret: (regtype), isOperator: false }], args);
}
function pgBlockingPids(...args) {
    return sqlFunction("pg_blocking_pids", [{ args: [(default_1$4)], ret: Array$1.of((default_1$4)), isOperator: false }], args);
}
function pgCancelBackend(...args) {
    return sqlFunction("pg_cancel_backend", [{ args: [(default_1$4)], ret: (default_1$8), isOperator: false }], args);
}
function pgCharToEncoding(...args) {
    return sqlFunction("pg_char_to_encoding", [{ args: [(name$1)], ret: (default_1$4), isOperator: false }], args);
}
function pgClientEncoding(...args) {
    return sqlFunction("pg_client_encoding", [{ args: [], ret: (name$1), isOperator: false }], args);
}
function pgCollationActualVersion(...args) {
    return sqlFunction("pg_collation_actual_version", [{ args: [(oid$1)], ret: (default_1$1), isOperator: false }], args);
}
function pgCollationFor(...args) {
    return sqlFunction("pg_collation_for", [{ args: [(Any)], ret: (default_1$1), isOperator: false }], args);
}
function pgCollationIsVisible(...args) {
    return sqlFunction("pg_collation_is_visible", [{ args: [(oid$1)], ret: (default_1$8), isOperator: false }], args);
}
function pgColumnCompression(...args) {
    return sqlFunction("pg_column_compression", [{ args: [(Any)], ret: (default_1$1), isOperator: false }], args);
}
function pgColumnIsUpdatable(...args) {
    return sqlFunction("pg_column_is_updatable", [{ args: [(regclass$1), (default_1$5), (default_1$8)], ret: (default_1$8), isOperator: false }], args);
}
function pgColumnSize(...args) {
    return sqlFunction("pg_column_size", [{ args: [(Any)], ret: (default_1$4), isOperator: false }], args);
}
function pgColumnToastChunkId(...args) {
    return sqlFunction("pg_column_toast_chunk_id", [{ args: [(Any)], ret: (oid$1), isOperator: false }], args);
}
function pgConfLoadTime(...args) {
    return sqlFunction("pg_conf_load_time", [{ args: [], ret: (timestamptz$1), isOperator: false }], args);
}
function pgConfig(...args) {
    return sqlFunction("pg_config", [{ args: [], ret: Setof.ofSchema({ name: (default_1$1), setting: (default_1$1) }), isOperator: false }], args);
}
function pgControlCheckpoint(...args) {
    return sqlFunction("pg_control_checkpoint", [{ args: [], ret: Record.of({ checkpoint_lsn: (pg_lsn), redo_lsn: (pg_lsn), redo_wal_file: (default_1$1), timeline_id: (default_1$4), prev_timeline_id: (default_1$4), full_page_writes: (default_1$8), next_xid: (default_1$1), next_oid: (oid$1), next_multixact_id: (xid$1), next_multi_offset: (xid$1), oldest_xid: (xid$1), oldest_xid_dbid: (oid$1), oldest_active_xid: (xid$1), oldest_multi_xid: (xid$1), oldest_multi_dbid: (oid$1), oldest_commit_ts_xid: (xid$1), newest_commit_ts_xid: (xid$1), checkpoint_time: (timestamptz$1) }), isOperator: false }], args);
}
function pgControlInit(...args) {
    return sqlFunction("pg_control_init", [{ args: [], ret: Record.of({ max_data_alignment: (default_1$4), database_block_size: (default_1$4), blocks_per_segment: (default_1$4), wal_block_size: (default_1$4), bytes_per_wal_segment: (default_1$4), max_identifier_length: (default_1$4), max_index_columns: (default_1$4), max_toast_chunk_size: (default_1$4), large_object_chunk_size: (default_1$4), float8_pass_by_value: (default_1$8), data_page_checksum_version: (default_1$4) }), isOperator: false }], args);
}
function pgControlRecovery(...args) {
    return sqlFunction("pg_control_recovery", [{ args: [], ret: Record.of({ min_recovery_end_lsn: (pg_lsn), min_recovery_end_timeline: (default_1$4), backup_start_lsn: (pg_lsn), backup_end_lsn: (pg_lsn), end_of_backup_record_required: (default_1$8) }), isOperator: false }], args);
}
function pgControlSystem(...args) {
    return sqlFunction("pg_control_system", [{ args: [], ret: Record.of({ pg_control_version: (default_1$4), catalog_version_no: (default_1$4), system_identifier: (default_1$3), pg_control_last_modified: (timestamptz$1) }), isOperator: false }], args);
}
function pgConversionIsVisible(...args) {
    return sqlFunction("pg_conversion_is_visible", [{ args: [(oid$1)], ret: (default_1$8), isOperator: false }], args);
}
function pgCopyLogicalReplicationSlot(...args) {
    return sqlFunction("pg_copy_logical_replication_slot", [{ args: [(name$1), (name$1)], ret: Record.of({ slot_name: (name$1), lsn: (pg_lsn) }), isOperator: false }, { args: [(name$1), (name$1), (default_1$8)], ret: Record.of({ slot_name: (name$1), lsn: (pg_lsn) }), isOperator: false }, { args: [(name$1), (name$1), (default_1$8), (name$1)], ret: Record.of({ slot_name: (name$1), lsn: (pg_lsn) }), isOperator: false }], args);
}
function pgCopyPhysicalReplicationSlot(...args) {
    return sqlFunction("pg_copy_physical_replication_slot", [{ args: [(name$1), (name$1)], ret: Record.of({ slot_name: (name$1), lsn: (pg_lsn) }), isOperator: false }, { args: [(name$1), (name$1), (default_1$8)], ret: Record.of({ slot_name: (name$1), lsn: (pg_lsn) }), isOperator: false }], args);
}
function pgCreateLogicalReplicationSlot(...args) {
    return sqlFunction("pg_create_logical_replication_slot", [{ args: [(name$1), (name$1), (default_1$8), (default_1$8), (default_1$8)], ret: Record.of({ slot_name: (name$1), lsn: (pg_lsn) }), isOperator: false }], args);
}
function pgCreatePhysicalReplicationSlot(...args) {
    return sqlFunction("pg_create_physical_replication_slot", [{ args: [(name$1), (default_1$8), (default_1$8)], ret: Record.of({ slot_name: (name$1), lsn: (pg_lsn) }), isOperator: false }], args);
}
function pgCreateRestorePoint(...args) {
    return sqlFunction("pg_create_restore_point", [{ args: [(default_1$1)], ret: (pg_lsn), isOperator: false }], args);
}
function pgCurrentLogfile(...args) {
    return sqlFunction("pg_current_logfile", [{ args: [], ret: (default_1$1), isOperator: false }, { args: [(default_1$1)], ret: (default_1$1), isOperator: false }], args);
}
function pgCurrentSnapshot(...args) {
    return sqlFunction("pg_current_snapshot", [{ args: [], ret: (pg_snapshot), isOperator: false }], args);
}
function pgCurrentWalFlushLsn(...args) {
    return sqlFunction("pg_current_wal_flush_lsn", [{ args: [], ret: (pg_lsn), isOperator: false }], args);
}
function pgCurrentWalInsertLsn(...args) {
    return sqlFunction("pg_current_wal_insert_lsn", [{ args: [], ret: (pg_lsn), isOperator: false }], args);
}
function pgCurrentWalLsn(...args) {
    return sqlFunction("pg_current_wal_lsn", [{ args: [], ret: (pg_lsn), isOperator: false }], args);
}
function pgCurrentXactId(...args) {
    return sqlFunction("pg_current_xact_id", [{ args: [], ret: (xid8), isOperator: false }], args);
}
function pgCurrentXactIdIfAssigned(...args) {
    return sqlFunction("pg_current_xact_id_if_assigned", [{ args: [], ret: (xid8), isOperator: false }], args);
}
function pgCursor(...args) {
    return sqlFunction("pg_cursor", [{ args: [], ret: Setof.ofSchema({ name: (default_1$1), statement: (default_1$1), is_holdable: (default_1$8), is_binary: (default_1$8), is_scrollable: (default_1$8), creation_time: (timestamptz$1) }), isOperator: false }], args);
}
function pgDatabaseCollationActualVersion(...args) {
    return sqlFunction("pg_database_collation_actual_version", [{ args: [(oid$1)], ret: (default_1$1), isOperator: false }], args);
}
function pgDatabaseSize(...args) {
    return sqlFunction("pg_database_size", [{ args: [(name$1)], ret: (default_1$3), isOperator: false }, { args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgDescribeObject(...args) {
    return sqlFunction("pg_describe_object", [{ args: [(oid$1), (oid$1), (default_1$4)], ret: (default_1$1), isOperator: false }], args);
}
function pgDropReplicationSlot(...args) {
    return sqlFunction("pg_drop_replication_slot", [{ args: [(name$1)], ret: (_void), isOperator: false }], args);
}
function pgEncodingMaxLength(...args) {
    return sqlFunction("pg_encoding_max_length", [{ args: [(default_1$4)], ret: (default_1$4), isOperator: false }], args);
}
function pgEncodingToChar(...args) {
    return sqlFunction("pg_encoding_to_char", [{ args: [(default_1$4)], ret: (name$1), isOperator: false }], args);
}
function pgEventTriggerDdlCommands(...args) {
    return sqlFunction("pg_event_trigger_ddl_commands", [{ args: [], ret: Setof.ofSchema({ classid: (oid$1), objid: (oid$1), objsubid: (default_1$4), command_tag: (default_1$1), object_type: (default_1$1), schema_name: (default_1$1), object_identity: (default_1$1), in_extension: (default_1$8), command: (pg_ddl_command) }), isOperator: false }], args);
}
function pgEventTriggerDroppedObjects(...args) {
    return sqlFunction("pg_event_trigger_dropped_objects", [{ args: [], ret: Setof.ofSchema({ classid: (oid$1), objid: (oid$1), objsubid: (default_1$4), original: (default_1$8), normal: (default_1$8), is_temporary: (default_1$8), object_type: (default_1$1), schema_name: (default_1$1), object_name: (default_1$1), object_identity: (default_1$1), address_names: Array$1.of((default_1$1)), address_args: Array$1.of((default_1$1)) }), isOperator: false }], args);
}
function pgEventTriggerTableRewriteOid(...args) {
    return sqlFunction("pg_event_trigger_table_rewrite_oid", [{ args: [], ret: (oid$1), isOperator: false }], args);
}
function pgEventTriggerTableRewriteReason(...args) {
    return sqlFunction("pg_event_trigger_table_rewrite_reason", [{ args: [], ret: (default_1$4), isOperator: false }], args);
}
function pgExportSnapshot(...args) {
    return sqlFunction("pg_export_snapshot", [{ args: [], ret: (default_1$1), isOperator: false }], args);
}
function pgExtensionConfigDump(...args) {
    return sqlFunction("pg_extension_config_dump", [{ args: [(regclass$1), (default_1$1)], ret: (_void), isOperator: false }], args);
}
function pgExtensionUpdatePaths(...args) {
    return sqlFunction("pg_extension_update_paths", [{ args: [(name$1)], ret: Setof.ofSchema({ source: (default_1$1), target: (default_1$1), path: (default_1$1) }), isOperator: false }], args);
}
function pgFilenodeRelation(...args) {
    return sqlFunction("pg_filenode_relation", [{ args: [(oid$1), (oid$1)], ret: (regclass$1), isOperator: false }], args);
}
function pgFunctionIsVisible(...args) {
    return sqlFunction("pg_function_is_visible", [{ args: [(oid$1)], ret: (default_1$8), isOperator: false }], args);
}
function pgGetBackendMemoryContexts(...args) {
    return sqlFunction("pg_get_backend_memory_contexts", [{ args: [], ret: Setof.ofSchema({ name: (default_1$1), ident: (default_1$1), parent: (default_1$1), level: (default_1$4), total_bytes: (default_1$3), total_nblocks: (default_1$3), free_bytes: (default_1$3), free_chunks: (default_1$3), used_bytes: (default_1$3) }), isOperator: false }], args);
}
function pgGetCatalogForeignKeys(...args) {
    return sqlFunction("pg_get_catalog_foreign_keys", [{ args: [], ret: Setof.ofSchema({ fktable: (regclass$1), fkcols: Array$1.of((default_1$1)), pktable: (regclass$1), pkcols: Array$1.of((default_1$1)), is_array: (default_1$8), is_opt: (default_1$8) }), isOperator: false }], args);
}
function pgGetConstraintdef(...args) {
    return sqlFunction("pg_get_constraintdef", [{ args: [(oid$1)], ret: (default_1$1), isOperator: false }, { args: [(oid$1), (default_1$8)], ret: (default_1$1), isOperator: false }], args);
}
function pgGetExpr(...args) {
    return sqlFunction("pg_get_expr", [{ args: [(pg_node_tree), (oid$1)], ret: (default_1$1), isOperator: false }, { args: [(pg_node_tree), (oid$1), (default_1$8)], ret: (default_1$1), isOperator: false }], args);
}
function pgGetFunctionArgDefault(...args) {
    return sqlFunction("pg_get_function_arg_default", [{ args: [(oid$1), (default_1$4)], ret: (default_1$1), isOperator: false }], args);
}
function pgGetFunctionArguments(...args) {
    return sqlFunction("pg_get_function_arguments", [{ args: [(oid$1)], ret: (default_1$1), isOperator: false }], args);
}
function pgGetFunctionIdentityArguments(...args) {
    return sqlFunction("pg_get_function_identity_arguments", [{ args: [(oid$1)], ret: (default_1$1), isOperator: false }], args);
}
function pgGetFunctionResult(...args) {
    return sqlFunction("pg_get_function_result", [{ args: [(oid$1)], ret: (default_1$1), isOperator: false }], args);
}
function pgGetFunctionSqlbody(...args) {
    return sqlFunction("pg_get_function_sqlbody", [{ args: [(oid$1)], ret: (default_1$1), isOperator: false }], args);
}
function pgGetFunctiondef(...args) {
    return sqlFunction("pg_get_functiondef", [{ args: [(oid$1)], ret: (default_1$1), isOperator: false }], args);
}
function pgGetIndexdef(...args) {
    return sqlFunction("pg_get_indexdef", [{ args: [(oid$1)], ret: (default_1$1), isOperator: false }, { args: [(oid$1), (default_1$4), (default_1$8)], ret: (default_1$1), isOperator: false }], args);
}
function pgGetKeywords(...args) {
    return sqlFunction("pg_get_keywords", [{ args: [], ret: Setof.ofSchema({ word: (default_1$1), catcode: (char$1), barelabel: (default_1$8), catdesc: (default_1$1), baredesc: (default_1$1) }), isOperator: false }], args);
}
function pgGetMultixactMembers(...args) {
    return sqlFunction("pg_get_multixact_members", [{ args: [(xid$1)], ret: Setof.ofSchema({ xid: (xid$1), mode: (default_1$1) }), isOperator: false }], args);
}
function pgGetObjectAddress(...args) {
    return sqlFunction("pg_get_object_address", [{ args: [(default_1$1), Array$1.of((default_1$1)), Array$1.of((default_1$1))], ret: Record.of({ classid: (oid$1), objid: (oid$1), objsubid: (default_1$4) }), isOperator: false }], args);
}
function pgGetPartitionConstraintdef(...args) {
    return sqlFunction("pg_get_partition_constraintdef", [{ args: [(oid$1)], ret: (default_1$1), isOperator: false }], args);
}
function pgGetPartkeydef(...args) {
    return sqlFunction("pg_get_partkeydef", [{ args: [(oid$1)], ret: (default_1$1), isOperator: false }], args);
}
function pgGetPublicationTables(...args) {
    return sqlFunction("pg_get_publication_tables", [{ args: [Array$1.of((default_1$1))], ret: Setof.ofSchema({ pubid: (oid$1), relid: (oid$1), attrs: (int2vector), qual: (pg_node_tree) }), isOperator: false }], args);
}
function pgGetReplicaIdentityIndex(...args) {
    return sqlFunction("pg_get_replica_identity_index", [{ args: [(regclass$1)], ret: (regclass$1), isOperator: false }], args);
}
function pgGetReplicationSlots(...args) {
    return sqlFunction("pg_get_replication_slots", [{ args: [], ret: Setof.ofSchema({ slot_name: (name$1), plugin: (name$1), slot_type: (default_1$1), datoid: (oid$1), temporary: (default_1$8), active: (default_1$8), active_pid: (default_1$4), xmin: (xid$1), catalog_xmin: (xid$1), restart_lsn: (pg_lsn), confirmed_flush_lsn: (pg_lsn), wal_status: (default_1$1), safe_wal_size: (default_1$3), two_phase: (default_1$8), inactive_since: (timestamptz$1), conflicting: (default_1$8), invalidation_reason: (default_1$1), failover: (default_1$8), synced: (default_1$8) }), isOperator: false }], args);
}
function pgGetRuledef(...args) {
    return sqlFunction("pg_get_ruledef", [{ args: [(oid$1)], ret: (default_1$1), isOperator: false }, { args: [(oid$1), (default_1$8)], ret: (default_1$1), isOperator: false }], args);
}
function pgGetSerialSequence(...args) {
    return sqlFunction("pg_get_serial_sequence", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$1), isOperator: false }], args);
}
function pgGetShmemAllocations(...args) {
    return sqlFunction("pg_get_shmem_allocations", [{ args: [], ret: Setof.ofSchema({ name: (default_1$1), off: (default_1$3), size: (default_1$3), allocated_size: (default_1$3) }), isOperator: false }], args);
}
function pgGetStatisticsobjdef(...args) {
    return sqlFunction("pg_get_statisticsobjdef", [{ args: [(oid$1)], ret: (default_1$1), isOperator: false }], args);
}
function pgGetStatisticsobjdefColumns(...args) {
    return sqlFunction("pg_get_statisticsobjdef_columns", [{ args: [(oid$1)], ret: (default_1$1), isOperator: false }], args);
}
function pgGetStatisticsobjdefExpressions(...args) {
    return sqlFunction("pg_get_statisticsobjdef_expressions", [{ args: [(oid$1)], ret: Array$1.of((default_1$1)), isOperator: false }], args);
}
function pgGetTriggerdef(...args) {
    return sqlFunction("pg_get_triggerdef", [{ args: [(oid$1)], ret: (default_1$1), isOperator: false }, { args: [(oid$1), (default_1$8)], ret: (default_1$1), isOperator: false }], args);
}
function pgGetUserbyid(...args) {
    return sqlFunction("pg_get_userbyid", [{ args: [(oid$1)], ret: (name$1), isOperator: false }], args);
}
function pgGetViewdef(...args) {
    return sqlFunction("pg_get_viewdef", [{ args: [(oid$1)], ret: (default_1$1), isOperator: false }, { args: [(oid$1), (default_1$8)], ret: (default_1$1), isOperator: false }, { args: [(oid$1), (default_1$4)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$8)], ret: (default_1$1), isOperator: false }], args);
}
function pgGetWaitEvents(...args) {
    return sqlFunction("pg_get_wait_events", [{ args: [], ret: Setof.ofSchema({ type: (default_1$1), name: (default_1$1), description: (default_1$1) }), isOperator: false }], args);
}
function pgGetWalReplayPauseState(...args) {
    return sqlFunction("pg_get_wal_replay_pause_state", [{ args: [], ret: (default_1$1), isOperator: false }], args);
}
function pgGetWalResourceManagers(...args) {
    return sqlFunction("pg_get_wal_resource_managers", [{ args: [], ret: Setof.ofSchema({ rm_id: (default_1$4), rm_name: (default_1$1), rm_builtin: (default_1$8) }), isOperator: false }], args);
}
function pgGetWalSummarizerState(...args) {
    return sqlFunction("pg_get_wal_summarizer_state", [{ args: [], ret: Record.of({ summarized_tli: (default_1$3), summarized_lsn: (pg_lsn), pending_lsn: (pg_lsn), summarizer_pid: (default_1$4) }), isOperator: false }], args);
}
function pgHasRole(...args) {
    return sqlFunction("pg_has_role", [{ args: [(name$1), (name$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(name$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(name$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (name$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function pgHbaFileRules(...args) {
    return sqlFunction("pg_hba_file_rules", [{ args: [], ret: Setof.ofSchema({ rule_number: (default_1$4), file_name: (default_1$1), line_number: (default_1$4), type: (default_1$1), database: Array$1.of((default_1$1)), user_name: Array$1.of((default_1$1)), address: (default_1$1), netmask: (default_1$1), auth_method: (default_1$1), options: Array$1.of((default_1$1)), error: (default_1$1) }), isOperator: false }], args);
}
function pgIdentFileMappings(...args) {
    return sqlFunction("pg_ident_file_mappings", [{ args: [], ret: Setof.ofSchema({ map_number: (default_1$4), file_name: (default_1$1), line_number: (default_1$4), map_name: (default_1$1), sys_name: (default_1$1), pg_username: (default_1$1), error: (default_1$1) }), isOperator: false }], args);
}
function pgIdentifyObject(...args) {
    return sqlFunction("pg_identify_object", [{ args: [(oid$1), (oid$1), (default_1$4)], ret: Record.of({ type: (default_1$1), schema: (default_1$1), name: (default_1$1), identity: (default_1$1) }), isOperator: false }], args);
}
function pgIdentifyObjectAsAddress(...args) {
    return sqlFunction("pg_identify_object_as_address", [{ args: [(oid$1), (oid$1), (default_1$4)], ret: Record.of({ type: (default_1$1), object_names: Array$1.of((default_1$1)), object_args: Array$1.of((default_1$1)) }), isOperator: false }], args);
}
function pgImportSystemCollations(...args) {
    return sqlFunction("pg_import_system_collations", [{ args: [(regnamespace)], ret: (default_1$4), isOperator: false }], args);
}
function pgIndexColumnHasProperty(...args) {
    return sqlFunction("pg_index_column_has_property", [{ args: [(regclass$1), (default_1$4), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function pgIndexHasProperty(...args) {
    return sqlFunction("pg_index_has_property", [{ args: [(regclass$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function pgIndexamHasProperty(...args) {
    return sqlFunction("pg_indexam_has_property", [{ args: [(oid$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function pgIndexamProgressPhasename(...args) {
    return sqlFunction("pg_indexam_progress_phasename", [{ args: [(oid$1), (default_1$3)], ret: (default_1$1), isOperator: false }], args);
}
function pgIndexesSize(...args) {
    return sqlFunction("pg_indexes_size", [{ args: [(regclass$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgInputErrorInfo(...args) {
    return sqlFunction("pg_input_error_info", [{ args: [(default_1$1), (default_1$1)], ret: Record.of({ message: (default_1$1), detail: (default_1$1), hint: (default_1$1), sql_error_code: (default_1$1) }), isOperator: false }], args);
}
function pgInputIsValid(...args) {
    return sqlFunction("pg_input_is_valid", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function pgIsInRecovery(...args) {
    return sqlFunction("pg_is_in_recovery", [{ args: [], ret: (default_1$8), isOperator: false }], args);
}
function pgIsOtherTempSchema(...args) {
    return sqlFunction("pg_is_other_temp_schema", [{ args: [(oid$1)], ret: (default_1$8), isOperator: false }], args);
}
function pgIsWalReplayPaused(...args) {
    return sqlFunction("pg_is_wal_replay_paused", [{ args: [], ret: (default_1$8), isOperator: false }], args);
}
function pgIsolationTestSessionIsBlocked(...args) {
    return sqlFunction("pg_isolation_test_session_is_blocked", [{ args: [(default_1$4), Array$1.of((default_1$4))], ret: (default_1$8), isOperator: false }], args);
}
function pgJitAvailable(...args) {
    return sqlFunction("pg_jit_available", [{ args: [], ret: (default_1$8), isOperator: false }], args);
}
function pgLastCommittedXact(...args) {
    return sqlFunction("pg_last_committed_xact", [{ args: [], ret: Record.of({ xid: (xid$1), timestamp: (timestamptz$1), roident: (oid$1) }), isOperator: false }], args);
}
function pgLastWalReceiveLsn(...args) {
    return sqlFunction("pg_last_wal_receive_lsn", [{ args: [], ret: (pg_lsn), isOperator: false }], args);
}
function pgLastWalReplayLsn(...args) {
    return sqlFunction("pg_last_wal_replay_lsn", [{ args: [], ret: (pg_lsn), isOperator: false }], args);
}
function pgLastXactReplayTimestamp(...args) {
    return sqlFunction("pg_last_xact_replay_timestamp", [{ args: [], ret: (timestamptz$1), isOperator: false }], args);
}
function pgListeningChannels(...args) {
    return sqlFunction("pg_listening_channels", [{ args: [], ret: Setof.ofSchema({}), isOperator: false }], args);
}
function pgLockStatus(...args) {
    return sqlFunction("pg_lock_status", [{ args: [], ret: Setof.ofSchema({ locktype: (default_1$1), database: (oid$1), relation: (oid$1), page: (default_1$4), tuple: (default_1$5), virtualxid: (default_1$1), transactionid: (xid$1), classid: (oid$1), objid: (oid$1), objsubid: (default_1$5), virtualtransaction: (default_1$1), pid: (default_1$4), mode: (default_1$1), granted: (default_1$8), fastpath: (default_1$8), waitstart: (timestamptz$1) }), isOperator: false }], args);
}
function pgLogBackendMemoryContexts(...args) {
    return sqlFunction("pg_log_backend_memory_contexts", [{ args: [(default_1$4)], ret: (default_1$8), isOperator: false }], args);
}
function pgLogStandbySnapshot(...args) {
    return sqlFunction("pg_log_standby_snapshot", [{ args: [], ret: (pg_lsn), isOperator: false }], args);
}
function pgLogicalEmitMessage(...args) {
    return sqlFunction("pg_logical_emit_message", [{ args: [(default_1$8), (default_1$1), (bytea), (default_1$8)], ret: (pg_lsn), isOperator: false }, { args: [(default_1$8), (default_1$1), (default_1$1), (default_1$8)], ret: (pg_lsn), isOperator: false }], args);
}
function pgLogicalSlotGetBinaryChanges(...args) {
    return sqlFunction("pg_logical_slot_get_binary_changes", [{ args: [(name$1), (pg_lsn), (default_1$4), Array$1.of((default_1$1))], ret: Setof.ofSchema({ lsn: (pg_lsn), xid: (xid$1), data: (bytea) }), isOperator: false }], args);
}
function pgLogicalSlotGetChanges(...args) {
    return sqlFunction("pg_logical_slot_get_changes", [{ args: [(name$1), (pg_lsn), (default_1$4), Array$1.of((default_1$1))], ret: Setof.ofSchema({ lsn: (pg_lsn), xid: (xid$1), data: (default_1$1) }), isOperator: false }], args);
}
function pgLogicalSlotPeekBinaryChanges(...args) {
    return sqlFunction("pg_logical_slot_peek_binary_changes", [{ args: [(name$1), (pg_lsn), (default_1$4), Array$1.of((default_1$1))], ret: Setof.ofSchema({ lsn: (pg_lsn), xid: (xid$1), data: (bytea) }), isOperator: false }], args);
}
function pgLogicalSlotPeekChanges(...args) {
    return sqlFunction("pg_logical_slot_peek_changes", [{ args: [(name$1), (pg_lsn), (default_1$4), Array$1.of((default_1$1))], ret: Setof.ofSchema({ lsn: (pg_lsn), xid: (xid$1), data: (default_1$1) }), isOperator: false }], args);
}
function pgLsArchiveStatusdir(...args) {
    return sqlFunction("pg_ls_archive_statusdir", [{ args: [], ret: Setof.ofSchema({ name: (default_1$1), size: (default_1$3), modification: (timestamptz$1) }), isOperator: false }], args);
}
function pgLsDir(...args) {
    return sqlFunction("pg_ls_dir", [{ args: [(default_1$1)], ret: Setof.ofSchema({}), isOperator: false }, { args: [(default_1$1), (default_1$8), (default_1$8)], ret: Setof.ofSchema({}), isOperator: false }], args);
}
function pgLsLogdir(...args) {
    return sqlFunction("pg_ls_logdir", [{ args: [], ret: Setof.ofSchema({ name: (default_1$1), size: (default_1$3), modification: (timestamptz$1) }), isOperator: false }], args);
}
function pgLsLogicalmapdir(...args) {
    return sqlFunction("pg_ls_logicalmapdir", [{ args: [], ret: Setof.ofSchema({ name: (default_1$1), size: (default_1$3), modification: (timestamptz$1) }), isOperator: false }], args);
}
function pgLsLogicalsnapdir(...args) {
    return sqlFunction("pg_ls_logicalsnapdir", [{ args: [], ret: Setof.ofSchema({ name: (default_1$1), size: (default_1$3), modification: (timestamptz$1) }), isOperator: false }], args);
}
function pgLsReplslotdir(...args) {
    return sqlFunction("pg_ls_replslotdir", [{ args: [(default_1$1)], ret: Setof.ofSchema({ name: (default_1$1), size: (default_1$3), modification: (timestamptz$1) }), isOperator: false }], args);
}
function pgLsTmpdir(...args) {
    return sqlFunction("pg_ls_tmpdir", [{ args: [], ret: Setof.ofSchema({ name: (default_1$1), size: (default_1$3), modification: (timestamptz$1) }), isOperator: false }, { args: [(oid$1)], ret: Setof.ofSchema({ name: (default_1$1), size: (default_1$3), modification: (timestamptz$1) }), isOperator: false }], args);
}
function pgLsWaldir(...args) {
    return sqlFunction("pg_ls_waldir", [{ args: [], ret: Setof.ofSchema({ name: (default_1$1), size: (default_1$3), modification: (timestamptz$1) }), isOperator: false }], args);
}
function pgLsn(...args) {
    return sqlFunction("pg_lsn", [{ args: [(default_1$2)], ret: (pg_lsn), isOperator: false }], args);
}
function pgLsnCmp(...args) {
    return sqlFunction("pg_lsn_cmp", [{ args: [(pg_lsn), (pg_lsn)], ret: (default_1$4), isOperator: false }], args);
}
function pgLsnEq(...args) {
    return sqlFunction("pg_lsn_eq", [{ args: [(pg_lsn), (pg_lsn)], ret: (default_1$8), isOperator: false }], args);
}
function pgLsnGe(...args) {
    return sqlFunction("pg_lsn_ge", [{ args: [(pg_lsn), (pg_lsn)], ret: (default_1$8), isOperator: false }], args);
}
function pgLsnGt(...args) {
    return sqlFunction("pg_lsn_gt", [{ args: [(pg_lsn), (pg_lsn)], ret: (default_1$8), isOperator: false }], args);
}
function pgLsnHash(...args) {
    return sqlFunction("pg_lsn_hash", [{ args: [(pg_lsn)], ret: (default_1$4), isOperator: false }], args);
}
function pgLsnHashExtended(...args) {
    return sqlFunction("pg_lsn_hash_extended", [{ args: [(pg_lsn), (default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function pgLsnLarger(...args) {
    return sqlFunction("pg_lsn_larger", [{ args: [(pg_lsn), (pg_lsn)], ret: (pg_lsn), isOperator: false }], args);
}
function pgLsnLe(...args) {
    return sqlFunction("pg_lsn_le", [{ args: [(pg_lsn), (pg_lsn)], ret: (default_1$8), isOperator: false }], args);
}
function pgLsnLt(...args) {
    return sqlFunction("pg_lsn_lt", [{ args: [(pg_lsn), (pg_lsn)], ret: (default_1$8), isOperator: false }], args);
}
function pgLsnMi(...args) {
    return sqlFunction("pg_lsn_mi", [{ args: [(pg_lsn), (pg_lsn)], ret: (default_1$2), isOperator: false }], args);
}
function pgLsnMii(...args) {
    return sqlFunction("pg_lsn_mii", [{ args: [(pg_lsn), (default_1$2)], ret: (pg_lsn), isOperator: false }], args);
}
function pgLsnNe(...args) {
    return sqlFunction("pg_lsn_ne", [{ args: [(pg_lsn), (pg_lsn)], ret: (default_1$8), isOperator: false }], args);
}
function pgLsnPli(...args) {
    return sqlFunction("pg_lsn_pli", [{ args: [(pg_lsn), (default_1$2)], ret: (pg_lsn), isOperator: false }], args);
}
function pgLsnSmaller(...args) {
    return sqlFunction("pg_lsn_smaller", [{ args: [(pg_lsn), (pg_lsn)], ret: (pg_lsn), isOperator: false }], args);
}
function pgMcvListItems(...args) {
    return sqlFunction("pg_mcv_list_items", [{ args: [(pg_mcv_list)], ret: Setof.ofSchema({ index: (default_1$4), values: Array$1.of((default_1$1)), nulls: Array$1.of((default_1$8)), frequency: (default_1$6), base_frequency: (default_1$6) }), isOperator: false }], args);
}
function pgMyTempSchema(...args) {
    return sqlFunction("pg_my_temp_schema", [{ args: [], ret: (oid$1), isOperator: false }], args);
}
function pgNextoid(...args) {
    return sqlFunction("pg_nextoid", [{ args: [(regclass$1), (name$1), (regclass$1)], ret: (oid$1), isOperator: false }], args);
}
function pgNotificationQueueUsage(...args) {
    return sqlFunction("pg_notification_queue_usage", [{ args: [], ret: (default_1$6), isOperator: false }], args);
}
function pgNotify(...args) {
    return sqlFunction("pg_notify", [{ args: [(default_1$1), (default_1$1)], ret: (_void), isOperator: false }], args);
}
function pgOpclassIsVisible(...args) {
    return sqlFunction("pg_opclass_is_visible", [{ args: [(oid$1)], ret: (default_1$8), isOperator: false }], args);
}
function pgOperatorIsVisible(...args) {
    return sqlFunction("pg_operator_is_visible", [{ args: [(oid$1)], ret: (default_1$8), isOperator: false }], args);
}
function pgOpfamilyIsVisible(...args) {
    return sqlFunction("pg_opfamily_is_visible", [{ args: [(oid$1)], ret: (default_1$8), isOperator: false }], args);
}
function pgOptionsToTable(...args) {
    return sqlFunction("pg_options_to_table", [{ args: [Array$1.of((default_1$1))], ret: Setof.ofSchema({ option_name: (default_1$1), option_value: (default_1$1) }), isOperator: false }], args);
}
function pgPartitionAncestors(...args) {
    return sqlFunction("pg_partition_ancestors", [{ args: [(regclass$1)], ret: Setof.ofSchema({ relid: (regclass$1) }), isOperator: false }], args);
}
function pgPartitionRoot(...args) {
    return sqlFunction("pg_partition_root", [{ args: [(regclass$1)], ret: (regclass$1), isOperator: false }], args);
}
function pgPartitionTree(...args) {
    return sqlFunction("pg_partition_tree", [{ args: [(regclass$1)], ret: Setof.ofSchema({ relid: (regclass$1), parentrelid: (regclass$1), isleaf: (default_1$8), level: (default_1$4) }), isOperator: false }], args);
}
function pgPostmasterStartTime(...args) {
    return sqlFunction("pg_postmaster_start_time", [{ args: [], ret: (timestamptz$1), isOperator: false }], args);
}
function pgPreparedStatement(...args) {
    return sqlFunction("pg_prepared_statement", [{ args: [], ret: Setof.ofSchema({ name: (default_1$1), statement: (default_1$1), prepare_time: (timestamptz$1), parameter_types: Array$1.of((regtype)), result_types: Array$1.of((regtype)), from_sql: (default_1$8), generic_plans: (default_1$3), custom_plans: (default_1$3) }), isOperator: false }], args);
}
function pgPreparedXact(...args) {
    return sqlFunction("pg_prepared_xact", [{ args: [], ret: Setof.ofSchema({ transaction: (xid$1), gid: (default_1$1), prepared: (timestamptz$1), ownerid: (oid$1), dbid: (oid$1) }), isOperator: false }], args);
}
function pgPromote(...args) {
    return sqlFunction("pg_promote", [{ args: [(default_1$8), (default_1$4)], ret: (default_1$8), isOperator: false }], args);
}
function pgReadBinaryFile(...args) {
    return sqlFunction("pg_read_binary_file", [{ args: [(default_1$1)], ret: (bytea), isOperator: false }, { args: [(default_1$1), (default_1$8)], ret: (bytea), isOperator: false }, { args: [(default_1$1), (default_1$3), (default_1$3)], ret: (bytea), isOperator: false }, { args: [(default_1$1), (default_1$3), (default_1$3), (default_1$8)], ret: (bytea), isOperator: false }], args);
}
function pgReadFile(...args) {
    return sqlFunction("pg_read_file", [{ args: [(default_1$1)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$8)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$3), (default_1$3)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$3), (default_1$3), (default_1$8)], ret: (default_1$1), isOperator: false }], args);
}
function pgRelationFilenode(...args) {
    return sqlFunction("pg_relation_filenode", [{ args: [(regclass$1)], ret: (oid$1), isOperator: false }], args);
}
function pgRelationFilepath(...args) {
    return sqlFunction("pg_relation_filepath", [{ args: [(regclass$1)], ret: (default_1$1), isOperator: false }], args);
}
function pgRelationIsPublishable(...args) {
    return sqlFunction("pg_relation_is_publishable", [{ args: [(regclass$1)], ret: (default_1$8), isOperator: false }], args);
}
function pgRelationIsUpdatable(...args) {
    return sqlFunction("pg_relation_is_updatable", [{ args: [(regclass$1), (default_1$8)], ret: (default_1$4), isOperator: false }], args);
}
function pgRelationSize(...args) {
    return sqlFunction("pg_relation_size", [{ args: [(regclass$1)], ret: (default_1$3), isOperator: false }, { args: [(regclass$1), (default_1$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgReloadConf(...args) {
    return sqlFunction("pg_reload_conf", [{ args: [], ret: (default_1$8), isOperator: false }], args);
}
function pgReplicationOriginAdvance(...args) {
    return sqlFunction("pg_replication_origin_advance", [{ args: [(default_1$1), (pg_lsn)], ret: (_void), isOperator: false }], args);
}
function pgReplicationOriginCreate(...args) {
    return sqlFunction("pg_replication_origin_create", [{ args: [(default_1$1)], ret: (oid$1), isOperator: false }], args);
}
function pgReplicationOriginDrop(...args) {
    return sqlFunction("pg_replication_origin_drop", [{ args: [(default_1$1)], ret: (_void), isOperator: false }], args);
}
function pgReplicationOriginOid(...args) {
    return sqlFunction("pg_replication_origin_oid", [{ args: [(default_1$1)], ret: (oid$1), isOperator: false }], args);
}
function pgReplicationOriginProgress(...args) {
    return sqlFunction("pg_replication_origin_progress", [{ args: [(default_1$1), (default_1$8)], ret: (pg_lsn), isOperator: false }], args);
}
function pgReplicationOriginSessionIsSetup(...args) {
    return sqlFunction("pg_replication_origin_session_is_setup", [{ args: [], ret: (default_1$8), isOperator: false }], args);
}
function pgReplicationOriginSessionProgress(...args) {
    return sqlFunction("pg_replication_origin_session_progress", [{ args: [(default_1$8)], ret: (pg_lsn), isOperator: false }], args);
}
function pgReplicationOriginSessionReset(...args) {
    return sqlFunction("pg_replication_origin_session_reset", [{ args: [], ret: (_void), isOperator: false }], args);
}
function pgReplicationOriginSessionSetup(...args) {
    return sqlFunction("pg_replication_origin_session_setup", [{ args: [(default_1$1)], ret: (_void), isOperator: false }], args);
}
function pgReplicationOriginXactReset(...args) {
    return sqlFunction("pg_replication_origin_xact_reset", [{ args: [], ret: (_void), isOperator: false }], args);
}
function pgReplicationOriginXactSetup(...args) {
    return sqlFunction("pg_replication_origin_xact_setup", [{ args: [(pg_lsn), (timestamptz$1)], ret: (_void), isOperator: false }], args);
}
function pgReplicationSlotAdvance(...args) {
    return sqlFunction("pg_replication_slot_advance", [{ args: [(name$1), (pg_lsn)], ret: Record.of({ slot_name: (name$1), end_lsn: (pg_lsn) }), isOperator: false }], args);
}
function pgRotateLogfile(...args) {
    return sqlFunction("pg_rotate_logfile", [{ args: [], ret: (default_1$8), isOperator: false }], args);
}
function pgSafeSnapshotBlockingPids(...args) {
    return sqlFunction("pg_safe_snapshot_blocking_pids", [{ args: [(default_1$4)], ret: Array$1.of((default_1$4)), isOperator: false }], args);
}
function pgSequenceLastValue(...args) {
    return sqlFunction("pg_sequence_last_value", [{ args: [(regclass$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgSequenceParameters(...args) {
    return sqlFunction("pg_sequence_parameters", [{ args: [(oid$1)], ret: Record.of({ start_value: (default_1$3), minimum_value: (default_1$3), maximum_value: (default_1$3), increment: (default_1$3), cycle_option: (default_1$8), cache_size: (default_1$3), data_type: (oid$1) }), isOperator: false }], args);
}
function pgSettingsGetFlags(...args) {
    return sqlFunction("pg_settings_get_flags", [{ args: [(default_1$1)], ret: Array$1.of((default_1$1)), isOperator: false }], args);
}
function pgShowAllFileSettings(...args) {
    return sqlFunction("pg_show_all_file_settings", [{ args: [], ret: Setof.ofSchema({ sourcefile: (default_1$1), sourceline: (default_1$4), seqno: (default_1$4), name: (default_1$1), setting: (default_1$1), applied: (default_1$8), error: (default_1$1) }), isOperator: false }], args);
}
function pgShowAllSettings(...args) {
    return sqlFunction("pg_show_all_settings", [{ args: [], ret: Setof.ofSchema({ name: (default_1$1), setting: (default_1$1), unit: (default_1$1), category: (default_1$1), short_desc: (default_1$1), extra_desc: (default_1$1), context: (default_1$1), vartype: (default_1$1), source: (default_1$1), min_val: (default_1$1), max_val: (default_1$1), enumvals: Array$1.of((default_1$1)), boot_val: (default_1$1), reset_val: (default_1$1), sourcefile: (default_1$1), sourceline: (default_1$4), pending_restart: (default_1$8) }), isOperator: false }], args);
}
function pgShowReplicationOriginStatus(...args) {
    return sqlFunction("pg_show_replication_origin_status", [{ args: [], ret: Setof.ofSchema({ local_id: (oid$1), external_id: (default_1$1), remote_lsn: (pg_lsn), local_lsn: (pg_lsn) }), isOperator: false }], args);
}
function pgSizeBytes(...args) {
    return sqlFunction("pg_size_bytes", [{ args: [(default_1$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgSizePretty(...args) {
    return sqlFunction("pg_size_pretty", [{ args: [(default_1$3)], ret: (default_1$1), isOperator: false }, { args: [(default_1$2)], ret: (default_1$1), isOperator: false }], args);
}
function pgSleep(...args) {
    return sqlFunction("pg_sleep", [{ args: [(default_1$6)], ret: (_void), isOperator: false }], args);
}
function pgSleepFor(...args) {
    return sqlFunction("pg_sleep_for", [{ args: [(interval$1)], ret: (_void), isOperator: false }], args);
}
function pgSleepUntil(...args) {
    return sqlFunction("pg_sleep_until", [{ args: [(timestamptz$1)], ret: (_void), isOperator: false }], args);
}
function pgSnapshotXip(...args) {
    return sqlFunction("pg_snapshot_xip", [{ args: [(pg_snapshot)], ret: Setof.ofSchema({}), isOperator: false }], args);
}
function pgSnapshotXmax(...args) {
    return sqlFunction("pg_snapshot_xmax", [{ args: [(pg_snapshot)], ret: (xid8), isOperator: false }], args);
}
function pgSplitWalfileName(...args) {
    return sqlFunction("pg_split_walfile_name", [{ args: [(default_1$1)], ret: Record.of({ segment_number: (default_1$2), timeline_id: (default_1$3) }), isOperator: false }], args);
}
function pgStatClearSnapshot(...args) {
    return sqlFunction("pg_stat_clear_snapshot", [{ args: [], ret: (_void), isOperator: false }], args);
}
function pgStatFile(...args) {
    return sqlFunction("pg_stat_file", [{ args: [(default_1$1)], ret: Record.of({ size: (default_1$3), access: (timestamptz$1), modification: (timestamptz$1), change: (timestamptz$1), creation: (timestamptz$1), isdir: (default_1$8) }), isOperator: false }, { args: [(default_1$1), (default_1$8)], ret: Record.of({ size: (default_1$3), access: (timestamptz$1), modification: (timestamptz$1), change: (timestamptz$1), creation: (timestamptz$1), isdir: (default_1$8) }), isOperator: false }], args);
}
function pgStatForceNextFlush(...args) {
    return sqlFunction("pg_stat_force_next_flush", [{ args: [], ret: (_void), isOperator: false }], args);
}
function pgStatGetActivity(...args) {
    return sqlFunction("pg_stat_get_activity", [{ args: [(default_1$4)], ret: Setof.ofSchema({ datid: (oid$1), pid: (default_1$4), usesysid: (oid$1), application_name: (default_1$1), state: (default_1$1), query: (default_1$1), wait_event_type: (default_1$1), wait_event: (default_1$1), xact_start: (timestamptz$1), query_start: (timestamptz$1), backend_start: (timestamptz$1), state_change: (timestamptz$1), client_addr: (inet), client_hostname: (default_1$1), client_port: (default_1$4), backend_xid: (xid$1), backend_xmin: (xid$1), backend_type: (default_1$1), ssl: (default_1$8), sslversion: (default_1$1), sslcipher: (default_1$1), sslbits: (default_1$4), ssl_client_dn: (default_1$1), ssl_client_serial: (default_1$2), ssl_issuer_dn: (default_1$1), gss_auth: (default_1$8), gss_princ: (default_1$1), gss_enc: (default_1$8), gss_delegation: (default_1$8), leader_pid: (default_1$4), query_id: (default_1$3) }), isOperator: false }], args);
}
function pgStatGetAnalyzeCount(...args) {
    return sqlFunction("pg_stat_get_analyze_count", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetArchiver(...args) {
    return sqlFunction("pg_stat_get_archiver", [{ args: [], ret: Record.of({ archived_count: (default_1$3), last_archived_wal: (default_1$1), last_archived_time: (timestamptz$1), failed_count: (default_1$3), last_failed_wal: (default_1$1), last_failed_time: (timestamptz$1), stats_reset: (timestamptz$1) }), isOperator: false }], args);
}
function pgStatGetAutoanalyzeCount(...args) {
    return sqlFunction("pg_stat_get_autoanalyze_count", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetAutovacuumCount(...args) {
    return sqlFunction("pg_stat_get_autovacuum_count", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetBackendActivity(...args) {
    return sqlFunction("pg_stat_get_backend_activity", [{ args: [(default_1$4)], ret: (default_1$1), isOperator: false }], args);
}
function pgStatGetBackendActivityStart(...args) {
    return sqlFunction("pg_stat_get_backend_activity_start", [{ args: [(default_1$4)], ret: (timestamptz$1), isOperator: false }], args);
}
function pgStatGetBackendClientAddr(...args) {
    return sqlFunction("pg_stat_get_backend_client_addr", [{ args: [(default_1$4)], ret: (inet), isOperator: false }], args);
}
function pgStatGetBackendClientPort(...args) {
    return sqlFunction("pg_stat_get_backend_client_port", [{ args: [(default_1$4)], ret: (default_1$4), isOperator: false }], args);
}
function pgStatGetBackendDbid(...args) {
    return sqlFunction("pg_stat_get_backend_dbid", [{ args: [(default_1$4)], ret: (oid$1), isOperator: false }], args);
}
function pgStatGetBackendIdset(...args) {
    return sqlFunction("pg_stat_get_backend_idset", [{ args: [], ret: Setof.ofSchema({}), isOperator: false }], args);
}
function pgStatGetBackendPid(...args) {
    return sqlFunction("pg_stat_get_backend_pid", [{ args: [(default_1$4)], ret: (default_1$4), isOperator: false }], args);
}
function pgStatGetBackendStart(...args) {
    return sqlFunction("pg_stat_get_backend_start", [{ args: [(default_1$4)], ret: (timestamptz$1), isOperator: false }], args);
}
function pgStatGetBackendSubxact(...args) {
    return sqlFunction("pg_stat_get_backend_subxact", [{ args: [(default_1$4)], ret: Record.of({ subxact_count: (default_1$4), subxact_overflowed: (default_1$8) }), isOperator: false }], args);
}
function pgStatGetBackendUserid(...args) {
    return sqlFunction("pg_stat_get_backend_userid", [{ args: [(default_1$4)], ret: (oid$1), isOperator: false }], args);
}
function pgStatGetBackendWaitEvent(...args) {
    return sqlFunction("pg_stat_get_backend_wait_event", [{ args: [(default_1$4)], ret: (default_1$1), isOperator: false }], args);
}
function pgStatGetBackendWaitEventType(...args) {
    return sqlFunction("pg_stat_get_backend_wait_event_type", [{ args: [(default_1$4)], ret: (default_1$1), isOperator: false }], args);
}
function pgStatGetBackendXactStart(...args) {
    return sqlFunction("pg_stat_get_backend_xact_start", [{ args: [(default_1$4)], ret: (timestamptz$1), isOperator: false }], args);
}
function pgStatGetBgwriterBufWrittenClean(...args) {
    return sqlFunction("pg_stat_get_bgwriter_buf_written_clean", [{ args: [], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetBgwriterMaxwrittenClean(...args) {
    return sqlFunction("pg_stat_get_bgwriter_maxwritten_clean", [{ args: [], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetBgwriterStatResetTime(...args) {
    return sqlFunction("pg_stat_get_bgwriter_stat_reset_time", [{ args: [], ret: (timestamptz$1), isOperator: false }], args);
}
function pgStatGetBlocksFetched(...args) {
    return sqlFunction("pg_stat_get_blocks_fetched", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetBlocksHit(...args) {
    return sqlFunction("pg_stat_get_blocks_hit", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetBufAlloc(...args) {
    return sqlFunction("pg_stat_get_buf_alloc", [{ args: [], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetCheckpointerBuffersWritten(...args) {
    return sqlFunction("pg_stat_get_checkpointer_buffers_written", [{ args: [], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetCheckpointerNumRequested(...args) {
    return sqlFunction("pg_stat_get_checkpointer_num_requested", [{ args: [], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetCheckpointerNumTimed(...args) {
    return sqlFunction("pg_stat_get_checkpointer_num_timed", [{ args: [], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetCheckpointerRestartpointsPerformed(...args) {
    return sqlFunction("pg_stat_get_checkpointer_restartpoints_performed", [{ args: [], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetCheckpointerRestartpointsRequested(...args) {
    return sqlFunction("pg_stat_get_checkpointer_restartpoints_requested", [{ args: [], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetCheckpointerRestartpointsTimed(...args) {
    return sqlFunction("pg_stat_get_checkpointer_restartpoints_timed", [{ args: [], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetCheckpointerStatResetTime(...args) {
    return sqlFunction("pg_stat_get_checkpointer_stat_reset_time", [{ args: [], ret: (timestamptz$1), isOperator: false }], args);
}
function pgStatGetCheckpointerSyncTime(...args) {
    return sqlFunction("pg_stat_get_checkpointer_sync_time", [{ args: [], ret: (default_1$6), isOperator: false }], args);
}
function pgStatGetCheckpointerWriteTime(...args) {
    return sqlFunction("pg_stat_get_checkpointer_write_time", [{ args: [], ret: (default_1$6), isOperator: false }], args);
}
function pgStatGetDbActiveTime(...args) {
    return sqlFunction("pg_stat_get_db_active_time", [{ args: [(oid$1)], ret: (default_1$6), isOperator: false }], args);
}
function pgStatGetDbBlkReadTime(...args) {
    return sqlFunction("pg_stat_get_db_blk_read_time", [{ args: [(oid$1)], ret: (default_1$6), isOperator: false }], args);
}
function pgStatGetDbBlkWriteTime(...args) {
    return sqlFunction("pg_stat_get_db_blk_write_time", [{ args: [(oid$1)], ret: (default_1$6), isOperator: false }], args);
}
function pgStatGetDbBlocksFetched(...args) {
    return sqlFunction("pg_stat_get_db_blocks_fetched", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetDbBlocksHit(...args) {
    return sqlFunction("pg_stat_get_db_blocks_hit", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetDbChecksumFailures(...args) {
    return sqlFunction("pg_stat_get_db_checksum_failures", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetDbChecksumLastFailure(...args) {
    return sqlFunction("pg_stat_get_db_checksum_last_failure", [{ args: [(oid$1)], ret: (timestamptz$1), isOperator: false }], args);
}
function pgStatGetDbConflictAll(...args) {
    return sqlFunction("pg_stat_get_db_conflict_all", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetDbConflictLock(...args) {
    return sqlFunction("pg_stat_get_db_conflict_lock", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetDbConflictLogicalslot(...args) {
    return sqlFunction("pg_stat_get_db_conflict_logicalslot", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetDbConflictSnapshot(...args) {
    return sqlFunction("pg_stat_get_db_conflict_snapshot", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetDbConflictStartupDeadlock(...args) {
    return sqlFunction("pg_stat_get_db_conflict_startup_deadlock", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetDbConflictTablespace(...args) {
    return sqlFunction("pg_stat_get_db_conflict_tablespace", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetDbDeadlocks(...args) {
    return sqlFunction("pg_stat_get_db_deadlocks", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetDbIdleInTransactionTime(...args) {
    return sqlFunction("pg_stat_get_db_idle_in_transaction_time", [{ args: [(oid$1)], ret: (default_1$6), isOperator: false }], args);
}
function pgStatGetDbNumbackends(...args) {
    return sqlFunction("pg_stat_get_db_numbackends", [{ args: [(oid$1)], ret: (default_1$4), isOperator: false }], args);
}
function pgStatGetDbSessionTime(...args) {
    return sqlFunction("pg_stat_get_db_session_time", [{ args: [(oid$1)], ret: (default_1$6), isOperator: false }], args);
}
function pgStatGetDbSessions(...args) {
    return sqlFunction("pg_stat_get_db_sessions", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetDbSessionsAbandoned(...args) {
    return sqlFunction("pg_stat_get_db_sessions_abandoned", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetDbSessionsFatal(...args) {
    return sqlFunction("pg_stat_get_db_sessions_fatal", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetDbSessionsKilled(...args) {
    return sqlFunction("pg_stat_get_db_sessions_killed", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetDbStatResetTime(...args) {
    return sqlFunction("pg_stat_get_db_stat_reset_time", [{ args: [(oid$1)], ret: (timestamptz$1), isOperator: false }], args);
}
function pgStatGetDbTempBytes(...args) {
    return sqlFunction("pg_stat_get_db_temp_bytes", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetDbTempFiles(...args) {
    return sqlFunction("pg_stat_get_db_temp_files", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetDbTuplesDeleted(...args) {
    return sqlFunction("pg_stat_get_db_tuples_deleted", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetDbTuplesFetched(...args) {
    return sqlFunction("pg_stat_get_db_tuples_fetched", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetDbTuplesInserted(...args) {
    return sqlFunction("pg_stat_get_db_tuples_inserted", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetDbTuplesReturned(...args) {
    return sqlFunction("pg_stat_get_db_tuples_returned", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetDbTuplesUpdated(...args) {
    return sqlFunction("pg_stat_get_db_tuples_updated", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetDbXactCommit(...args) {
    return sqlFunction("pg_stat_get_db_xact_commit", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetDbXactRollback(...args) {
    return sqlFunction("pg_stat_get_db_xact_rollback", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetDeadTuples(...args) {
    return sqlFunction("pg_stat_get_dead_tuples", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetFunctionCalls(...args) {
    return sqlFunction("pg_stat_get_function_calls", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetFunctionSelfTime(...args) {
    return sqlFunction("pg_stat_get_function_self_time", [{ args: [(oid$1)], ret: (default_1$6), isOperator: false }], args);
}
function pgStatGetFunctionTotalTime(...args) {
    return sqlFunction("pg_stat_get_function_total_time", [{ args: [(oid$1)], ret: (default_1$6), isOperator: false }], args);
}
function pgStatGetInsSinceVacuum(...args) {
    return sqlFunction("pg_stat_get_ins_since_vacuum", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetIo(...args) {
    return sqlFunction("pg_stat_get_io", [{ args: [], ret: Setof.ofSchema({ backend_type: (default_1$1), object: (default_1$1), context: (default_1$1), reads: (default_1$3), read_time: (default_1$6), writes: (default_1$3), write_time: (default_1$6), writebacks: (default_1$3), writeback_time: (default_1$6), extends: (default_1$3), extend_time: (default_1$6), op_bytes: (default_1$3), hits: (default_1$3), evictions: (default_1$3), reuses: (default_1$3), fsyncs: (default_1$3), fsync_time: (default_1$6), stats_reset: (timestamptz$1) }), isOperator: false }], args);
}
function pgStatGetLastAnalyzeTime(...args) {
    return sqlFunction("pg_stat_get_last_analyze_time", [{ args: [(oid$1)], ret: (timestamptz$1), isOperator: false }], args);
}
function pgStatGetLastAutoanalyzeTime(...args) {
    return sqlFunction("pg_stat_get_last_autoanalyze_time", [{ args: [(oid$1)], ret: (timestamptz$1), isOperator: false }], args);
}
function pgStatGetLastAutovacuumTime(...args) {
    return sqlFunction("pg_stat_get_last_autovacuum_time", [{ args: [(oid$1)], ret: (timestamptz$1), isOperator: false }], args);
}
function pgStatGetLastVacuumTime(...args) {
    return sqlFunction("pg_stat_get_last_vacuum_time", [{ args: [(oid$1)], ret: (timestamptz$1), isOperator: false }], args);
}
function pgStatGetLastscan(...args) {
    return sqlFunction("pg_stat_get_lastscan", [{ args: [(oid$1)], ret: (timestamptz$1), isOperator: false }], args);
}
function pgStatGetLiveTuples(...args) {
    return sqlFunction("pg_stat_get_live_tuples", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetModSinceAnalyze(...args) {
    return sqlFunction("pg_stat_get_mod_since_analyze", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetNumscans(...args) {
    return sqlFunction("pg_stat_get_numscans", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetProgressInfo(...args) {
    return sqlFunction("pg_stat_get_progress_info", [{ args: [(default_1$1)], ret: Setof.ofSchema({ pid: (default_1$4), datid: (oid$1), relid: (oid$1), param1: (default_1$3), param2: (default_1$3), param3: (default_1$3), param4: (default_1$3), param5: (default_1$3), param6: (default_1$3), param7: (default_1$3), param8: (default_1$3), param9: (default_1$3), param10: (default_1$3), param11: (default_1$3), param12: (default_1$3), param13: (default_1$3), param14: (default_1$3), param15: (default_1$3), param16: (default_1$3), param17: (default_1$3), param18: (default_1$3), param19: (default_1$3), param20: (default_1$3) }), isOperator: false }], args);
}
function pgStatGetRecoveryPrefetch(...args) {
    return sqlFunction("pg_stat_get_recovery_prefetch", [{ args: [], ret: Setof.ofSchema({ stats_reset: (timestamptz$1), prefetch: (default_1$3), hit: (default_1$3), skip_init: (default_1$3), skip_new: (default_1$3), skip_fpw: (default_1$3), skip_rep: (default_1$3), wal_distance: (default_1$4), block_distance: (default_1$4), io_depth: (default_1$4) }), isOperator: false }], args);
}
function pgStatGetReplicationSlot(...args) {
    return sqlFunction("pg_stat_get_replication_slot", [{ args: [(default_1$1)], ret: Record.of({ slot_name: (default_1$1), spill_txns: (default_1$3), spill_count: (default_1$3), spill_bytes: (default_1$3), stream_txns: (default_1$3), stream_count: (default_1$3), stream_bytes: (default_1$3), total_txns: (default_1$3), total_bytes: (default_1$3), stats_reset: (timestamptz$1) }), isOperator: false }], args);
}
function pgStatGetSlru(...args) {
    return sqlFunction("pg_stat_get_slru", [{ args: [], ret: Setof.ofSchema({ name: (default_1$1), blks_zeroed: (default_1$3), blks_hit: (default_1$3), blks_read: (default_1$3), blks_written: (default_1$3), blks_exists: (default_1$3), flushes: (default_1$3), truncates: (default_1$3), stats_reset: (timestamptz$1) }), isOperator: false }], args);
}
function pgStatGetSnapshotTimestamp(...args) {
    return sqlFunction("pg_stat_get_snapshot_timestamp", [{ args: [], ret: (timestamptz$1), isOperator: false }], args);
}
function pgStatGetSubscription(...args) {
    return sqlFunction("pg_stat_get_subscription", [{ args: [(oid$1)], ret: Setof.ofSchema({ subid: (oid$1), relid: (oid$1), pid: (default_1$4), leader_pid: (default_1$4), received_lsn: (pg_lsn), last_msg_send_time: (timestamptz$1), last_msg_receipt_time: (timestamptz$1), latest_end_lsn: (pg_lsn), latest_end_time: (timestamptz$1), worker_type: (default_1$1) }), isOperator: false }], args);
}
function pgStatGetSubscriptionStats(...args) {
    return sqlFunction("pg_stat_get_subscription_stats", [{ args: [(oid$1)], ret: Record.of({ subid: (oid$1), apply_error_count: (default_1$3), sync_error_count: (default_1$3), stats_reset: (timestamptz$1) }), isOperator: false }], args);
}
function pgStatGetTuplesDeleted(...args) {
    return sqlFunction("pg_stat_get_tuples_deleted", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetTuplesFetched(...args) {
    return sqlFunction("pg_stat_get_tuples_fetched", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetTuplesHotUpdated(...args) {
    return sqlFunction("pg_stat_get_tuples_hot_updated", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetTuplesInserted(...args) {
    return sqlFunction("pg_stat_get_tuples_inserted", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetTuplesNewpageUpdated(...args) {
    return sqlFunction("pg_stat_get_tuples_newpage_updated", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetTuplesReturned(...args) {
    return sqlFunction("pg_stat_get_tuples_returned", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetTuplesUpdated(...args) {
    return sqlFunction("pg_stat_get_tuples_updated", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetVacuumCount(...args) {
    return sqlFunction("pg_stat_get_vacuum_count", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetWal(...args) {
    return sqlFunction("pg_stat_get_wal", [{ args: [], ret: Record.of({ wal_records: (default_1$3), wal_fpi: (default_1$3), wal_bytes: (default_1$2), wal_buffers_full: (default_1$3), wal_write: (default_1$3), wal_sync: (default_1$3), wal_write_time: (default_1$6), wal_sync_time: (default_1$6), stats_reset: (timestamptz$1) }), isOperator: false }], args);
}
function pgStatGetWalReceiver(...args) {
    return sqlFunction("pg_stat_get_wal_receiver", [{ args: [], ret: Record.of({ pid: (default_1$4), status: (default_1$1), receive_start_lsn: (pg_lsn), receive_start_tli: (default_1$4), written_lsn: (pg_lsn), flushed_lsn: (pg_lsn), received_tli: (default_1$4), last_msg_send_time: (timestamptz$1), last_msg_receipt_time: (timestamptz$1), latest_end_lsn: (pg_lsn), latest_end_time: (timestamptz$1), slot_name: (default_1$1), sender_host: (default_1$1), sender_port: (default_1$4), conninfo: (default_1$1) }), isOperator: false }], args);
}
function pgStatGetWalSenders(...args) {
    return sqlFunction("pg_stat_get_wal_senders", [{ args: [], ret: Setof.ofSchema({ pid: (default_1$4), state: (default_1$1), sent_lsn: (pg_lsn), write_lsn: (pg_lsn), flush_lsn: (pg_lsn), replay_lsn: (pg_lsn), write_lag: (interval$1), flush_lag: (interval$1), replay_lag: (interval$1), sync_priority: (default_1$4), sync_state: (default_1$1), reply_time: (timestamptz$1) }), isOperator: false }], args);
}
function pgStatGetXactBlocksFetched(...args) {
    return sqlFunction("pg_stat_get_xact_blocks_fetched", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetXactBlocksHit(...args) {
    return sqlFunction("pg_stat_get_xact_blocks_hit", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetXactFunctionCalls(...args) {
    return sqlFunction("pg_stat_get_xact_function_calls", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetXactFunctionSelfTime(...args) {
    return sqlFunction("pg_stat_get_xact_function_self_time", [{ args: [(oid$1)], ret: (default_1$6), isOperator: false }], args);
}
function pgStatGetXactFunctionTotalTime(...args) {
    return sqlFunction("pg_stat_get_xact_function_total_time", [{ args: [(oid$1)], ret: (default_1$6), isOperator: false }], args);
}
function pgStatGetXactNumscans(...args) {
    return sqlFunction("pg_stat_get_xact_numscans", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetXactTuplesDeleted(...args) {
    return sqlFunction("pg_stat_get_xact_tuples_deleted", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetXactTuplesFetched(...args) {
    return sqlFunction("pg_stat_get_xact_tuples_fetched", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetXactTuplesHotUpdated(...args) {
    return sqlFunction("pg_stat_get_xact_tuples_hot_updated", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetXactTuplesInserted(...args) {
    return sqlFunction("pg_stat_get_xact_tuples_inserted", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetXactTuplesNewpageUpdated(...args) {
    return sqlFunction("pg_stat_get_xact_tuples_newpage_updated", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetXactTuplesReturned(...args) {
    return sqlFunction("pg_stat_get_xact_tuples_returned", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatGetXactTuplesUpdated(...args) {
    return sqlFunction("pg_stat_get_xact_tuples_updated", [{ args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgStatHaveStats(...args) {
    return sqlFunction("pg_stat_have_stats", [{ args: [(default_1$1), (oid$1), (oid$1)], ret: (default_1$8), isOperator: false }], args);
}
function pgStatReset(...args) {
    return sqlFunction("pg_stat_reset", [{ args: [], ret: (_void), isOperator: false }], args);
}
function pgStatResetReplicationSlot(...args) {
    return sqlFunction("pg_stat_reset_replication_slot", [{ args: [(default_1$1)], ret: (_void), isOperator: false }], args);
}
function pgStatResetShared(...args) {
    return sqlFunction("pg_stat_reset_shared", [{ args: [(default_1$1)], ret: (_void), isOperator: false }], args);
}
function pgStatResetSingleFunctionCounters(...args) {
    return sqlFunction("pg_stat_reset_single_function_counters", [{ args: [(oid$1)], ret: (_void), isOperator: false }], args);
}
function pgStatResetSingleTableCounters(...args) {
    return sqlFunction("pg_stat_reset_single_table_counters", [{ args: [(oid$1)], ret: (_void), isOperator: false }], args);
}
function pgStatResetSlru(...args) {
    return sqlFunction("pg_stat_reset_slru", [{ args: [(default_1$1)], ret: (_void), isOperator: false }], args);
}
function pgStatResetSubscriptionStats(...args) {
    return sqlFunction("pg_stat_reset_subscription_stats", [{ args: [(oid$1)], ret: (_void), isOperator: false }], args);
}
function pgStatisticsObjIsVisible(...args) {
    return sqlFunction("pg_statistics_obj_is_visible", [{ args: [(oid$1)], ret: (default_1$8), isOperator: false }], args);
}
function pgStopMakingPinnedObjects(...args) {
    return sqlFunction("pg_stop_making_pinned_objects", [{ args: [], ret: (_void), isOperator: false }], args);
}
function pgSwitchWal(...args) {
    return sqlFunction("pg_switch_wal", [{ args: [], ret: (pg_lsn), isOperator: false }], args);
}
function pgSyncReplicationSlots(...args) {
    return sqlFunction("pg_sync_replication_slots", [{ args: [], ret: (_void), isOperator: false }], args);
}
function pgTableIsVisible(...args) {
    return sqlFunction("pg_table_is_visible", [{ args: [(oid$1)], ret: (default_1$8), isOperator: false }], args);
}
function pgTableSize(...args) {
    return sqlFunction("pg_table_size", [{ args: [(regclass$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgTablespaceDatabases(...args) {
    return sqlFunction("pg_tablespace_databases", [{ args: [(oid$1)], ret: Setof.ofSchema({}), isOperator: false }], args);
}
function pgTablespaceLocation(...args) {
    return sqlFunction("pg_tablespace_location", [{ args: [(oid$1)], ret: (default_1$1), isOperator: false }], args);
}
function pgTablespaceSize(...args) {
    return sqlFunction("pg_tablespace_size", [{ args: [(name$1)], ret: (default_1$3), isOperator: false }, { args: [(oid$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgTerminateBackend(...args) {
    return sqlFunction("pg_terminate_backend", [{ args: [(default_1$4), (default_1$3)], ret: (default_1$8), isOperator: false }], args);
}
function pgTimezoneAbbrevs(...args) {
    return sqlFunction("pg_timezone_abbrevs", [{ args: [], ret: Setof.ofSchema({ abbrev: (default_1$1), utc_offset: (interval$1), is_dst: (default_1$8) }), isOperator: false }], args);
}
function pgTimezoneNames(...args) {
    return sqlFunction("pg_timezone_names", [{ args: [], ret: Setof.ofSchema({ name: (default_1$1), abbrev: (default_1$1), utc_offset: (interval$1), is_dst: (default_1$8) }), isOperator: false }], args);
}
function pgTotalRelationSize(...args) {
    return sqlFunction("pg_total_relation_size", [{ args: [(regclass$1)], ret: (default_1$3), isOperator: false }], args);
}
function pgTriggerDepth(...args) {
    return sqlFunction("pg_trigger_depth", [{ args: [], ret: (default_1$4), isOperator: false }], args);
}
function pgTryAdvisoryLock(...args) {
    return sqlFunction("pg_try_advisory_lock", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$8), isOperator: false }, { args: [(default_1$3)], ret: (default_1$8), isOperator: false }], args);
}
function pgTryAdvisoryLockShared(...args) {
    return sqlFunction("pg_try_advisory_lock_shared", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$8), isOperator: false }, { args: [(default_1$3)], ret: (default_1$8), isOperator: false }], args);
}
function pgTryAdvisoryXactLock(...args) {
    return sqlFunction("pg_try_advisory_xact_lock", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$8), isOperator: false }, { args: [(default_1$3)], ret: (default_1$8), isOperator: false }], args);
}
function pgTryAdvisoryXactLockShared(...args) {
    return sqlFunction("pg_try_advisory_xact_lock_shared", [{ args: [(default_1$4), (default_1$4)], ret: (default_1$8), isOperator: false }, { args: [(default_1$3)], ret: (default_1$8), isOperator: false }], args);
}
function pgTsConfigIsVisible(...args) {
    return sqlFunction("pg_ts_config_is_visible", [{ args: [(oid$1)], ret: (default_1$8), isOperator: false }], args);
}
function pgTsDictIsVisible(...args) {
    return sqlFunction("pg_ts_dict_is_visible", [{ args: [(oid$1)], ret: (default_1$8), isOperator: false }], args);
}
function pgTsParserIsVisible(...args) {
    return sqlFunction("pg_ts_parser_is_visible", [{ args: [(oid$1)], ret: (default_1$8), isOperator: false }], args);
}
function pgTsTemplateIsVisible(...args) {
    return sqlFunction("pg_ts_template_is_visible", [{ args: [(oid$1)], ret: (default_1$8), isOperator: false }], args);
}
function pgTypeIsVisible(...args) {
    return sqlFunction("pg_type_is_visible", [{ args: [(oid$1)], ret: (default_1$8), isOperator: false }], args);
}
function pgTypeof(...args) {
    return sqlFunction("pg_typeof", [{ args: [(Any)], ret: (regtype), isOperator: false }], args);
}
function pgVisibleInSnapshot(...args) {
    return sqlFunction("pg_visible_in_snapshot", [{ args: [(xid8), (pg_snapshot)], ret: (default_1$8), isOperator: false }], args);
}
function pgWalLsnDiff(...args) {
    return sqlFunction("pg_wal_lsn_diff", [{ args: [(pg_lsn), (pg_lsn)], ret: (default_1$2), isOperator: false }], args);
}
function pgWalReplayPause(...args) {
    return sqlFunction("pg_wal_replay_pause", [{ args: [], ret: (_void), isOperator: false }], args);
}
function pgWalReplayResume(...args) {
    return sqlFunction("pg_wal_replay_resume", [{ args: [], ret: (_void), isOperator: false }], args);
}
function pgWalSummaryContents(...args) {
    return sqlFunction("pg_wal_summary_contents", [{ args: [(default_1$3), (pg_lsn), (pg_lsn)], ret: Setof.ofSchema({ relfilenode: (oid$1), reltablespace: (oid$1), reldatabase: (oid$1), relforknumber: (default_1$5), relblocknumber: (default_1$3), is_limit_block: (default_1$8) }), isOperator: false }], args);
}
function pgWalfileName(...args) {
    return sqlFunction("pg_walfile_name", [{ args: [(pg_lsn)], ret: (default_1$1), isOperator: false }], args);
}
function pgWalfileNameOffset(...args) {
    return sqlFunction("pg_walfile_name_offset", [{ args: [(pg_lsn)], ret: Record.of({ file_name: (default_1$1), file_offset: (default_1$4) }), isOperator: false }], args);
}
function pgXactCommitTimestamp(...args) {
    return sqlFunction("pg_xact_commit_timestamp", [{ args: [(xid$1)], ret: (timestamptz$1), isOperator: false }], args);
}
function pgXactStatus(...args) {
    return sqlFunction("pg_xact_status", [{ args: [(xid8)], ret: (default_1$1), isOperator: false }], args);
}
function phrasetoTsquery(...args) {
    return sqlFunction("phraseto_tsquery", [{ args: [(regconfig), (default_1$1)], ret: (tsquery), isOperator: false }, { args: [(default_1$1)], ret: (tsquery), isOperator: false }], args);
}
function pi(...args) {
    return sqlFunction("pi", [{ args: [], ret: (default_1$6), isOperator: false }], args);
}
function plaintoTsquery(...args) {
    return sqlFunction("plainto_tsquery", [{ args: [(regconfig), (default_1$1)], ret: (tsquery), isOperator: false }, { args: [(default_1$1)], ret: (tsquery), isOperator: false }], args);
}
function plpgsqlCallHandler(...args) {
    return sqlFunction("plpgsql_call_handler", [{ args: [], ret: (language_handler), isOperator: false }], args);
}
function plpgsqlValidator(...args) {
    return sqlFunction("plpgsql_validator", [{ args: [(oid$1)], ret: (_void), isOperator: false }], args);
}
function point(...args) {
    return sqlFunction("point", [{ args: [(box$1)], ret: (point$1), isOperator: false }, { args: [(circle$1)], ret: (point$1), isOperator: false }, { args: [(default_1$6), (default_1$6)], ret: (point$1), isOperator: false }, { args: [(lseg$1)], ret: (point$1), isOperator: false }, { args: [(polygon$1)], ret: (point$1), isOperator: false }], args);
}
function pointAbove(...args) {
    return sqlFunction("point_above", [{ args: [(point$1), (point$1)], ret: (default_1$8), isOperator: false }, { args: [(point$1), (point$1)], ret: (default_1$8), isOperator: false }], args);
}
function pointAdd(...args) {
    return sqlFunction("point_add", [{ args: [(point$1), (point$1)], ret: (point$1), isOperator: false }], args);
}
function pointBelow(...args) {
    return sqlFunction("point_below", [{ args: [(point$1), (point$1)], ret: (default_1$8), isOperator: false }, { args: [(point$1), (point$1)], ret: (default_1$8), isOperator: false }], args);
}
function pointDistance(...args) {
    return sqlFunction("point_distance", [{ args: [(point$1), (point$1)], ret: (default_1$6), isOperator: false }], args);
}
function pointDiv(...args) {
    return sqlFunction("point_div", [{ args: [(point$1), (point$1)], ret: (point$1), isOperator: false }], args);
}
function pointEq(...args) {
    return sqlFunction("point_eq", [{ args: [(point$1), (point$1)], ret: (default_1$8), isOperator: false }], args);
}
function pointHoriz(...args) {
    return sqlFunction("point_horiz", [{ args: [(point$1), (point$1)], ret: (default_1$8), isOperator: false }], args);
}
function pointLeft(...args) {
    return sqlFunction("point_left", [{ args: [(point$1), (point$1)], ret: (default_1$8), isOperator: false }], args);
}
function pointMul(...args) {
    return sqlFunction("point_mul", [{ args: [(point$1), (point$1)], ret: (point$1), isOperator: false }], args);
}
function pointNe(...args) {
    return sqlFunction("point_ne", [{ args: [(point$1), (point$1)], ret: (default_1$8), isOperator: false }], args);
}
function pointRight(...args) {
    return sqlFunction("point_right", [{ args: [(point$1), (point$1)], ret: (default_1$8), isOperator: false }], args);
}
function pointSub(...args) {
    return sqlFunction("point_sub", [{ args: [(point$1), (point$1)], ret: (point$1), isOperator: false }], args);
}
function pointVert(...args) {
    return sqlFunction("point_vert", [{ args: [(point$1), (point$1)], ret: (default_1$8), isOperator: false }], args);
}
function polyAbove(...args) {
    return sqlFunction("poly_above", [{ args: [(polygon$1), (polygon$1)], ret: (default_1$8), isOperator: false }], args);
}
function polyBelow(...args) {
    return sqlFunction("poly_below", [{ args: [(polygon$1), (polygon$1)], ret: (default_1$8), isOperator: false }], args);
}
function polyCenter(...args) {
    return sqlFunction("poly_center", [{ args: [(polygon$1)], ret: (point$1), isOperator: false }], args);
}
function polyContainPt(...args) {
    return sqlFunction("poly_contain_pt", [{ args: [(polygon$1), (point$1)], ret: (default_1$8), isOperator: false }], args);
}
function polyContained(...args) {
    return sqlFunction("poly_contained", [{ args: [(polygon$1), (polygon$1)], ret: (default_1$8), isOperator: false }], args);
}
function polyDistance(...args) {
    return sqlFunction("poly_distance", [{ args: [(polygon$1), (polygon$1)], ret: (default_1$6), isOperator: false }], args);
}
function polyLeft(...args) {
    return sqlFunction("poly_left", [{ args: [(polygon$1), (polygon$1)], ret: (default_1$8), isOperator: false }], args);
}
function polyNpoints(...args) {
    return sqlFunction("poly_npoints", [{ args: [(polygon$1)], ret: (default_1$4), isOperator: false }], args);
}
function polyOverabove(...args) {
    return sqlFunction("poly_overabove", [{ args: [(polygon$1), (polygon$1)], ret: (default_1$8), isOperator: false }], args);
}
function polyOverbelow(...args) {
    return sqlFunction("poly_overbelow", [{ args: [(polygon$1), (polygon$1)], ret: (default_1$8), isOperator: false }], args);
}
function polyOverlap(...args) {
    return sqlFunction("poly_overlap", [{ args: [(polygon$1), (polygon$1)], ret: (default_1$8), isOperator: false }], args);
}
function polyOverleft(...args) {
    return sqlFunction("poly_overleft", [{ args: [(polygon$1), (polygon$1)], ret: (default_1$8), isOperator: false }], args);
}
function polyOverright(...args) {
    return sqlFunction("poly_overright", [{ args: [(polygon$1), (polygon$1)], ret: (default_1$8), isOperator: false }], args);
}
function polyRight(...args) {
    return sqlFunction("poly_right", [{ args: [(polygon$1), (polygon$1)], ret: (default_1$8), isOperator: false }], args);
}
function polySame(...args) {
    return sqlFunction("poly_same", [{ args: [(polygon$1), (polygon$1)], ret: (default_1$8), isOperator: false }], args);
}
function polygon(...args) {
    return sqlFunction("polygon", [{ args: [(box$1)], ret: (polygon$1), isOperator: false }, { args: [(circle$1)], ret: (polygon$1), isOperator: false }, { args: [(default_1$4), (circle$1)], ret: (polygon$1), isOperator: false }, { args: [(path$1)], ret: (polygon$1), isOperator: false }], args);
}
function popen(...args) {
    return sqlFunction("popen", [{ args: [(path$1)], ret: (path$1), isOperator: false }], args);
}
function position(...args) {
    return sqlFunction("position", [{ args: [(bit$1), (bit$1)], ret: (default_1$4), isOperator: false }, { args: [(bytea), (bytea)], ret: (default_1$4), isOperator: false }, { args: [(default_1$1), (default_1$1)], ret: (default_1$4), isOperator: false }], args);
}
function postgresqlFdwValidator(...args) {
    return sqlFunction("postgresql_fdw_validator", [{ args: [Array$1.of((default_1$1)), (oid$1)], ret: (default_1$8), isOperator: false }], args);
}
function pow(...args) {
    return sqlFunction("pow", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }, { args: [(default_1$2), (default_1$2)], ret: (default_1$2), isOperator: false }], args);
}
function power(...args) {
    return sqlFunction("power", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }, { args: [(default_1$2), (default_1$2)], ret: (default_1$2), isOperator: false }], args);
}
function ptContainedCircle(...args) {
    return sqlFunction("pt_contained_circle", [{ args: [(point$1), (circle$1)], ret: (default_1$8), isOperator: false }], args);
}
function ptContainedPoly(...args) {
    return sqlFunction("pt_contained_poly", [{ args: [(point$1), (polygon$1)], ret: (default_1$8), isOperator: false }], args);
}
function queryToXml(...args) {
    return sqlFunction("query_to_xml", [{ args: [(default_1$1), (default_1$8), (default_1$8), (default_1$1)], ret: (xml$1), isOperator: false }], args);
}
function queryToXmlAndXmlschema(...args) {
    return sqlFunction("query_to_xml_and_xmlschema", [{ args: [(default_1$1), (default_1$8), (default_1$8), (default_1$1)], ret: (xml$1), isOperator: false }], args);
}
function queryToXmlschema(...args) {
    return sqlFunction("query_to_xmlschema", [{ args: [(default_1$1), (default_1$8), (default_1$8), (default_1$1)], ret: (xml$1), isOperator: false }], args);
}
function querytree(...args) {
    return sqlFunction("querytree", [{ args: [(tsquery)], ret: (default_1$1), isOperator: false }], args);
}
function quoteIdent(...args) {
    return sqlFunction("quote_ident", [{ args: [(default_1$1)], ret: (default_1$1), isOperator: false }], args);
}
function quoteLiteral(...args) {
    return sqlFunction("quote_literal", [({ T }) => ({ args: [T], ret: (default_1$1), isOperator: false }), { args: [(default_1$1)], ret: (default_1$1), isOperator: false }], args);
}
function quoteNullable(...args) {
    return sqlFunction("quote_nullable", [({ T }) => ({ args: [T], ret: (default_1$1), isOperator: false }), { args: [(default_1$1)], ret: (default_1$1), isOperator: false }], args);
}
function radians(...args) {
    return sqlFunction("radians", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function radius(...args) {
    return sqlFunction("radius", [{ args: [(circle$1)], ret: (default_1$6), isOperator: false }], args);
}
function random(...args) {
    return sqlFunction("random", [{ args: [], ret: (default_1$6), isOperator: false }, { args: [(default_1$4), (default_1$4)], ret: (default_1$4), isOperator: false }, { args: [(default_1$3), (default_1$3)], ret: (default_1$3), isOperator: false }, { args: [(default_1$2), (default_1$2)], ret: (default_1$2), isOperator: false }], args);
}
function randomNormal(...args) {
    return sqlFunction("random_normal", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function rangeAdjacent(...args) {
    return sqlFunction("range_adjacent", [{ args: [anyrange, anyrange], ret: (default_1$8), isOperator: false }], args);
}
function rangeAdjacentMultirange(...args) {
    return sqlFunction("range_adjacent_multirange", [{ args: [anyrange, anymultirange], ret: (default_1$8), isOperator: false }], args);
}
function rangeAfter(...args) {
    return sqlFunction("range_after", [{ args: [anyrange, anyrange], ret: (default_1$8), isOperator: false }], args);
}
function rangeAfterMultirange(...args) {
    return sqlFunction("range_after_multirange", [{ args: [anyrange, anymultirange], ret: (default_1$8), isOperator: false }], args);
}
function rangeAgg(...args) {
    return sqlFunction("range_agg", [{ args: [anymultirange], ret: anymultirange, isOperator: false }, { args: [anyrange], ret: anymultirange, isOperator: false }], args);
}
function rangeBefore(...args) {
    return sqlFunction("range_before", [{ args: [anyrange, anyrange], ret: (default_1$8), isOperator: false }], args);
}
function rangeBeforeMultirange(...args) {
    return sqlFunction("range_before_multirange", [{ args: [anyrange, anymultirange], ret: (default_1$8), isOperator: false }], args);
}
function rangeCmp(...args) {
    return sqlFunction("range_cmp", [{ args: [anyrange, anyrange], ret: (default_1$4), isOperator: false }], args);
}
function rangeContainedBy(...args) {
    return sqlFunction("range_contained_by", [{ args: [anyrange, anyrange], ret: (default_1$8), isOperator: false }], args);
}
function rangeContainedByMultirange(...args) {
    return sqlFunction("range_contained_by_multirange", [{ args: [anyrange, anymultirange], ret: (default_1$8), isOperator: false }], args);
}
function rangeContains(...args) {
    return sqlFunction("range_contains", [{ args: [anyrange, anyrange], ret: (default_1$8), isOperator: false }], args);
}
function rangeContainsElem(...args) {
    return sqlFunction("range_contains_elem", [({ T }) => ({ args: [anyrange, T], ret: (default_1$8), isOperator: false })], args);
}
function rangeContainsMultirange(...args) {
    return sqlFunction("range_contains_multirange", [{ args: [anyrange, anymultirange], ret: (default_1$8), isOperator: false }], args);
}
function rangeEq(...args) {
    return sqlFunction("range_eq", [{ args: [anyrange, anyrange], ret: (default_1$8), isOperator: false }], args);
}
function rangeGe(...args) {
    return sqlFunction("range_ge", [{ args: [anyrange, anyrange], ret: (default_1$8), isOperator: false }], args);
}
function rangeGt(...args) {
    return sqlFunction("range_gt", [{ args: [anyrange, anyrange], ret: (default_1$8), isOperator: false }], args);
}
function rangeIntersect(...args) {
    return sqlFunction("range_intersect", [{ args: [anyrange, anyrange], ret: anyrange, isOperator: false }], args);
}
function rangeIntersectAgg(...args) {
    return sqlFunction("range_intersect_agg", [{ args: [anymultirange], ret: anymultirange, isOperator: false }, { args: [anyrange], ret: anyrange, isOperator: false }], args);
}
function rangeIntersectAggTransfn(...args) {
    return sqlFunction("range_intersect_agg_transfn", [{ args: [anyrange, anyrange], ret: anyrange, isOperator: false }], args);
}
function rangeLe(...args) {
    return sqlFunction("range_le", [{ args: [anyrange, anyrange], ret: (default_1$8), isOperator: false }], args);
}
function rangeLt(...args) {
    return sqlFunction("range_lt", [{ args: [anyrange, anyrange], ret: (default_1$8), isOperator: false }], args);
}
function rangeMerge(...args) {
    return sqlFunction("range_merge", [{ args: [anymultirange], ret: anyrange, isOperator: false }, { args: [anyrange, anyrange], ret: anyrange, isOperator: false }], args);
}
function rangeMinus(...args) {
    return sqlFunction("range_minus", [{ args: [anyrange, anyrange], ret: anyrange, isOperator: false }], args);
}
function rangeNe(...args) {
    return sqlFunction("range_ne", [{ args: [anyrange, anyrange], ret: (default_1$8), isOperator: false }], args);
}
function rangeOverlaps(...args) {
    return sqlFunction("range_overlaps", [{ args: [anyrange, anyrange], ret: (default_1$8), isOperator: false }], args);
}
function rangeOverlapsMultirange(...args) {
    return sqlFunction("range_overlaps_multirange", [{ args: [anyrange, anymultirange], ret: (default_1$8), isOperator: false }], args);
}
function rangeOverleft(...args) {
    return sqlFunction("range_overleft", [{ args: [anyrange, anyrange], ret: (default_1$8), isOperator: false }], args);
}
function rangeOverleftMultirange(...args) {
    return sqlFunction("range_overleft_multirange", [{ args: [anyrange, anymultirange], ret: (default_1$8), isOperator: false }], args);
}
function rangeOverright(...args) {
    return sqlFunction("range_overright", [{ args: [anyrange, anyrange], ret: (default_1$8), isOperator: false }], args);
}
function rangeOverrightMultirange(...args) {
    return sqlFunction("range_overright_multirange", [{ args: [anyrange, anymultirange], ret: (default_1$8), isOperator: false }], args);
}
function rangeUnion(...args) {
    return sqlFunction("range_union", [{ args: [anyrange, anyrange], ret: anyrange, isOperator: false }], args);
}
function rank(...args) {
    return sqlFunction("rank", [{ args: [], ret: (default_1$3), isOperator: false }, { args: [(Any)], ret: (default_1$3), isOperator: false }], args);
}
function recordEq(...args) {
    return sqlFunction("record_eq", [({ R }) => ({ args: [Record.of(R), Record.of(R)], ret: (default_1$8), isOperator: false })], args);
}
function recordGe(...args) {
    return sqlFunction("record_ge", [({ R }) => ({ args: [Record.of(R), Record.of(R)], ret: (default_1$8), isOperator: false })], args);
}
function recordGt(...args) {
    return sqlFunction("record_gt", [({ R }) => ({ args: [Record.of(R), Record.of(R)], ret: (default_1$8), isOperator: false })], args);
}
function recordImageEq(...args) {
    return sqlFunction("record_image_eq", [({ R }) => ({ args: [Record.of(R), Record.of(R)], ret: (default_1$8), isOperator: false })], args);
}
function recordImageGe(...args) {
    return sqlFunction("record_image_ge", [({ R }) => ({ args: [Record.of(R), Record.of(R)], ret: (default_1$8), isOperator: false })], args);
}
function recordImageGt(...args) {
    return sqlFunction("record_image_gt", [({ R }) => ({ args: [Record.of(R), Record.of(R)], ret: (default_1$8), isOperator: false })], args);
}
function recordImageLe(...args) {
    return sqlFunction("record_image_le", [({ R }) => ({ args: [Record.of(R), Record.of(R)], ret: (default_1$8), isOperator: false })], args);
}
function recordImageLt(...args) {
    return sqlFunction("record_image_lt", [({ R }) => ({ args: [Record.of(R), Record.of(R)], ret: (default_1$8), isOperator: false })], args);
}
function recordImageNe(...args) {
    return sqlFunction("record_image_ne", [({ R }) => ({ args: [Record.of(R), Record.of(R)], ret: (default_1$8), isOperator: false })], args);
}
function recordLe(...args) {
    return sqlFunction("record_le", [({ R }) => ({ args: [Record.of(R), Record.of(R)], ret: (default_1$8), isOperator: false })], args);
}
function recordLt(...args) {
    return sqlFunction("record_lt", [({ R }) => ({ args: [Record.of(R), Record.of(R)], ret: (default_1$8), isOperator: false })], args);
}
function recordNe(...args) {
    return sqlFunction("record_ne", [({ R }) => ({ args: [Record.of(R), Record.of(R)], ret: (default_1$8), isOperator: false })], args);
}
function regclass(...args) {
    return sqlFunction("regclass", [{ args: [(default_1$1)], ret: (regclass$1), isOperator: false }], args);
}
function regexpCount(...args) {
    return sqlFunction("regexp_count", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$4), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$4)], ret: (default_1$4), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$4), (default_1$1)], ret: (default_1$4), isOperator: false }], args);
}
function regexpInstr(...args) {
    return sqlFunction("regexp_instr", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$4), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$4)], ret: (default_1$4), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$4), (default_1$4)], ret: (default_1$4), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$4), (default_1$4), (default_1$4)], ret: (default_1$4), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$4), (default_1$4), (default_1$4), (default_1$1)], ret: (default_1$4), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$4), (default_1$4), (default_1$4), (default_1$1), (default_1$4)], ret: (default_1$4), isOperator: false }], args);
}
function regexpLike(...args) {
    return sqlFunction("regexp_like", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function regexpMatch(...args) {
    return sqlFunction("regexp_match", [{ args: [(default_1$1), (default_1$1)], ret: Array$1.of((default_1$1)), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$1)], ret: Array$1.of((default_1$1)), isOperator: false }], args);
}
function regexpMatches(...args) {
    return sqlFunction("regexp_matches", [{ args: [(default_1$1), (default_1$1)], ret: Setof.ofSchema({}), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$1)], ret: Setof.ofSchema({}), isOperator: false }], args);
}
function regexpReplace(...args) {
    return sqlFunction("regexp_replace", [{ args: [(default_1$1), (default_1$1), (default_1$1)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$1), (default_1$4)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$1), (default_1$4), (default_1$4)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$1), (default_1$4), (default_1$4), (default_1$1)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$1), (default_1$1)], ret: (default_1$1), isOperator: false }], args);
}
function regexpSplitToArray(...args) {
    return sqlFunction("regexp_split_to_array", [{ args: [(default_1$1), (default_1$1)], ret: Array$1.of((default_1$1)), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$1)], ret: Array$1.of((default_1$1)), isOperator: false }], args);
}
function regexpSplitToTable(...args) {
    return sqlFunction("regexp_split_to_table", [{ args: [(default_1$1), (default_1$1)], ret: Setof.ofSchema({}), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$1)], ret: Setof.ofSchema({}), isOperator: false }], args);
}
function regexpSubstr(...args) {
    return sqlFunction("regexp_substr", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$4)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$4), (default_1$4)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$4), (default_1$4), (default_1$1)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$4), (default_1$4), (default_1$1), (default_1$4)], ret: (default_1$1), isOperator: false }], args);
}
function regrAvgx(...args) {
    return sqlFunction("regr_avgx", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function regrAvgy(...args) {
    return sqlFunction("regr_avgy", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function regrCount(...args) {
    return sqlFunction("regr_count", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$3), isOperator: false }], args);
}
function regrIntercept(...args) {
    return sqlFunction("regr_intercept", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function regrR2(...args) {
    return sqlFunction("regr_r2", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function regrSlope(...args) {
    return sqlFunction("regr_slope", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function regrSxx(...args) {
    return sqlFunction("regr_sxx", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function regrSxy(...args) {
    return sqlFunction("regr_sxy", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function regrSyy(...args) {
    return sqlFunction("regr_syy", [{ args: [(default_1$6), (default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function repeat(...args) {
    return sqlFunction("repeat", [{ args: [(default_1$1), (default_1$4)], ret: (default_1$1), isOperator: false }], args);
}
function replace(...args) {
    return sqlFunction("replace", [{ args: [(default_1$1), (default_1$1), (default_1$1)], ret: (default_1$1), isOperator: false }], args);
}
function reverse(...args) {
    return sqlFunction("reverse", [{ args: [(default_1$1)], ret: (default_1$1), isOperator: false }], args);
}
function right(...args) {
    return sqlFunction("right", [{ args: [(default_1$1), (default_1$4)], ret: (default_1$1), isOperator: false }], args);
}
function round(...args) {
    return sqlFunction("round", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }, { args: [(default_1$2)], ret: (default_1$2), isOperator: false }, { args: [(default_1$2), (default_1$4)], ret: (default_1$2), isOperator: false }], args);
}
function rowNumber(...args) {
    return sqlFunction("row_number", [{ args: [], ret: (default_1$3), isOperator: false }], args);
}
function rowSecurityActive(...args) {
    return sqlFunction("row_security_active", [{ args: [(oid$1)], ret: (default_1$8), isOperator: false }, { args: [(default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function rowToJson(...args) {
    return sqlFunction("row_to_json", [({ R }) => ({ args: [Record.of(R)], ret: (json), isOperator: false }), ({ R }) => ({ args: [Record.of(R), (default_1$8)], ret: (json), isOperator: false })], args);
}
function rpad(...args) {
    return sqlFunction("rpad", [{ args: [(default_1$1), (default_1$4)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$4), (default_1$1)], ret: (default_1$1), isOperator: false }], args);
}
function rtrim(...args) {
    return sqlFunction("rtrim", [{ args: [(bytea), (bytea)], ret: (bytea), isOperator: false }, { args: [(default_1$1)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$1)], ret: (default_1$1), isOperator: false }], args);
}
function satisfiesHashPartition(...args) {
    return sqlFunction("satisfies_hash_partition", [{ args: [(oid$1), (default_1$4), (default_1$4), (Any)], ret: (default_1$8), isOperator: false }], args);
}
function scale(...args) {
    return sqlFunction("scale", [{ args: [(default_1$2)], ret: (default_1$4), isOperator: false }], args);
}
function schemaToXml(...args) {
    return sqlFunction("schema_to_xml", [{ args: [(name$1), (default_1$8), (default_1$8), (default_1$1)], ret: (xml$1), isOperator: false }], args);
}
function schemaToXmlAndXmlschema(...args) {
    return sqlFunction("schema_to_xml_and_xmlschema", [{ args: [(name$1), (default_1$8), (default_1$8), (default_1$1)], ret: (xml$1), isOperator: false }], args);
}
function schemaToXmlschema(...args) {
    return sqlFunction("schema_to_xmlschema", [{ args: [(name$1), (default_1$8), (default_1$8), (default_1$1)], ret: (xml$1), isOperator: false }], args);
}
function sessionUser(...args) {
    return sqlFunction("session_user", [{ args: [], ret: (name$1), isOperator: false }], args);
}
function setBit(...args) {
    return sqlFunction("set_bit", [{ args: [(bit$1), (default_1$4), (default_1$4)], ret: (bit$1), isOperator: false }, { args: [(bytea), (default_1$3), (default_1$4)], ret: (bytea), isOperator: false }], args);
}
function setByte(...args) {
    return sqlFunction("set_byte", [{ args: [(bytea), (default_1$4), (default_1$4)], ret: (bytea), isOperator: false }], args);
}
function setConfig(...args) {
    return sqlFunction("set_config", [{ args: [(default_1$1), (default_1$1), (default_1$8)], ret: (default_1$1), isOperator: false }], args);
}
function setMasklen(...args) {
    return sqlFunction("set_masklen", [{ args: [(cidr$1), (default_1$4)], ret: (cidr$1), isOperator: false }, { args: [(inet), (default_1$4)], ret: (inet), isOperator: false }], args);
}
function setseed(...args) {
    return sqlFunction("setseed", [{ args: [(default_1$6)], ret: (_void), isOperator: false }], args);
}
function setval(...args) {
    return sqlFunction("setval", [{ args: [(regclass$1), (default_1$3)], ret: (default_1$3), isOperator: false }, { args: [(regclass$1), (default_1$3), (default_1$8)], ret: (default_1$3), isOperator: false }], args);
}
function setweight(...args) {
    return sqlFunction("setweight", [{ args: [(tsvector), (char$1)], ret: (tsvector), isOperator: false }, { args: [(tsvector), (char$1), Array$1.of((default_1$1))], ret: (tsvector), isOperator: false }], args);
}
function sha224(...args) {
    return sqlFunction("sha224", [{ args: [(bytea)], ret: (bytea), isOperator: false }], args);
}
function sha256(...args) {
    return sqlFunction("sha256", [{ args: [(bytea)], ret: (bytea), isOperator: false }], args);
}
function sha384(...args) {
    return sqlFunction("sha384", [{ args: [(bytea)], ret: (bytea), isOperator: false }], args);
}
function sha512(...args) {
    return sqlFunction("sha512", [{ args: [(bytea)], ret: (bytea), isOperator: false }], args);
}
function shobjDescription(...args) {
    return sqlFunction("shobj_description", [{ args: [(oid$1), (name$1)], ret: (default_1$1), isOperator: false }], args);
}
function sign(...args) {
    return sqlFunction("sign", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }, { args: [(default_1$2)], ret: (default_1$2), isOperator: false }], args);
}
function similarEscape(...args) {
    return sqlFunction("similar_escape", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$1), isOperator: false }], args);
}
function similarToEscape(...args) {
    return sqlFunction("similar_to_escape", [{ args: [(default_1$1)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$1)], ret: (default_1$1), isOperator: false }], args);
}
function sind(...args) {
    return sqlFunction("sind", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function sinh(...args) {
    return sqlFunction("sinh", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function slope(...args) {
    return sqlFunction("slope", [{ args: [(point$1), (point$1)], ret: (default_1$6), isOperator: false }], args);
}
function spgPolyQuadCompress(...args) {
    return sqlFunction("spg_poly_quad_compress", [{ args: [(polygon$1)], ret: (box$1), isOperator: false }], args);
}
function splitPart(...args) {
    return sqlFunction("split_part", [{ args: [(default_1$1), (default_1$1), (default_1$4)], ret: (default_1$1), isOperator: false }], args);
}
function sqrt(...args) {
    return sqlFunction("sqrt", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }, { args: [(default_1$2)], ret: (default_1$2), isOperator: false }], args);
}
function startsWith(...args) {
    return sqlFunction("starts_with", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function statementTimestamp(...args) {
    return sqlFunction("statement_timestamp", [{ args: [], ret: (timestamptz$1), isOperator: false }], args);
}
function stddev(...args) {
    return sqlFunction("stddev", [{ args: [(default_1$7)], ret: (default_1$6), isOperator: false }, { args: [(default_1$6)], ret: (default_1$6), isOperator: false }, { args: [(default_1$5)], ret: (default_1$2), isOperator: false }, { args: [(default_1$4)], ret: (default_1$2), isOperator: false }, { args: [(default_1$3)], ret: (default_1$2), isOperator: false }, { args: [(default_1$2)], ret: (default_1$2), isOperator: false }], args);
}
function stddevPop(...args) {
    return sqlFunction("stddev_pop", [{ args: [(default_1$7)], ret: (default_1$6), isOperator: false }, { args: [(default_1$6)], ret: (default_1$6), isOperator: false }, { args: [(default_1$5)], ret: (default_1$2), isOperator: false }, { args: [(default_1$4)], ret: (default_1$2), isOperator: false }, { args: [(default_1$3)], ret: (default_1$2), isOperator: false }, { args: [(default_1$2)], ret: (default_1$2), isOperator: false }], args);
}
function stddevSamp(...args) {
    return sqlFunction("stddev_samp", [{ args: [(default_1$7)], ret: (default_1$6), isOperator: false }, { args: [(default_1$6)], ret: (default_1$6), isOperator: false }, { args: [(default_1$5)], ret: (default_1$2), isOperator: false }, { args: [(default_1$4)], ret: (default_1$2), isOperator: false }, { args: [(default_1$3)], ret: (default_1$2), isOperator: false }, { args: [(default_1$2)], ret: (default_1$2), isOperator: false }], args);
}
function stringAgg(...args) {
    return sqlFunction("string_agg", [{ args: [(bytea), (bytea)], ret: (bytea), isOperator: false }, { args: [(default_1$1), (default_1$1)], ret: (default_1$1), isOperator: false }], args);
}
function stringToArray(...args) {
    return sqlFunction("string_to_array", [{ args: [(default_1$1), (default_1$1)], ret: Array$1.of((default_1$1)), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$1)], ret: Array$1.of((default_1$1)), isOperator: false }], args);
}
function stringToTable(...args) {
    return sqlFunction("string_to_table", [{ args: [(default_1$1), (default_1$1)], ret: Setof.ofSchema({}), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$1)], ret: Setof.ofSchema({}), isOperator: false }], args);
}
function strip(...args) {
    return sqlFunction("strip", [{ args: [(tsvector)], ret: (tsvector), isOperator: false }], args);
}
function strpos(...args) {
    return sqlFunction("strpos", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$4), isOperator: false }], args);
}
function substr(...args) {
    return sqlFunction("substr", [{ args: [(bytea), (default_1$4)], ret: (bytea), isOperator: false }, { args: [(bytea), (default_1$4), (default_1$4)], ret: (bytea), isOperator: false }, { args: [(default_1$1), (default_1$4)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$4), (default_1$4)], ret: (default_1$1), isOperator: false }], args);
}
function substring(...args) {
    return sqlFunction("substring", [{ args: [(bit$1), (default_1$4)], ret: (bit$1), isOperator: false }, { args: [(bit$1), (default_1$4), (default_1$4)], ret: (bit$1), isOperator: false }, { args: [(bytea), (default_1$4)], ret: (bytea), isOperator: false }, { args: [(bytea), (default_1$4), (default_1$4)], ret: (bytea), isOperator: false }, { args: [(default_1$1), (default_1$4)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$4), (default_1$4)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$1)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$1), (default_1$1)], ret: (default_1$1), isOperator: false }], args);
}
function sum(...args) {
    return sqlFunction("sum", [{ args: [(default_1$7)], ret: (default_1$7), isOperator: false }, { args: [(default_1$6)], ret: (default_1$6), isOperator: false }, { args: [(default_1$5)], ret: (default_1$3), isOperator: false }, { args: [(default_1$4)], ret: (default_1$3), isOperator: false }, { args: [(interval$1)], ret: (interval$1), isOperator: false }, { args: [(money$1)], ret: (money$1), isOperator: false }, { args: [(default_1$3)], ret: (default_1$2), isOperator: false }, { args: [(default_1$2)], ret: (default_1$2), isOperator: false }], args);
}
function suppressRedundantUpdatesTrigger(...args) {
    return sqlFunction("suppress_redundant_updates_trigger", [{ args: [], ret: (trigger), isOperator: false }], args);
}
function systemUser(...args) {
    return sqlFunction("system_user", [{ args: [], ret: (default_1$1), isOperator: false }], args);
}
function tableToXml(...args) {
    return sqlFunction("table_to_xml", [{ args: [(regclass$1), (default_1$8), (default_1$8), (default_1$1)], ret: (xml$1), isOperator: false }], args);
}
function tableToXmlAndXmlschema(...args) {
    return sqlFunction("table_to_xml_and_xmlschema", [{ args: [(regclass$1), (default_1$8), (default_1$8), (default_1$1)], ret: (xml$1), isOperator: false }], args);
}
function tableToXmlschema(...args) {
    return sqlFunction("table_to_xmlschema", [{ args: [(regclass$1), (default_1$8), (default_1$8), (default_1$1)], ret: (xml$1), isOperator: false }], args);
}
function tan(...args) {
    return sqlFunction("tan", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function tand(...args) {
    return sqlFunction("tand", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function tanh(...args) {
    return sqlFunction("tanh", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }], args);
}
function text(...args) {
    return sqlFunction("text", [{ args: [(default_1$8)], ret: (default_1$1), isOperator: false }, { args: [(bpchar$1)], ret: (default_1$1), isOperator: false }, { args: [(char$1)], ret: (default_1$1), isOperator: false }, { args: [(inet)], ret: (default_1$1), isOperator: false }, { args: [(name$1)], ret: (default_1$1), isOperator: false }, { args: [(xml$1)], ret: (default_1$1), isOperator: false }], args);
}
function textGe(...args) {
    return sqlFunction("text_ge", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function textGt(...args) {
    return sqlFunction("text_gt", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function textLarger(...args) {
    return sqlFunction("text_larger", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$1), isOperator: false }], args);
}
function textLe(...args) {
    return sqlFunction("text_le", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function textLt(...args) {
    return sqlFunction("text_lt", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function textPatternGe(...args) {
    return sqlFunction("text_pattern_ge", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function textPatternGt(...args) {
    return sqlFunction("text_pattern_gt", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function textPatternLe(...args) {
    return sqlFunction("text_pattern_le", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function textPatternLt(...args) {
    return sqlFunction("text_pattern_lt", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function textSmaller(...args) {
    return sqlFunction("text_smaller", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$1), isOperator: false }], args);
}
function textanycat(...args) {
    return sqlFunction("textanycat", [({ T }) => ({ args: [(default_1$1), T], ret: (default_1$1), isOperator: false })], args);
}
function textcat(...args) {
    return sqlFunction("textcat", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$1), isOperator: false }], args);
}
function texteq(...args) {
    return sqlFunction("texteq", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function texteqname(...args) {
    return sqlFunction("texteqname", [{ args: [(default_1$1), (name$1)], ret: (default_1$8), isOperator: false }], args);
}
function textgename(...args) {
    return sqlFunction("textgename", [{ args: [(default_1$1), (name$1)], ret: (default_1$8), isOperator: false }], args);
}
function textgtname(...args) {
    return sqlFunction("textgtname", [{ args: [(default_1$1), (name$1)], ret: (default_1$8), isOperator: false }], args);
}
function texticlike(...args) {
    return sqlFunction("texticlike", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function texticnlike(...args) {
    return sqlFunction("texticnlike", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function texticregexeq(...args) {
    return sqlFunction("texticregexeq", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function texticregexne(...args) {
    return sqlFunction("texticregexne", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function textlen(...args) {
    return sqlFunction("textlen", [{ args: [(default_1$1)], ret: (default_1$4), isOperator: false }], args);
}
function textlename(...args) {
    return sqlFunction("textlename", [{ args: [(default_1$1), (name$1)], ret: (default_1$8), isOperator: false }], args);
}
function textlike(...args) {
    return sqlFunction("textlike", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function textltname(...args) {
    return sqlFunction("textltname", [{ args: [(default_1$1), (name$1)], ret: (default_1$8), isOperator: false }], args);
}
function textne(...args) {
    return sqlFunction("textne", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function textnename(...args) {
    return sqlFunction("textnename", [{ args: [(default_1$1), (name$1)], ret: (default_1$8), isOperator: false }], args);
}
function textnlike(...args) {
    return sqlFunction("textnlike", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function textregexeq(...args) {
    return sqlFunction("textregexeq", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function textregexne(...args) {
    return sqlFunction("textregexne", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function tideq(...args) {
    return sqlFunction("tideq", [{ args: [(tid), (tid)], ret: (default_1$8), isOperator: false }], args);
}
function tidge(...args) {
    return sqlFunction("tidge", [{ args: [(tid), (tid)], ret: (default_1$8), isOperator: false }], args);
}
function tidgt(...args) {
    return sqlFunction("tidgt", [{ args: [(tid), (tid)], ret: (default_1$8), isOperator: false }], args);
}
function tidlarger(...args) {
    return sqlFunction("tidlarger", [{ args: [(tid), (tid)], ret: (tid), isOperator: false }], args);
}
function tidle(...args) {
    return sqlFunction("tidle", [{ args: [(tid), (tid)], ret: (default_1$8), isOperator: false }], args);
}
function tidlt(...args) {
    return sqlFunction("tidlt", [{ args: [(tid), (tid)], ret: (default_1$8), isOperator: false }], args);
}
function tidne(...args) {
    return sqlFunction("tidne", [{ args: [(tid), (tid)], ret: (default_1$8), isOperator: false }], args);
}
function tidsmaller(...args) {
    return sqlFunction("tidsmaller", [{ args: [(tid), (tid)], ret: (tid), isOperator: false }], args);
}
function time(...args) {
    return sqlFunction("time", [{ args: [(interval$1)], ret: (time$1), isOperator: false }, { args: [(time$1), (default_1$4)], ret: (time$1), isOperator: false }, { args: [(timestamp$1)], ret: (time$1), isOperator: false }, { args: [(timestamptz$1)], ret: (time$1), isOperator: false }, { args: [(timetz$1)], ret: (time$1), isOperator: false }], args);
}
function timeCmp(...args) {
    return sqlFunction("time_cmp", [{ args: [(time$1), (time$1)], ret: (default_1$4), isOperator: false }], args);
}
function timeEq(...args) {
    return sqlFunction("time_eq", [{ args: [(time$1), (time$1)], ret: (default_1$8), isOperator: false }], args);
}
function timeGe(...args) {
    return sqlFunction("time_ge", [{ args: [(time$1), (time$1)], ret: (default_1$8), isOperator: false }], args);
}
function timeGt(...args) {
    return sqlFunction("time_gt", [{ args: [(time$1), (time$1)], ret: (default_1$8), isOperator: false }], args);
}
function timeHash(...args) {
    return sqlFunction("time_hash", [{ args: [(time$1)], ret: (default_1$4), isOperator: false }], args);
}
function timeHashExtended(...args) {
    return sqlFunction("time_hash_extended", [{ args: [(time$1), (default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function timeLarger(...args) {
    return sqlFunction("time_larger", [{ args: [(time$1), (time$1)], ret: (time$1), isOperator: false }], args);
}
function timeLe(...args) {
    return sqlFunction("time_le", [{ args: [(time$1), (time$1)], ret: (default_1$8), isOperator: false }], args);
}
function timeLt(...args) {
    return sqlFunction("time_lt", [{ args: [(time$1), (time$1)], ret: (default_1$8), isOperator: false }], args);
}
function timeMiInterval(...args) {
    return sqlFunction("time_mi_interval", [{ args: [(time$1), (interval$1)], ret: (time$1), isOperator: false }], args);
}
function timeMiTime(...args) {
    return sqlFunction("time_mi_time", [{ args: [(time$1), (time$1)], ret: (interval$1), isOperator: false }], args);
}
function timeNe(...args) {
    return sqlFunction("time_ne", [{ args: [(time$1), (time$1)], ret: (default_1$8), isOperator: false }], args);
}
function timePlInterval(...args) {
    return sqlFunction("time_pl_interval", [{ args: [(time$1), (interval$1)], ret: (time$1), isOperator: false }], args);
}
function timeSmaller(...args) {
    return sqlFunction("time_smaller", [{ args: [(time$1), (time$1)], ret: (time$1), isOperator: false }], args);
}
function timedatePl(...args) {
    return sqlFunction("timedate_pl", [{ args: [(time$1), (date$1)], ret: (timestamp$1), isOperator: false }], args);
}
function timeofday(...args) {
    return sqlFunction("timeofday", [{ args: [], ret: (default_1$1), isOperator: false }], args);
}
function timestamp(...args) {
    return sqlFunction("timestamp", [{ args: [(date$1)], ret: (timestamp$1), isOperator: false }, { args: [(date$1), (time$1)], ret: (timestamp$1), isOperator: false }, { args: [(timestamp$1), (default_1$4)], ret: (timestamp$1), isOperator: false }, { args: [(timestamptz$1)], ret: (timestamp$1), isOperator: false }], args);
}
function timestampCmp(...args) {
    return sqlFunction("timestamp_cmp", [{ args: [(timestamp$1), (timestamp$1)], ret: (default_1$4), isOperator: false }], args);
}
function timestampCmpDate(...args) {
    return sqlFunction("timestamp_cmp_date", [{ args: [(timestamp$1), (date$1)], ret: (default_1$4), isOperator: false }], args);
}
function timestampCmpTimestamptz(...args) {
    return sqlFunction("timestamp_cmp_timestamptz", [{ args: [(timestamp$1), (timestamptz$1)], ret: (default_1$4), isOperator: false }], args);
}
function timestampEq(...args) {
    return sqlFunction("timestamp_eq", [{ args: [(timestamp$1), (timestamp$1)], ret: (default_1$8), isOperator: false }], args);
}
function timestampEqDate(...args) {
    return sqlFunction("timestamp_eq_date", [{ args: [(timestamp$1), (date$1)], ret: (default_1$8), isOperator: false }], args);
}
function timestampEqTimestamptz(...args) {
    return sqlFunction("timestamp_eq_timestamptz", [{ args: [(timestamp$1), (timestamptz$1)], ret: (default_1$8), isOperator: false }], args);
}
function timestampGe(...args) {
    return sqlFunction("timestamp_ge", [{ args: [(timestamp$1), (timestamp$1)], ret: (default_1$8), isOperator: false }], args);
}
function timestampGeDate(...args) {
    return sqlFunction("timestamp_ge_date", [{ args: [(timestamp$1), (date$1)], ret: (default_1$8), isOperator: false }], args);
}
function timestampGeTimestamptz(...args) {
    return sqlFunction("timestamp_ge_timestamptz", [{ args: [(timestamp$1), (timestamptz$1)], ret: (default_1$8), isOperator: false }], args);
}
function timestampGt(...args) {
    return sqlFunction("timestamp_gt", [{ args: [(timestamp$1), (timestamp$1)], ret: (default_1$8), isOperator: false }], args);
}
function timestampGtDate(...args) {
    return sqlFunction("timestamp_gt_date", [{ args: [(timestamp$1), (date$1)], ret: (default_1$8), isOperator: false }], args);
}
function timestampGtTimestamptz(...args) {
    return sqlFunction("timestamp_gt_timestamptz", [{ args: [(timestamp$1), (timestamptz$1)], ret: (default_1$8), isOperator: false }], args);
}
function timestampHash(...args) {
    return sqlFunction("timestamp_hash", [{ args: [(timestamp$1)], ret: (default_1$4), isOperator: false }], args);
}
function timestampHashExtended(...args) {
    return sqlFunction("timestamp_hash_extended", [{ args: [(timestamp$1), (default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function timestampLarger(...args) {
    return sqlFunction("timestamp_larger", [{ args: [(timestamp$1), (timestamp$1)], ret: (timestamp$1), isOperator: false }], args);
}
function timestampLe(...args) {
    return sqlFunction("timestamp_le", [{ args: [(timestamp$1), (timestamp$1)], ret: (default_1$8), isOperator: false }], args);
}
function timestampLeDate(...args) {
    return sqlFunction("timestamp_le_date", [{ args: [(timestamp$1), (date$1)], ret: (default_1$8), isOperator: false }], args);
}
function timestampLeTimestamptz(...args) {
    return sqlFunction("timestamp_le_timestamptz", [{ args: [(timestamp$1), (timestamptz$1)], ret: (default_1$8), isOperator: false }], args);
}
function timestampLt(...args) {
    return sqlFunction("timestamp_lt", [{ args: [(timestamp$1), (timestamp$1)], ret: (default_1$8), isOperator: false }], args);
}
function timestampLtDate(...args) {
    return sqlFunction("timestamp_lt_date", [{ args: [(timestamp$1), (date$1)], ret: (default_1$8), isOperator: false }], args);
}
function timestampLtTimestamptz(...args) {
    return sqlFunction("timestamp_lt_timestamptz", [{ args: [(timestamp$1), (timestamptz$1)], ret: (default_1$8), isOperator: false }], args);
}
function timestampMi(...args) {
    return sqlFunction("timestamp_mi", [{ args: [(timestamp$1), (timestamp$1)], ret: (interval$1), isOperator: false }], args);
}
function timestampMiInterval(...args) {
    return sqlFunction("timestamp_mi_interval", [{ args: [(timestamp$1), (interval$1)], ret: (timestamp$1), isOperator: false }], args);
}
function timestampNe(...args) {
    return sqlFunction("timestamp_ne", [{ args: [(timestamp$1), (timestamp$1)], ret: (default_1$8), isOperator: false }], args);
}
function timestampNeDate(...args) {
    return sqlFunction("timestamp_ne_date", [{ args: [(timestamp$1), (date$1)], ret: (default_1$8), isOperator: false }], args);
}
function timestampNeTimestamptz(...args) {
    return sqlFunction("timestamp_ne_timestamptz", [{ args: [(timestamp$1), (timestamptz$1)], ret: (default_1$8), isOperator: false }], args);
}
function timestampPlInterval(...args) {
    return sqlFunction("timestamp_pl_interval", [{ args: [(timestamp$1), (interval$1)], ret: (timestamp$1), isOperator: false }], args);
}
function timestampSmaller(...args) {
    return sqlFunction("timestamp_smaller", [{ args: [(timestamp$1), (timestamp$1)], ret: (timestamp$1), isOperator: false }], args);
}
function timestamptz(...args) {
    return sqlFunction("timestamptz", [{ args: [(date$1)], ret: (timestamptz$1), isOperator: false }, { args: [(date$1), (time$1)], ret: (timestamptz$1), isOperator: false }, { args: [(date$1), (timetz$1)], ret: (timestamptz$1), isOperator: false }, { args: [(timestamp$1)], ret: (timestamptz$1), isOperator: false }, { args: [(timestamptz$1), (default_1$4)], ret: (timestamptz$1), isOperator: false }], args);
}
function timestamptzCmp(...args) {
    return sqlFunction("timestamptz_cmp", [{ args: [(timestamptz$1), (timestamptz$1)], ret: (default_1$4), isOperator: false }], args);
}
function timestamptzCmpDate(...args) {
    return sqlFunction("timestamptz_cmp_date", [{ args: [(timestamptz$1), (date$1)], ret: (default_1$4), isOperator: false }], args);
}
function timestamptzCmpTimestamp(...args) {
    return sqlFunction("timestamptz_cmp_timestamp", [{ args: [(timestamptz$1), (timestamp$1)], ret: (default_1$4), isOperator: false }], args);
}
function timestamptzEq(...args) {
    return sqlFunction("timestamptz_eq", [{ args: [(timestamptz$1), (timestamptz$1)], ret: (default_1$8), isOperator: false }], args);
}
function timestamptzEqDate(...args) {
    return sqlFunction("timestamptz_eq_date", [{ args: [(timestamptz$1), (date$1)], ret: (default_1$8), isOperator: false }], args);
}
function timestamptzEqTimestamp(...args) {
    return sqlFunction("timestamptz_eq_timestamp", [{ args: [(timestamptz$1), (timestamp$1)], ret: (default_1$8), isOperator: false }], args);
}
function timestamptzGe(...args) {
    return sqlFunction("timestamptz_ge", [{ args: [(timestamptz$1), (timestamptz$1)], ret: (default_1$8), isOperator: false }], args);
}
function timestamptzGeDate(...args) {
    return sqlFunction("timestamptz_ge_date", [{ args: [(timestamptz$1), (date$1)], ret: (default_1$8), isOperator: false }], args);
}
function timestamptzGeTimestamp(...args) {
    return sqlFunction("timestamptz_ge_timestamp", [{ args: [(timestamptz$1), (timestamp$1)], ret: (default_1$8), isOperator: false }], args);
}
function timestamptzGt(...args) {
    return sqlFunction("timestamptz_gt", [{ args: [(timestamptz$1), (timestamptz$1)], ret: (default_1$8), isOperator: false }], args);
}
function timestamptzGtDate(...args) {
    return sqlFunction("timestamptz_gt_date", [{ args: [(timestamptz$1), (date$1)], ret: (default_1$8), isOperator: false }], args);
}
function timestamptzGtTimestamp(...args) {
    return sqlFunction("timestamptz_gt_timestamp", [{ args: [(timestamptz$1), (timestamp$1)], ret: (default_1$8), isOperator: false }], args);
}
function timestamptzLarger(...args) {
    return sqlFunction("timestamptz_larger", [{ args: [(timestamptz$1), (timestamptz$1)], ret: (timestamptz$1), isOperator: false }], args);
}
function timestamptzLe(...args) {
    return sqlFunction("timestamptz_le", [{ args: [(timestamptz$1), (timestamptz$1)], ret: (default_1$8), isOperator: false }], args);
}
function timestamptzLeDate(...args) {
    return sqlFunction("timestamptz_le_date", [{ args: [(timestamptz$1), (date$1)], ret: (default_1$8), isOperator: false }], args);
}
function timestamptzLeTimestamp(...args) {
    return sqlFunction("timestamptz_le_timestamp", [{ args: [(timestamptz$1), (timestamp$1)], ret: (default_1$8), isOperator: false }], args);
}
function timestamptzLt(...args) {
    return sqlFunction("timestamptz_lt", [{ args: [(timestamptz$1), (timestamptz$1)], ret: (default_1$8), isOperator: false }], args);
}
function timestamptzLtDate(...args) {
    return sqlFunction("timestamptz_lt_date", [{ args: [(timestamptz$1), (date$1)], ret: (default_1$8), isOperator: false }], args);
}
function timestamptzLtTimestamp(...args) {
    return sqlFunction("timestamptz_lt_timestamp", [{ args: [(timestamptz$1), (timestamp$1)], ret: (default_1$8), isOperator: false }], args);
}
function timestamptzMi(...args) {
    return sqlFunction("timestamptz_mi", [{ args: [(timestamptz$1), (timestamptz$1)], ret: (interval$1), isOperator: false }], args);
}
function timestamptzMiInterval(...args) {
    return sqlFunction("timestamptz_mi_interval", [{ args: [(timestamptz$1), (interval$1)], ret: (timestamptz$1), isOperator: false }], args);
}
function timestamptzNe(...args) {
    return sqlFunction("timestamptz_ne", [{ args: [(timestamptz$1), (timestamptz$1)], ret: (default_1$8), isOperator: false }], args);
}
function timestamptzNeDate(...args) {
    return sqlFunction("timestamptz_ne_date", [{ args: [(timestamptz$1), (date$1)], ret: (default_1$8), isOperator: false }], args);
}
function timestamptzNeTimestamp(...args) {
    return sqlFunction("timestamptz_ne_timestamp", [{ args: [(timestamptz$1), (timestamp$1)], ret: (default_1$8), isOperator: false }], args);
}
function timestamptzPlInterval(...args) {
    return sqlFunction("timestamptz_pl_interval", [{ args: [(timestamptz$1), (interval$1)], ret: (timestamptz$1), isOperator: false }], args);
}
function timestamptzSmaller(...args) {
    return sqlFunction("timestamptz_smaller", [{ args: [(timestamptz$1), (timestamptz$1)], ret: (timestamptz$1), isOperator: false }], args);
}
function timetz(...args) {
    return sqlFunction("timetz", [{ args: [(time$1)], ret: (timetz$1), isOperator: false }, { args: [(timestamptz$1)], ret: (timetz$1), isOperator: false }, { args: [(timetz$1), (default_1$4)], ret: (timetz$1), isOperator: false }], args);
}
function timetzCmp(...args) {
    return sqlFunction("timetz_cmp", [{ args: [(timetz$1), (timetz$1)], ret: (default_1$4), isOperator: false }], args);
}
function timetzEq(...args) {
    return sqlFunction("timetz_eq", [{ args: [(timetz$1), (timetz$1)], ret: (default_1$8), isOperator: false }], args);
}
function timetzGe(...args) {
    return sqlFunction("timetz_ge", [{ args: [(timetz$1), (timetz$1)], ret: (default_1$8), isOperator: false }], args);
}
function timetzGt(...args) {
    return sqlFunction("timetz_gt", [{ args: [(timetz$1), (timetz$1)], ret: (default_1$8), isOperator: false }], args);
}
function timetzHash(...args) {
    return sqlFunction("timetz_hash", [{ args: [(timetz$1)], ret: (default_1$4), isOperator: false }], args);
}
function timetzHashExtended(...args) {
    return sqlFunction("timetz_hash_extended", [{ args: [(timetz$1), (default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function timetzLarger(...args) {
    return sqlFunction("timetz_larger", [{ args: [(timetz$1), (timetz$1)], ret: (timetz$1), isOperator: false }], args);
}
function timetzLe(...args) {
    return sqlFunction("timetz_le", [{ args: [(timetz$1), (timetz$1)], ret: (default_1$8), isOperator: false }], args);
}
function timetzLt(...args) {
    return sqlFunction("timetz_lt", [{ args: [(timetz$1), (timetz$1)], ret: (default_1$8), isOperator: false }], args);
}
function timetzMiInterval(...args) {
    return sqlFunction("timetz_mi_interval", [{ args: [(timetz$1), (interval$1)], ret: (timetz$1), isOperator: false }], args);
}
function timetzNe(...args) {
    return sqlFunction("timetz_ne", [{ args: [(timetz$1), (timetz$1)], ret: (default_1$8), isOperator: false }], args);
}
function timetzPlInterval(...args) {
    return sqlFunction("timetz_pl_interval", [{ args: [(timetz$1), (interval$1)], ret: (timetz$1), isOperator: false }], args);
}
function timetzSmaller(...args) {
    return sqlFunction("timetz_smaller", [{ args: [(timetz$1), (timetz$1)], ret: (timetz$1), isOperator: false }], args);
}
function timetzdatePl(...args) {
    return sqlFunction("timetzdate_pl", [{ args: [(timetz$1), (date$1)], ret: (timestamptz$1), isOperator: false }], args);
}
function timezone(...args) {
    return sqlFunction("timezone", [{ args: [(interval$1), (timestamptz$1)], ret: (timestamp$1), isOperator: false }, { args: [(default_1$1), (timestamptz$1)], ret: (timestamp$1), isOperator: false }, { args: [(timestamptz$1)], ret: (timestamp$1), isOperator: false }, { args: [(interval$1), (timestamp$1)], ret: (timestamptz$1), isOperator: false }, { args: [(default_1$1), (timestamp$1)], ret: (timestamptz$1), isOperator: false }, { args: [(timestamp$1)], ret: (timestamptz$1), isOperator: false }, { args: [(interval$1), (timetz$1)], ret: (timetz$1), isOperator: false }, { args: [(default_1$1), (timetz$1)], ret: (timetz$1), isOperator: false }, { args: [(timetz$1)], ret: (timetz$1), isOperator: false }], args);
}
function toAscii(...args) {
    return sqlFunction("to_ascii", [{ args: [(default_1$1)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (default_1$4)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (name$1)], ret: (default_1$1), isOperator: false }], args);
}
function toChar(...args) {
    return sqlFunction("to_char", [{ args: [(default_1$7), (default_1$1)], ret: (default_1$1), isOperator: false }, { args: [(default_1$6), (default_1$1)], ret: (default_1$1), isOperator: false }, { args: [(default_1$4), (default_1$1)], ret: (default_1$1), isOperator: false }, { args: [(default_1$3), (default_1$1)], ret: (default_1$1), isOperator: false }, { args: [(interval$1), (default_1$1)], ret: (default_1$1), isOperator: false }, { args: [(default_1$2), (default_1$1)], ret: (default_1$1), isOperator: false }, { args: [(timestamp$1), (default_1$1)], ret: (default_1$1), isOperator: false }, { args: [(timestamptz$1), (default_1$1)], ret: (default_1$1), isOperator: false }], args);
}
function toDate(...args) {
    return sqlFunction("to_date", [{ args: [(default_1$1), (default_1$1)], ret: (date$1), isOperator: false }], args);
}
function toHex(...args) {
    return sqlFunction("to_hex", [{ args: [(default_1$4)], ret: (default_1$1), isOperator: false }, { args: [(default_1$3)], ret: (default_1$1), isOperator: false }], args);
}
function toJson(...args) {
    return sqlFunction("to_json", [({ T }) => ({ args: [T], ret: (json), isOperator: false })], args);
}
function toJsonb(...args) {
    return sqlFunction("to_jsonb", [({ T }) => ({ args: [T], ret: (jsonb), isOperator: false })], args);
}
function toNumber(...args) {
    return sqlFunction("to_number", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$2), isOperator: false }], args);
}
function toOct(...args) {
    return sqlFunction("to_oct", [{ args: [(default_1$4)], ret: (default_1$1), isOperator: false }, { args: [(default_1$3)], ret: (default_1$1), isOperator: false }], args);
}
function toRegclass(...args) {
    return sqlFunction("to_regclass", [{ args: [(default_1$1)], ret: (regclass$1), isOperator: false }], args);
}
function toRegcollation(...args) {
    return sqlFunction("to_regcollation", [{ args: [(default_1$1)], ret: (regcollation), isOperator: false }], args);
}
function toRegnamespace(...args) {
    return sqlFunction("to_regnamespace", [{ args: [(default_1$1)], ret: (regnamespace), isOperator: false }], args);
}
function toRegoper(...args) {
    return sqlFunction("to_regoper", [{ args: [(default_1$1)], ret: (regoper), isOperator: false }], args);
}
function toRegoperator(...args) {
    return sqlFunction("to_regoperator", [{ args: [(default_1$1)], ret: (regoperator), isOperator: false }], args);
}
function toRegproc(...args) {
    return sqlFunction("to_regproc", [{ args: [(default_1$1)], ret: (regproc), isOperator: false }], args);
}
function toRegprocedure(...args) {
    return sqlFunction("to_regprocedure", [{ args: [(default_1$1)], ret: (regprocedure), isOperator: false }], args);
}
function toRegrole(...args) {
    return sqlFunction("to_regrole", [{ args: [(default_1$1)], ret: (regrole), isOperator: false }], args);
}
function toRegtype(...args) {
    return sqlFunction("to_regtype", [{ args: [(default_1$1)], ret: (regtype), isOperator: false }], args);
}
function toRegtypemod(...args) {
    return sqlFunction("to_regtypemod", [{ args: [(default_1$1)], ret: (default_1$4), isOperator: false }], args);
}
function toTimestamp(...args) {
    return sqlFunction("to_timestamp", [{ args: [(default_1$6)], ret: (timestamptz$1), isOperator: false }, { args: [(default_1$1), (default_1$1)], ret: (timestamptz$1), isOperator: false }], args);
}
function toTsquery(...args) {
    return sqlFunction("to_tsquery", [{ args: [(regconfig), (default_1$1)], ret: (tsquery), isOperator: false }, { args: [(default_1$1)], ret: (tsquery), isOperator: false }], args);
}
function toTsvector(...args) {
    return sqlFunction("to_tsvector", [{ args: [(json)], ret: (tsvector), isOperator: false }, { args: [(jsonb)], ret: (tsvector), isOperator: false }, { args: [(regconfig), (json)], ret: (tsvector), isOperator: false }, { args: [(regconfig), (jsonb)], ret: (tsvector), isOperator: false }, { args: [(regconfig), (default_1$1)], ret: (tsvector), isOperator: false }, { args: [(default_1$1)], ret: (tsvector), isOperator: false }], args);
}
function transactionTimestamp(...args) {
    return sqlFunction("transaction_timestamp", [{ args: [], ret: (timestamptz$1), isOperator: false }], args);
}
function translate(...args) {
    return sqlFunction("translate", [{ args: [(default_1$1), (default_1$1), (default_1$1)], ret: (default_1$1), isOperator: false }], args);
}
function trimArray(...args) {
    return sqlFunction("trim_array", [({ T }) => ({ args: [Array$1.of(T), (default_1$4)], ret: Array$1.of(T), isOperator: false })], args);
}
function trimScale(...args) {
    return sqlFunction("trim_scale", [{ args: [(default_1$2)], ret: (default_1$2), isOperator: false }], args);
}
function trunc(...args) {
    return sqlFunction("trunc", [{ args: [(default_1$6)], ret: (default_1$6), isOperator: false }, { args: [(macaddr$1)], ret: (macaddr$1), isOperator: false }, { args: [(macaddr8$1)], ret: (macaddr8$1), isOperator: false }, { args: [(default_1$2)], ret: (default_1$2), isOperator: false }, { args: [(default_1$2), (default_1$4)], ret: (default_1$2), isOperator: false }], args);
}
function tsDebug(...args) {
    return sqlFunction("ts_debug", [{ args: [(regconfig), (default_1$1)], ret: Setof.ofSchema({ alias: (default_1$1), description: (default_1$1), token: (default_1$1), dictionaries: Array$1.of((regdictionary)), dictionary: (regdictionary), lexemes: Array$1.of((default_1$1)) }), isOperator: false }, { args: [(default_1$1)], ret: Setof.ofSchema({ alias: (default_1$1), description: (default_1$1), token: (default_1$1), dictionaries: Array$1.of((regdictionary)), dictionary: (regdictionary), lexemes: Array$1.of((default_1$1)) }), isOperator: false }], args);
}
function tsDelete(...args) {
    return sqlFunction("ts_delete", [{ args: [(tsvector), Array$1.of((default_1$1))], ret: (tsvector), isOperator: false }, { args: [(tsvector), (default_1$1)], ret: (tsvector), isOperator: false }], args);
}
function tsFilter(...args) {
    return sqlFunction("ts_filter", [{ args: [(tsvector), Array$1.of((char$1))], ret: (tsvector), isOperator: false }], args);
}
function tsHeadline(...args) {
    return sqlFunction("ts_headline", [{ args: [(json), (tsquery)], ret: (json), isOperator: false }, { args: [(json), (tsquery), (default_1$1)], ret: (json), isOperator: false }, { args: [(regconfig), (json), (tsquery)], ret: (json), isOperator: false }, { args: [(regconfig), (json), (tsquery), (default_1$1)], ret: (json), isOperator: false }, { args: [(jsonb), (tsquery)], ret: (jsonb), isOperator: false }, { args: [(jsonb), (tsquery), (default_1$1)], ret: (jsonb), isOperator: false }, { args: [(regconfig), (jsonb), (tsquery)], ret: (jsonb), isOperator: false }, { args: [(regconfig), (jsonb), (tsquery), (default_1$1)], ret: (jsonb), isOperator: false }, { args: [(regconfig), (default_1$1), (tsquery)], ret: (default_1$1), isOperator: false }, { args: [(regconfig), (default_1$1), (tsquery), (default_1$1)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (tsquery)], ret: (default_1$1), isOperator: false }, { args: [(default_1$1), (tsquery), (default_1$1)], ret: (default_1$1), isOperator: false }], args);
}
function tsLexize(...args) {
    return sqlFunction("ts_lexize", [{ args: [(regdictionary), (default_1$1)], ret: Array$1.of((default_1$1)), isOperator: false }], args);
}
function tsMatchQv(...args) {
    return sqlFunction("ts_match_qv", [{ args: [(tsquery), (tsvector)], ret: (default_1$8), isOperator: false }, { args: [(tsquery), (tsvector)], ret: (default_1$8), isOperator: false }], args);
}
function tsMatchTq(...args) {
    return sqlFunction("ts_match_tq", [{ args: [(default_1$1), (tsquery)], ret: (default_1$8), isOperator: false }], args);
}
function tsMatchTt(...args) {
    return sqlFunction("ts_match_tt", [{ args: [(default_1$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function tsMatchVq(...args) {
    return sqlFunction("ts_match_vq", [{ args: [(tsvector), (tsquery)], ret: (default_1$8), isOperator: false }, { args: [(tsvector), (tsquery)], ret: (default_1$8), isOperator: false }], args);
}
function tsParse(...args) {
    return sqlFunction("ts_parse", [{ args: [(oid$1), (default_1$1)], ret: Setof.ofSchema({ tokid: (default_1$4), token: (default_1$1) }), isOperator: false }, { args: [(default_1$1), (default_1$1)], ret: Setof.ofSchema({ tokid: (default_1$4), token: (default_1$1) }), isOperator: false }], args);
}
function tsRank(...args) {
    return sqlFunction("ts_rank", [{ args: [Array$1.of((default_1$7)), (tsvector), (tsquery)], ret: (default_1$7), isOperator: false }, { args: [Array$1.of((default_1$7)), (tsvector), (tsquery), (default_1$4)], ret: (default_1$7), isOperator: false }, { args: [(tsvector), (tsquery)], ret: (default_1$7), isOperator: false }, { args: [(tsvector), (tsquery), (default_1$4)], ret: (default_1$7), isOperator: false }], args);
}
function tsRankCd(...args) {
    return sqlFunction("ts_rank_cd", [{ args: [Array$1.of((default_1$7)), (tsvector), (tsquery)], ret: (default_1$7), isOperator: false }, { args: [Array$1.of((default_1$7)), (tsvector), (tsquery), (default_1$4)], ret: (default_1$7), isOperator: false }, { args: [(tsvector), (tsquery)], ret: (default_1$7), isOperator: false }, { args: [(tsvector), (tsquery), (default_1$4)], ret: (default_1$7), isOperator: false }], args);
}
function tsRewrite(...args) {
    return sqlFunction("ts_rewrite", [{ args: [(tsquery), (default_1$1)], ret: (tsquery), isOperator: false }, { args: [(tsquery), (tsquery), (tsquery)], ret: (tsquery), isOperator: false }], args);
}
function tsStat(...args) {
    return sqlFunction("ts_stat", [{ args: [(default_1$1)], ret: Setof.ofSchema({ word: (default_1$1), ndoc: (default_1$4), nentry: (default_1$4) }), isOperator: false }, { args: [(default_1$1), (default_1$1)], ret: Setof.ofSchema({ word: (default_1$1), ndoc: (default_1$4), nentry: (default_1$4) }), isOperator: false }], args);
}
function tsTokenType(...args) {
    return sqlFunction("ts_token_type", [{ args: [(oid$1)], ret: Setof.ofSchema({ tokid: (default_1$4), alias: (default_1$1), description: (default_1$1) }), isOperator: false }, { args: [(default_1$1)], ret: Setof.ofSchema({ tokid: (default_1$4), alias: (default_1$1), description: (default_1$1) }), isOperator: false }], args);
}
function tsmultirange(...args) {
    return sqlFunction("tsmultirange", [{ args: [], ret: (tsmultirange$1), isOperator: false }, { args: [Array$1.of((tsrange$1))], ret: (tsmultirange$1), isOperator: false }, { args: [(tsrange$1)], ret: (tsmultirange$1), isOperator: false }], args);
}
function tsqMcontained(...args) {
    return sqlFunction("tsq_mcontained", [{ args: [(tsquery), (tsquery)], ret: (default_1$8), isOperator: false }], args);
}
function tsqMcontains(...args) {
    return sqlFunction("tsq_mcontains", [{ args: [(tsquery), (tsquery)], ret: (default_1$8), isOperator: false }], args);
}
function tsqueryAnd(...args) {
    return sqlFunction("tsquery_and", [{ args: [(tsquery), (tsquery)], ret: (tsquery), isOperator: false }], args);
}
function tsqueryCmp(...args) {
    return sqlFunction("tsquery_cmp", [{ args: [(tsquery), (tsquery)], ret: (default_1$4), isOperator: false }], args);
}
function tsqueryEq(...args) {
    return sqlFunction("tsquery_eq", [{ args: [(tsquery), (tsquery)], ret: (default_1$8), isOperator: false }], args);
}
function tsqueryGe(...args) {
    return sqlFunction("tsquery_ge", [{ args: [(tsquery), (tsquery)], ret: (default_1$8), isOperator: false }], args);
}
function tsqueryGt(...args) {
    return sqlFunction("tsquery_gt", [{ args: [(tsquery), (tsquery)], ret: (default_1$8), isOperator: false }], args);
}
function tsqueryLe(...args) {
    return sqlFunction("tsquery_le", [{ args: [(tsquery), (tsquery)], ret: (default_1$8), isOperator: false }], args);
}
function tsqueryLt(...args) {
    return sqlFunction("tsquery_lt", [{ args: [(tsquery), (tsquery)], ret: (default_1$8), isOperator: false }], args);
}
function tsqueryNe(...args) {
    return sqlFunction("tsquery_ne", [{ args: [(tsquery), (tsquery)], ret: (default_1$8), isOperator: false }], args);
}
function tsqueryNot(...args) {
    return sqlFunction("tsquery_not", [{ args: [(tsquery)], ret: (tsquery), isOperator: false }], args);
}
function tsqueryOr(...args) {
    return sqlFunction("tsquery_or", [{ args: [(tsquery), (tsquery)], ret: (tsquery), isOperator: false }], args);
}
function tsqueryPhrase(...args) {
    return sqlFunction("tsquery_phrase", [{ args: [(tsquery), (tsquery)], ret: (tsquery), isOperator: false }, { args: [(tsquery), (tsquery), (default_1$4)], ret: (tsquery), isOperator: false }], args);
}
function tsrange(...args) {
    return sqlFunction("tsrange", [{ args: [(timestamp$1), (timestamp$1)], ret: (tsrange$1), isOperator: false }, { args: [(timestamp$1), (timestamp$1), (default_1$1)], ret: (tsrange$1), isOperator: false }], args);
}
function tsrangeSubdiff(...args) {
    return sqlFunction("tsrange_subdiff", [{ args: [(timestamp$1), (timestamp$1)], ret: (default_1$6), isOperator: false }], args);
}
function tstzmultirange(...args) {
    return sqlFunction("tstzmultirange", [{ args: [], ret: (tstzmultirange$1), isOperator: false }, { args: [Array$1.of((tstzrange$1))], ret: (tstzmultirange$1), isOperator: false }, { args: [(tstzrange$1)], ret: (tstzmultirange$1), isOperator: false }], args);
}
function tstzrange(...args) {
    return sqlFunction("tstzrange", [{ args: [(timestamptz$1), (timestamptz$1)], ret: (tstzrange$1), isOperator: false }, { args: [(timestamptz$1), (timestamptz$1), (default_1$1)], ret: (tstzrange$1), isOperator: false }], args);
}
function tstzrangeSubdiff(...args) {
    return sqlFunction("tstzrange_subdiff", [{ args: [(timestamptz$1), (timestamptz$1)], ret: (default_1$6), isOperator: false }], args);
}
function tsvectorCmp(...args) {
    return sqlFunction("tsvector_cmp", [{ args: [(tsvector), (tsvector)], ret: (default_1$4), isOperator: false }], args);
}
function tsvectorConcat(...args) {
    return sqlFunction("tsvector_concat", [{ args: [(tsvector), (tsvector)], ret: (tsvector), isOperator: false }], args);
}
function tsvectorEq(...args) {
    return sqlFunction("tsvector_eq", [{ args: [(tsvector), (tsvector)], ret: (default_1$8), isOperator: false }], args);
}
function tsvectorGe(...args) {
    return sqlFunction("tsvector_ge", [{ args: [(tsvector), (tsvector)], ret: (default_1$8), isOperator: false }], args);
}
function tsvectorGt(...args) {
    return sqlFunction("tsvector_gt", [{ args: [(tsvector), (tsvector)], ret: (default_1$8), isOperator: false }], args);
}
function tsvectorLe(...args) {
    return sqlFunction("tsvector_le", [{ args: [(tsvector), (tsvector)], ret: (default_1$8), isOperator: false }], args);
}
function tsvectorLt(...args) {
    return sqlFunction("tsvector_lt", [{ args: [(tsvector), (tsvector)], ret: (default_1$8), isOperator: false }], args);
}
function tsvectorNe(...args) {
    return sqlFunction("tsvector_ne", [{ args: [(tsvector), (tsvector)], ret: (default_1$8), isOperator: false }], args);
}
function tsvectorToArray(...args) {
    return sqlFunction("tsvector_to_array", [{ args: [(tsvector)], ret: Array$1.of((default_1$1)), isOperator: false }], args);
}
function tsvectorUpdateTrigger(...args) {
    return sqlFunction("tsvector_update_trigger", [{ args: [], ret: (trigger), isOperator: false }], args);
}
function tsvectorUpdateTriggerColumn(...args) {
    return sqlFunction("tsvector_update_trigger_column", [{ args: [], ret: (trigger), isOperator: false }], args);
}
function txidCurrent(...args) {
    return sqlFunction("txid_current", [{ args: [], ret: (default_1$3), isOperator: false }], args);
}
function txidCurrentIfAssigned(...args) {
    return sqlFunction("txid_current_if_assigned", [{ args: [], ret: (default_1$3), isOperator: false }], args);
}
function txidCurrentSnapshot(...args) {
    return sqlFunction("txid_current_snapshot", [{ args: [], ret: (txid_snapshot), isOperator: false }], args);
}
function txidSnapshotXip(...args) {
    return sqlFunction("txid_snapshot_xip", [{ args: [(txid_snapshot)], ret: Setof.ofSchema({}), isOperator: false }], args);
}
function txidSnapshotXmax(...args) {
    return sqlFunction("txid_snapshot_xmax", [{ args: [(txid_snapshot)], ret: (default_1$3), isOperator: false }], args);
}
function txidStatus(...args) {
    return sqlFunction("txid_status", [{ args: [(default_1$3)], ret: (default_1$1), isOperator: false }], args);
}
function txidVisibleInSnapshot(...args) {
    return sqlFunction("txid_visible_in_snapshot", [{ args: [(default_1$3), (txid_snapshot)], ret: (default_1$8), isOperator: false }], args);
}
function unicodeAssigned(...args) {
    return sqlFunction("unicode_assigned", [{ args: [(default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function unicodeVersion(...args) {
    return sqlFunction("unicode_version", [{ args: [], ret: (default_1$1), isOperator: false }], args);
}
function uniqueKeyRecheck(...args) {
    return sqlFunction("unique_key_recheck", [{ args: [], ret: (trigger), isOperator: false }], args);
}
function unistr(...args) {
    return sqlFunction("unistr", [{ args: [(default_1$1)], ret: (default_1$1), isOperator: false }], args);
}
function unnest(...args) {
    return sqlFunction("unnest", [({ T }) => ({ args: [Array$1.of(T)], ret: Setof.ofSchema({}), isOperator: false }), { args: [anymultirange], ret: Setof.ofSchema({}), isOperator: false }, { args: [(tsvector)], ret: Setof.ofSchema({ lexeme: (default_1$1), positions: Array$1.of((default_1$5)), weights: Array$1.of((default_1$1)) }), isOperator: false }], args);
}
function upper(...args) {
    return sqlFunction("upper", [({ T }) => ({ args: [anymultirange], ret: T, isOperator: false }), ({ T }) => ({ args: [anyrange], ret: T, isOperator: false }), { args: [(default_1$1)], ret: (default_1$1), isOperator: false }], args);
}
function upperInc(...args) {
    return sqlFunction("upper_inc", [{ args: [anymultirange], ret: (default_1$8), isOperator: false }, { args: [anyrange], ret: (default_1$8), isOperator: false }], args);
}
function upperInf(...args) {
    return sqlFunction("upper_inf", [{ args: [anymultirange], ret: (default_1$8), isOperator: false }, { args: [anyrange], ret: (default_1$8), isOperator: false }], args);
}
function uuidCmp(...args) {
    return sqlFunction("uuid_cmp", [{ args: [(uuid), (uuid)], ret: (default_1$4), isOperator: false }], args);
}
function uuidEq(...args) {
    return sqlFunction("uuid_eq", [{ args: [(uuid), (uuid)], ret: (default_1$8), isOperator: false }], args);
}
function uuidExtractTimestamp(...args) {
    return sqlFunction("uuid_extract_timestamp", [{ args: [(uuid)], ret: (timestamptz$1), isOperator: false }], args);
}
function uuidExtractVersion(...args) {
    return sqlFunction("uuid_extract_version", [{ args: [(uuid)], ret: (default_1$5), isOperator: false }], args);
}
function uuidGe(...args) {
    return sqlFunction("uuid_ge", [{ args: [(uuid), (uuid)], ret: (default_1$8), isOperator: false }], args);
}
function uuidGt(...args) {
    return sqlFunction("uuid_gt", [{ args: [(uuid), (uuid)], ret: (default_1$8), isOperator: false }], args);
}
function uuidHash(...args) {
    return sqlFunction("uuid_hash", [{ args: [(uuid)], ret: (default_1$4), isOperator: false }], args);
}
function uuidHashExtended(...args) {
    return sqlFunction("uuid_hash_extended", [{ args: [(uuid), (default_1$3)], ret: (default_1$3), isOperator: false }], args);
}
function uuidLe(...args) {
    return sqlFunction("uuid_le", [{ args: [(uuid), (uuid)], ret: (default_1$8), isOperator: false }], args);
}
function uuidLt(...args) {
    return sqlFunction("uuid_lt", [{ args: [(uuid), (uuid)], ret: (default_1$8), isOperator: false }], args);
}
function uuidNe(...args) {
    return sqlFunction("uuid_ne", [{ args: [(uuid), (uuid)], ret: (default_1$8), isOperator: false }], args);
}
function varPop(...args) {
    return sqlFunction("var_pop", [{ args: [(default_1$7)], ret: (default_1$6), isOperator: false }, { args: [(default_1$6)], ret: (default_1$6), isOperator: false }, { args: [(default_1$5)], ret: (default_1$2), isOperator: false }, { args: [(default_1$4)], ret: (default_1$2), isOperator: false }, { args: [(default_1$3)], ret: (default_1$2), isOperator: false }, { args: [(default_1$2)], ret: (default_1$2), isOperator: false }], args);
}
function varSamp(...args) {
    return sqlFunction("var_samp", [{ args: [(default_1$7)], ret: (default_1$6), isOperator: false }, { args: [(default_1$6)], ret: (default_1$6), isOperator: false }, { args: [(default_1$5)], ret: (default_1$2), isOperator: false }, { args: [(default_1$4)], ret: (default_1$2), isOperator: false }, { args: [(default_1$3)], ret: (default_1$2), isOperator: false }, { args: [(default_1$2)], ret: (default_1$2), isOperator: false }], args);
}
function varbit(...args) {
    return sqlFunction("varbit", [{ args: [(varbit$1), (default_1$4), (default_1$8)], ret: (varbit$1), isOperator: false }], args);
}
function varbitcmp(...args) {
    return sqlFunction("varbitcmp", [{ args: [(varbit$1), (varbit$1)], ret: (default_1$4), isOperator: false }], args);
}
function varbiteq(...args) {
    return sqlFunction("varbiteq", [{ args: [(varbit$1), (varbit$1)], ret: (default_1$8), isOperator: false }], args);
}
function varbitge(...args) {
    return sqlFunction("varbitge", [{ args: [(varbit$1), (varbit$1)], ret: (default_1$8), isOperator: false }], args);
}
function varbitgt(...args) {
    return sqlFunction("varbitgt", [{ args: [(varbit$1), (varbit$1)], ret: (default_1$8), isOperator: false }], args);
}
function varbitle(...args) {
    return sqlFunction("varbitle", [{ args: [(varbit$1), (varbit$1)], ret: (default_1$8), isOperator: false }], args);
}
function varbitlt(...args) {
    return sqlFunction("varbitlt", [{ args: [(varbit$1), (varbit$1)], ret: (default_1$8), isOperator: false }], args);
}
function varbitne(...args) {
    return sqlFunction("varbitne", [{ args: [(varbit$1), (varbit$1)], ret: (default_1$8), isOperator: false }], args);
}
function varchar(...args) {
    return sqlFunction("varchar", [{ args: [(name$1)], ret: (varchar$1), isOperator: false }, { args: [(varchar$1), (default_1$4), (default_1$8)], ret: (varchar$1), isOperator: false }], args);
}
function variance(...args) {
    return sqlFunction("variance", [{ args: [(default_1$7)], ret: (default_1$6), isOperator: false }, { args: [(default_1$6)], ret: (default_1$6), isOperator: false }, { args: [(default_1$5)], ret: (default_1$2), isOperator: false }, { args: [(default_1$4)], ret: (default_1$2), isOperator: false }, { args: [(default_1$3)], ret: (default_1$2), isOperator: false }, { args: [(default_1$2)], ret: (default_1$2), isOperator: false }], args);
}
function version(...args) {
    return sqlFunction("version", [{ args: [], ret: (default_1$1), isOperator: false }], args);
}
function websearchToTsquery(...args) {
    return sqlFunction("websearch_to_tsquery", [{ args: [(regconfig), (default_1$1)], ret: (tsquery), isOperator: false }, { args: [(default_1$1)], ret: (tsquery), isOperator: false }], args);
}
function width(...args) {
    return sqlFunction("width", [{ args: [(box$1)], ret: (default_1$6), isOperator: false }], args);
}
function widthBucket(...args) {
    return sqlFunction("width_bucket", [({ T }) => ({ args: [T, Array$1.of(T)], ret: (default_1$4), isOperator: false }), { args: [(default_1$6), (default_1$6), (default_1$6), (default_1$4)], ret: (default_1$4), isOperator: false }, { args: [(default_1$2), (default_1$2), (default_1$2), (default_1$4)], ret: (default_1$4), isOperator: false }], args);
}
function xid(...args) {
    return sqlFunction("xid", [{ args: [(xid8)], ret: (xid$1), isOperator: false }], args);
}
function xid8Larger(...args) {
    return sqlFunction("xid8_larger", [{ args: [(xid8), (xid8)], ret: (xid8), isOperator: false }], args);
}
function xid8Smaller(...args) {
    return sqlFunction("xid8_smaller", [{ args: [(xid8), (xid8)], ret: (xid8), isOperator: false }], args);
}
function xid8Cmp(...args) {
    return sqlFunction("xid8cmp", [{ args: [(xid8), (xid8)], ret: (default_1$4), isOperator: false }], args);
}
function xid8Eq(...args) {
    return sqlFunction("xid8eq", [{ args: [(xid8), (xid8)], ret: (default_1$8), isOperator: false }], args);
}
function xid8Ge(...args) {
    return sqlFunction("xid8ge", [{ args: [(xid8), (xid8)], ret: (default_1$8), isOperator: false }], args);
}
function xid8Gt(...args) {
    return sqlFunction("xid8gt", [{ args: [(xid8), (xid8)], ret: (default_1$8), isOperator: false }], args);
}
function xid8Le(...args) {
    return sqlFunction("xid8le", [{ args: [(xid8), (xid8)], ret: (default_1$8), isOperator: false }], args);
}
function xid8Lt(...args) {
    return sqlFunction("xid8lt", [{ args: [(xid8), (xid8)], ret: (default_1$8), isOperator: false }], args);
}
function xid8Ne(...args) {
    return sqlFunction("xid8ne", [{ args: [(xid8), (xid8)], ret: (default_1$8), isOperator: false }], args);
}
function xideq(...args) {
    return sqlFunction("xideq", [{ args: [(xid$1), (xid$1)], ret: (default_1$8), isOperator: false }], args);
}
function xideqint4(...args) {
    return sqlFunction("xideqint4", [{ args: [(xid$1), (default_1$4)], ret: (default_1$8), isOperator: false }], args);
}
function xidneq(...args) {
    return sqlFunction("xidneq", [{ args: [(xid$1), (xid$1)], ret: (default_1$8), isOperator: false }], args);
}
function xidneqint4(...args) {
    return sqlFunction("xidneqint4", [{ args: [(xid$1), (default_1$4)], ret: (default_1$8), isOperator: false }], args);
}
function xml(...args) {
    return sqlFunction("xml", [{ args: [(default_1$1)], ret: (xml$1), isOperator: false }], args);
}
function xmlIsWellFormed(...args) {
    return sqlFunction("xml_is_well_formed", [{ args: [(default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function xmlIsWellFormedContent(...args) {
    return sqlFunction("xml_is_well_formed_content", [{ args: [(default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function xmlIsWellFormedDocument(...args) {
    return sqlFunction("xml_is_well_formed_document", [{ args: [(default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function xmlagg(...args) {
    return sqlFunction("xmlagg", [{ args: [(xml$1)], ret: (xml$1), isOperator: false }], args);
}
function xmlcomment(...args) {
    return sqlFunction("xmlcomment", [{ args: [(default_1$1)], ret: (xml$1), isOperator: false }], args);
}
function xmlconcat2(...args) {
    return sqlFunction("xmlconcat2", [{ args: [(xml$1), (xml$1)], ret: (xml$1), isOperator: false }], args);
}
function xmlexists(...args) {
    return sqlFunction("xmlexists", [{ args: [(default_1$1), (xml$1)], ret: (default_1$8), isOperator: false }], args);
}
function xmltext(...args) {
    return sqlFunction("xmltext", [{ args: [(default_1$1)], ret: (xml$1), isOperator: false }], args);
}
function xmlvalidate(...args) {
    return sqlFunction("xmlvalidate", [{ args: [(xml$1), (default_1$1)], ret: (default_1$8), isOperator: false }], args);
}
function xpath(...args) {
    return sqlFunction("xpath", [{ args: [(default_1$1), (xml$1)], ret: Array$1.of((xml$1)), isOperator: false }, { args: [(default_1$1), (xml$1), Array$1.of((default_1$1))], ret: Array$1.of((xml$1)), isOperator: false }], args);
}
function xpathExists(...args) {
    return sqlFunction("xpath_exists", [{ args: [(default_1$1), (xml$1)], ret: (default_1$8), isOperator: false }, { args: [(default_1$1), (xml$1), Array$1.of((default_1$1))], ret: (default_1$8), isOperator: false }], args);
}

database({
    person: {
        firstName: (default_1$1),
        lastName: (default_1$1),
        gender: (default_1$1),
        id: (default_1$4),
        createdAt: (timestamp$1),
    },
    kysely_migration: {
        name: (default_1$1),
        timestamp: (default_1$1),
    },
    pet: {
        name: (default_1$1),
        ownerId: (default_1$4),
        species: (default_1$1),
        age: (default_1$4),
        id: (default_1$4),
    },
    kysely_migration_lock: {
        id: (default_1$1),
        is_locked: (default_1$4),
    },
});

// src/dialect.ts

// src/connection.ts
var PGliteConnection = class {
  client;
  constructor(client) {
    this.client = client;
  }
  async executeQuery(compiledQuery) {
    const result = await this.client.query(compiledQuery.sql, [
      ...compiledQuery.parameters
    ]);
    if (result.affectedRows) {
      const numAffectedRows = BigInt(result.affectedRows);
      return {
        numAffectedRows,
        rows: result.rows
      };
    }
    return {
      rows: result.rows
    };
  }
  async *streamQuery(_compiledQuery, _chunkSize) {
    throw new Error("PGLite Driver does not support streaming");
  }
};

// src/dialect.ts
var PGliteDialect = class {
  constructor(pgLite) {
    this.pgLite = pgLite;
  }
  createAdapter() {
    return new PostgresAdapter();
  }
  createDriver() {
    return new PGliteDriver(this.pgLite);
  }
  createQueryCompiler() {
    return new PostgresQueryCompiler();
  }
  createIntrospector(db) {
    return new PostgresIntrospector(db);
  }
};
var PGliteDriver = class {
  client;
  /**
   * Currently used connection.
   * If another acquireConnection() is called the request is queued till this connection has been released.
   */
  connection;
  queue = [];
  constructor(pgLite) {
    this.client = pgLite;
  }
  async init() {
  }
  // Serialize access to the connection, i.e. promise is only resolved when the last connection was released.
  async acquireConnection() {
    if (this.client === void 0) {
      throw new Error("PGLite not initialized");
    }
    if (this.connection !== void 0) {
      return new Promise((resolve) => {
        this.queue.push(resolve);
      });
    }
    this.connection = new PGliteConnection(this.client);
    return this.connection;
  }
  async releaseConnection(connection) {
    if (connection !== this.connection) {
      throw new Error("Invalid connection");
    }
    const removed = this.queue.splice(0, 1);
    const next = removed[0];
    if (next === void 0) {
      this.connection = void 0;
      return;
    }
    next(this.connection);
  }
  async beginTransaction(conn, settings) {
    if (settings.isolationLevel) {
      await conn.executeQuery(
        CompiledQuery.raw(
          `start transaction isolation level ${settings.isolationLevel}`
        )
      );
    } else {
      await conn.executeQuery(CompiledQuery.raw("begin"));
    }
  }
  async commitTransaction(conn) {
    await conn.executeQuery(CompiledQuery.raw("commit"));
  }
  async rollbackTransaction(conn) {
    await conn.executeQuery(CompiledQuery.raw("rollback"));
  }
  async destroy() {
    this.client = void 0;
  }
};

const db = async (dbConfig) => {
    if (dbConfig.type === "pg") {
        const { PoolClass, config } = dbConfig;
        return new Kysely({
            dialect: new PostgresDialect({
                pool: new PoolClass({
                    ...config,
                    types: {
                        getTypeParser: (_oid, format) => {
                            if (format === "binary") {
                                throw new Error("Binary format not supported");
                            }
                            return (v) => v;
                        },
                    },
                }),
            }),
        });
    }
    if (dbConfig.type === "pglite") {
        const { PGliteClass, options } = dbConfig;
        return new Kysely({
            dialect: new PGliteDialect(await PGliteClass.create({
                ...options,
                parsers: Object.fromEntries(Array(2000).keys().map((value) => {
                    return [value, (x) => x];
                })),
            })),
        });
    }
    throw new Error("Invalid database configuration");
};

export { aclitem as Aclitem, Any, anyenum as Anyenum, anymultirange as Anymultirange, anynonarray as Anynonarray, anyrange as Anyrange, Array$1 as Array, BinaryOperatorExpression, bit$1 as Bit, default_1$8 as Bool, box$1 as Box, bpchar$1 as Bpchar, bytea as Bytea, char$1 as Char, cid as Cid, cidr$1 as Cidr, circle$1 as Circle, ColumnAliasExpression, Context, date$1 as Date, datemultirange$1 as Datemultirange, daterange$1 as Daterange, Expression, default_1$7 as Float4, default_1$6 as Float8, FunctionExpression, Generated, inet as Inet, default_1$5 as Int2, int2vector as Int2Vector, default_1$4 as Int4, int4multirange as Int4Multirange, int4range as Int4Range, default_1$3 as Int8, int8multirange as Int8Multirange, int8range as Int8Range, interval$1 as Interval, json as Json, jsonb as Jsonb, jsonpath as Jsonpath, language_handler as LanguageHandler, line$1 as Line, LiteralExpression, LiteralUnknownExpression, lseg$1 as Lseg, macaddr$1 as Macaddr, macaddr8$1 as Macaddr8, money$1 as Money, name$1 as Name, default_1$2 as Numeric, nummultirange$1 as Nummultirange, numrange$1 as Numrange, oid$1 as Oid, oidvector as Oidvector, path$1 as Path, pg_ddl_command as PgDdlCommand, pg_lsn as PgLsn, pg_mcv_list as PgMcvList, pg_node_tree as PgNodeTree, pg_snapshot as PgSnapshot, point$1 as Point, polygon$1 as Polygon, QueryAlias, RawTableReferenceExpression, Record, refcursor as Refcursor, regclass$1 as Regclass, regcollation as Regcollation, regconfig as Regconfig, regdictionary as Regdictionary, regnamespace as Regnamespace, regoper as Regoper, regoperator as Regoperator, regproc as Regproc, regprocedure as Regprocedure, regrole as Regrole, regtype as Regtype, SelectableExpression, SelectableFunctionExpression, Setof, SubqueryExpression, TableReferenceExpression, default_1$1 as Text, tid as Tid, time$1 as Time, timestamp$1 as Timestamp, timestamptz$1 as Timestamptz, timetz$1 as Timetz, trigger as Trigger, tsmultirange$1 as Tsmultirange, tsquery as Tsquery, tsrange$1 as Tsrange, tstzmultirange$1 as Tstzmultirange, tstzrange$1 as Tstzrange, tsvector as Tsvector, txid_snapshot as TxidSnapshot, uuid as Uuid, ValuesExpression, varbit$1 as Varbit, varchar$1 as Varchar, _void as Void, xid$1 as Xid, xid8 as Xid8, xml$1 as Xml, abbrev, abs, aclcontains, acldefault, aclexplode, aclinsert, aclitemeq, aclremove, acos, acosd, acosh, age, aliasRowLike, aliasScalar, amvalidate, anyValue, anyValueTransfn, anytextcat, area, arrayAgg, arrayAppend, arrayCat, arrayDims, arrayEq, arrayFill, arrayGe, arrayGt, arrayLarger, arrayLe, arrayLength, arrayLower, arrayLt, arrayNdims, arrayNe, arrayPosition, arrayPositions, arrayPrepend, arrayRemove, arrayReplace, arraySample, arrayShuffle, arraySmaller, arrayToJson, arrayToString, arrayToTsvector, arrayUpper, arraycontained, arraycontains, arrayoverlap, ascii, asind, asinh, atan, atan2, atan2D, atand, atanh, avg, binaryUpgradeAddSubRelState, binaryUpgradeCreateEmptyExtension, binaryUpgradeLogicalSlotHasCaughtUp, binaryUpgradeReploriginAdvance, binaryUpgradeSetMissingValue, binaryUpgradeSetNextArrayPgTypeOid, binaryUpgradeSetNextHeapPgClassOid, binaryUpgradeSetNextHeapRelfilenode, binaryUpgradeSetNextIndexPgClassOid, binaryUpgradeSetNextIndexRelfilenode, binaryUpgradeSetNextMultirangeArrayPgTypeOid, binaryUpgradeSetNextMultirangePgTypeOid, binaryUpgradeSetNextPgAuthidOid, binaryUpgradeSetNextPgEnumOid, binaryUpgradeSetNextPgTablespaceOid, binaryUpgradeSetNextPgTypeOid, binaryUpgradeSetNextToastPgClassOid, binaryUpgradeSetNextToastRelfilenode, binaryUpgradeSetRecordInitPrivs, bit, bitAnd, bitCount, bitLength, bitOr, bitXor, bitand, bitcat, bitcmp, biteq, bitge, bitgt, bitle, bitlt, bitne, bitnot, bitor, bitshiftleft, bitshiftright, bitxor, bool, boolAnd, boolOr, boolandStatefunc, booleq, boolge, boolgt, boolle, boollt, boolne, boolorStatefunc, boundBox, box, boxAbove, boxAboveEq, boxAdd, boxBelow, boxBelowEq, boxCenter, boxContainPt, boxContained, boxDistance, boxDiv, boxEq, boxGe, boxGt, boxIntersect, boxLe, boxLeft, boxLt, boxMul, boxOverabove, boxOverbelow, boxOverlap, boxOverleft, boxOverright, boxRight, boxSame, boxSub, bpchar, bpcharLarger, bpcharPatternGe, bpcharPatternGt, bpcharPatternLe, bpcharPatternLt, bpcharSmaller, bpcharcmp, bpchareq, bpcharge, bpchargt, bpchariclike, bpcharicnlike, bpcharicregexeq, bpcharicregexne, bpcharle, bpcharlike, bpcharlt, bpcharne, bpcharnlike, bpcharregexeq, bpcharregexne, brinDesummarizeRange, brinSummarizeNewValues, brinSummarizeRange, broadcast, btarraycmp, btboolcmp, btbpcharPatternCmp, btcharcmp, btequalimage, btfloat48Cmp, btfloat4Cmp, btfloat84Cmp, btfloat8Cmp, btint24Cmp, btint28Cmp, btint2Cmp, btint42Cmp, btint48Cmp, btint4Cmp, btint82Cmp, btint84Cmp, btint8Cmp, btnamecmp, btnametextcmp, btoidcmp, btoidvectorcmp, btrecordcmp, btrecordimagecmp, btrim, bttextPatternCmp, bttextcmp, bttextnamecmp, bttidcmp, btvarstrequalimage, byteacat, byteacmp, byteaeq, byteage, byteagt, byteale, bytealike, bytealt, byteane, byteanlike, cardinality, cashCmp, cashDivCash, cashDivFlt4, cashDivFlt8, cashDivInt2, cashDivInt4, cashDivInt8, cashEq, cashGe, cashGt, cashLe, cashLt, cashMi, cashMulFlt4, cashMulFlt8, cashMulInt2, cashMulInt4, cashMulInt8, cashNe, cashPl, cashWords, cashlarger, cashsmaller, cbrt, ceil, ceiling, center, char, charLength, characterLength, chareq, charge, chargt, charle, charlt, charne, chr, cideq, cidr, circle, circleAbove, circleAddPt, circleBelow, circleCenter, circleContainPt, circleContained, circleDistance, circleDivPt, circleEq, circleGe, circleGt, circleLe, circleLeft, circleLt, circleMulPt, circleNe, circleOverabove, circleOverbelow, circleOverlap, circleOverleft, circleOverright, circleRight, circleSame, circleSubPt, clockTimestamp, closeLs, closeLseg, closePb, closePl, closePs, closeSb, colDescription, concat, concatWs, convert, convertFrom, convertTo, corr, cos, cosd, cosh, cot, cotd, count, covarPop, covarSamp, cumeDist, currentDatabase, currentQuery, currentSchema, currentSchemas, currentSetting, currentUser, currtid2, currval, cursorToXml, cursorToXmlschema, database, databaseToXml, databaseToXmlAndXmlschema, databaseToXmlschema, date, dateAdd, dateCmp, dateCmpTimestamp, dateCmpTimestamptz, dateEq, dateEqTimestamp, dateEqTimestamptz, dateGe, dateGeTimestamp, dateGeTimestamptz, dateGt, dateGtTimestamp, dateGtTimestamptz, dateLarger, dateLe, dateLeTimestamp, dateLeTimestamptz, dateLt, dateLtTimestamp, dateLtTimestamptz, dateMi, dateMiInterval, dateMii, dateNe, dateNeTimestamp, dateNeTimestamptz, datePart, datePlInterval, datePli, dateSmaller, dateSubtract, dateTrunc, datemultirange, daterange, daterangeCanonical, daterangeSubdiff, datetimePl, datetimetzPl, db, dcbrt, decode, degrees, denseRank, dexp, diagonal, diameter, distBp, distBs, distCpoint, distCpoly, distLp, distLs, distPathp, distPb, distPc, distPl, distPolyc, distPolyp, distPpath, distPpoly, distPs, distSb, distSl, distSp, div, dlog1, dlog10, dpow, dround, dsqrt, dtrunc, elemContainedByMultirange, elemContainedByRange, encode, enumCmp, enumEq, enumFirst, enumGe, enumGt, enumLarger, enumLast, enumLe, enumLt, enumNe, enumRange, enumSmaller, erf, erfc, every, exp, extract, factorial, family, firstValue, float4, float48Div, float48Eq, float48Ge, float48Gt, float48Le, float48Lt, float48Mi, float48Mul, float48Ne, float48Pl, float4Abs, float4Accum, float4Div, float4Eq, float4Ge, float4Gt, float4Larger, float4Le, float4Lt, float4Mi, float4Mul, float4Ne, float4Pl, float4Smaller, float4Um, float4Up, float8, float84Div, float84Eq, float84Ge, float84Gt, float84Le, float84Lt, float84Mi, float84Mul, float84Ne, float84Pl, float8Abs, float8Accum, float8Avg, float8Combine, float8Corr, float8CovarPop, float8CovarSamp, float8Div, float8Eq, float8Ge, float8Gt, float8Larger, float8Le, float8Lt, float8Mi, float8Mul, float8Ne, float8Pl, float8RegrAccum, float8RegrAvgx, float8RegrAvgy, float8RegrCombine, float8RegrIntercept, float8RegrR2, float8RegrSlope, float8RegrSxx, float8RegrSxy, float8RegrSyy, float8Smaller, float8StddevPop, float8StddevSamp, float8Um, float8Up, float8VarPop, float8VarSamp, floor, flt4MulCash, flt8MulCash, fmgrCValidator, fmgrInternalValidator, fmgrSqlValidator, format, formatType, gcd, genRandomUuid, generateSeries, generateSubscripts, getBit, getByte, getCurrentTsConfig, getdatabaseencoding, getpgusername, ginCleanPendingList, ginCmpTslexeme, ginCompareJsonb, hasAnyColumnPrivilege, hasColumnPrivilege, hasDatabasePrivilege, hasForeignDataWrapperPrivilege, hasFunctionPrivilege, hasLanguagePrivilege, hasParameterPrivilege, hasSchemaPrivilege, hasSequencePrivilege, hasServerPrivilege, hasTablePrivilege, hasTablespacePrivilege, hasTypePrivilege, hashAclitem, hashAclitemExtended, hashArray, hashArrayExtended, hashMultirange, hashMultirangeExtended, hashNumeric, hashNumericExtended, hashRange, hashRangeExtended, hashRecord, hashRecordExtended, hashbpchar, hashbpcharextended, hashchar, hashcharextended, hashenum, hashenumextended, hashfloat4, hashfloat4Extended, hashfloat8, hashfloat8Extended, hashinet, hashinetextended, hashint2, hashint2Extended, hashint4, hashint4Extended, hashint8, hashint8Extended, hashmacaddr, hashmacaddr8, hashmacaddr8Extended, hashmacaddrextended, hashname, hashnameextended, hashoid, hashoidextended, hashoidvector, hashoidvectorextended, hashtext, hashtextextended, hashtid, hashtidextended, height, host, hostmask, icuUnicodeVersion, inRange, inetClientAddr, inetClientPort, inetMerge, inetSameFamily, inetServerAddr, inetServerPort, inetand, inetmi, inetmiInt8, inetnot, inetor, inetpl, initcap, int2, int24Div, int24Eq, int24Ge, int24Gt, int24Le, int24Lt, int24Mi, int24Mul, int24Ne, int24Pl, int28Div, int28Eq, int28Ge, int28Gt, int28Le, int28Lt, int28Mi, int28Mul, int28Ne, int28Pl, int2Abs, int2And, int2AvgAccum, int2AvgAccumInv, int2Div, int2Eq, int2Ge, int2Gt, int2Int4Sum, int2Larger, int2Le, int2Lt, int2Mi, int2Mod, int2Mul, int2MulCash, int2Ne, int2Not, int2Or, int2Pl, int2Shl, int2Shr, int2Smaller, int2Sum, int2Um, int2Up, int2Xor, int4, int42Div, int42Eq, int42Ge, int42Gt, int42Le, int42Lt, int42Mi, int42Mul, int42Ne, int42Pl, int48Div, int48Eq, int48Ge, int48Gt, int48Le, int48Lt, int48Mi, int48Mul, int48Ne, int48Pl, int4Abs, int4And, int4AvgAccum, int4AvgAccumInv, int4AvgCombine, int4Div, int4Eq, int4Ge, int4Gt, int4Inc, int4Larger, int4Le, int4Lt, int4Mi, int4Mod, int4Mul, int4MulCash, int4Multirange, int4Ne, int4Not, int4Or, int4Pl, int4Range, int4RangeCanonical, int4RangeSubdiff, int4Shl, int4Shr, int4Smaller, int4Sum, int4Um, int4Up, int4Xor, int8, int82Div, int82Eq, int82Ge, int82Gt, int82Le, int82Lt, int82Mi, int82Mul, int82Ne, int82Pl, int84Div, int84Eq, int84Ge, int84Gt, int84Le, int84Lt, int84Mi, int84Mul, int84Ne, int84Pl, int8Abs, int8And, int8Avg, int8Dec, int8DecAny, int8Div, int8Eq, int8Ge, int8Gt, int8Inc, int8IncAny, int8IncFloat8Float8, int8Larger, int8Le, int8Lt, int8Mi, int8Mod, int8Mul, int8MulCash, int8Multirange, int8Ne, int8Not, int8Or, int8Pl, int8PlInet, int8Range, int8RangeCanonical, int8RangeSubdiff, int8Shl, int8Shr, int8Smaller, int8Sum, int8Um, int8Up, int8Xor, integerPlDate, interLb, interSb, interSl, interval, intervalCmp, intervalDiv, intervalEq, intervalGe, intervalGt, intervalHash, intervalHashExtended, intervalLarger, intervalLe, intervalLt, intervalMi, intervalMul, intervalNe, intervalPl, intervalPlDate, intervalPlTime, intervalPlTimestamp, intervalPlTimestamptz, intervalPlTimetz, intervalSmaller, intervalUm, isNormalized, isScalar, isScalarRelaxed, isclosed, isempty, isfinite, ishorizontal, isopen, isparallel, isperp, isvertical, jsonAgg, jsonAggStrict, jsonArrayElement, jsonArrayElementText, jsonArrayElements, jsonArrayElementsText, jsonArrayLength, jsonBuildArray, jsonBuildObject, jsonEach, jsonEachText, jsonExtractPath, jsonExtractPathText, jsonObject, jsonObjectAgg, jsonObjectAggStrict, jsonObjectAggUnique, jsonObjectAggUniqueStrict, jsonObjectField, jsonObjectFieldText, jsonObjectKeys, jsonPopulateRecord, jsonPopulateRecordset, jsonStripNulls, jsonToRecord, jsonToRecordset, jsonToTsvector, jsonTypeof, jsonbAgg, jsonbAggStrict, jsonbArrayElement, jsonbArrayElementText, jsonbArrayElements, jsonbArrayElementsText, jsonbArrayLength, jsonbBuildArray, jsonbBuildObject, jsonbCmp, jsonbConcat, jsonbContained, jsonbContains, jsonbDelete, jsonbDeletePath, jsonbEach, jsonbEachText, jsonbEq, jsonbExists, jsonbExistsAll, jsonbExistsAny, jsonbExtractPath, jsonbExtractPathText, jsonbGe, jsonbGt, jsonbHash, jsonbHashExtended, jsonbInsert, jsonbLe, jsonbLt, jsonbNe, jsonbObject, jsonbObjectAgg, jsonbObjectAggStrict, jsonbObjectAggUnique, jsonbObjectAggUniqueStrict, jsonbObjectField, jsonbObjectFieldText, jsonbObjectKeys, jsonbPathExists, jsonbPathExistsOpr, jsonbPathExistsTz, jsonbPathMatch, jsonbPathMatchOpr, jsonbPathMatchTz, jsonbPathQuery, jsonbPathQueryArray, jsonbPathQueryArrayTz, jsonbPathQueryFirst, jsonbPathQueryFirstTz, jsonbPathQueryTz, jsonbPopulateRecord, jsonbPopulateRecordValid, jsonbPopulateRecordset, jsonbPretty, jsonbSet, jsonbSetLax, jsonbStripNulls, jsonbToRecord, jsonbToRecordset, jsonbToTsvector, jsonbTypeof, justifyDays, justifyHours, justifyInterval, lag, lastValue, lastval, lcm, lead, left, length, like, likeEscape, line, lineDistance, lineEq, lineHorizontal, lineInterpt, lineIntersect, lineParallel, linePerp, lineVertical, ln, loClose, loCreat, loCreate, loExport, loFromBytea, loGet, loImport, loLseek, loLseek64, loOpen, loPut, loTell, loTell64, loTruncate, loTruncate64, loUnlink, log, log10, loread, lower, lowerInc, lowerInf, lowrite, lpad, lseg, lsegCenter, lsegDistance, lsegEq, lsegGe, lsegGt, lsegHorizontal, lsegInterpt, lsegIntersect, lsegLe, lsegLength, lsegLt, lsegNe, lsegParallel, lsegPerp, lsegVertical, ltrim, macaddr, macaddr8, macaddr8And, macaddr8Cmp, macaddr8Eq, macaddr8Ge, macaddr8Gt, macaddr8Le, macaddr8Lt, macaddr8Ne, macaddr8Not, macaddr8Or, macaddr8Set7Bit, macaddrAnd, macaddrCmp, macaddrEq, macaddrGe, macaddrGt, macaddrLe, macaddrLt, macaddrNe, macaddrNot, macaddrOr, makeDate, makeInterval, makeTime, makeTimestamp, makeTimestamptz, makeaclitem, masklen, max, md5, minScale, mod, mode, money, mulDInterval, multirange, multirangeAdjacentMultirange, multirangeAdjacentRange, multirangeAfterMultirange, multirangeAfterRange, multirangeBeforeMultirange, multirangeBeforeRange, multirangeCmp, multirangeContainedByMultirange, multirangeContainedByRange, multirangeContainsElem, multirangeContainsMultirange, multirangeContainsRange, multirangeEq, multirangeGe, multirangeGt, multirangeIntersect, multirangeIntersectAggTransfn, multirangeLe, multirangeLt, multirangeMinus, multirangeNe, multirangeOverlapsMultirange, multirangeOverlapsRange, multirangeOverleftMultirange, multirangeOverleftRange, multirangeOverrightMultirange, multirangeOverrightRange, multirangeUnion, mxidAge, name, nameconcatoid, nameeq, nameeqtext, namege, namegetext, namegt, namegttext, nameiclike, nameicnlike, nameicregexeq, nameicregexne, namele, nameletext, namelike, namelt, namelttext, namene, namenetext, namenlike, nameregexeq, nameregexne, netmask, network, networkCmp, networkEq, networkGe, networkGt, networkLarger, networkLe, networkLt, networkNe, networkOverlap, networkSmaller, networkSub, networkSubeq, networkSup, networkSupeq, nextval, normalize, notlike, now, npoints, nthValue, ntile, numNonnulls, numNulls, numeric, numericAbs, numericAdd, numericCmp, numericDiv, numericDivTrunc, numericEq, numericExp, numericGe, numericGt, numericInc, numericLarger, numericLe, numericLn, numericLog, numericLt, numericMod, numericMul, numericNe, numericPlPgLsn, numericPower, numericSmaller, numericSqrt, numericSub, numericUminus, numericUplus, nummultirange, numnode, numrange, numrangeSubdiff, objDescription, octetLength, oid, oideq, oidge, oidgt, oidlarger, oidle, oidlt, oidne, oidsmaller, oidvectoreq, oidvectorge, oidvectorgt, oidvectorle, oidvectorlt, oidvectorne, oidvectortypes, onPb, onPl, onPpath, onPs, onSb, onSl, overlaps, overlay, parseIdent, path, pathAdd, pathAddPt, pathContainPt, pathDistance, pathDivPt, pathInter, pathLength, pathMulPt, pathNEq, pathNGe, pathNGt, pathNLe, pathNLt, pathNpoints, pathSubPt, pclose, percentRank, percentileCont, percentileDisc, pgAdvisoryLock, pgAdvisoryLockShared, pgAdvisoryUnlock, pgAdvisoryUnlockAll, pgAdvisoryUnlockShared, pgAdvisoryXactLock, pgAdvisoryXactLockShared, pgAvailableExtensionVersions, pgAvailableExtensions, pgAvailableWalSummaries, pgBackendPid, pgBackupStart, pgBackupStop, pgBasetype, pgBlockingPids, pgCancelBackend, pgCharToEncoding, pgClientEncoding, pgCollationActualVersion, pgCollationFor, pgCollationIsVisible, pgColumnCompression, pgColumnIsUpdatable, pgColumnSize, pgColumnToastChunkId, pgConfLoadTime, pgConfig, pgControlCheckpoint, pgControlInit, pgControlRecovery, pgControlSystem, pgConversionIsVisible, pgCopyLogicalReplicationSlot, pgCopyPhysicalReplicationSlot, pgCreateLogicalReplicationSlot, pgCreatePhysicalReplicationSlot, pgCreateRestorePoint, pgCurrentLogfile, pgCurrentSnapshot, pgCurrentWalFlushLsn, pgCurrentWalInsertLsn, pgCurrentWalLsn, pgCurrentXactId, pgCurrentXactIdIfAssigned, pgCursor, pgDatabaseCollationActualVersion, pgDatabaseSize, pgDescribeObject, pgDropReplicationSlot, pgEncodingMaxLength, pgEncodingToChar, pgEventTriggerDdlCommands, pgEventTriggerDroppedObjects, pgEventTriggerTableRewriteOid, pgEventTriggerTableRewriteReason, pgExportSnapshot, pgExtensionConfigDump, pgExtensionUpdatePaths, pgFilenodeRelation, pgFunctionIsVisible, pgGetBackendMemoryContexts, pgGetCatalogForeignKeys, pgGetConstraintdef, pgGetExpr, pgGetFunctionArgDefault, pgGetFunctionArguments, pgGetFunctionIdentityArguments, pgGetFunctionResult, pgGetFunctionSqlbody, pgGetFunctiondef, pgGetIndexdef, pgGetKeywords, pgGetMultixactMembers, pgGetObjectAddress, pgGetPartitionConstraintdef, pgGetPartkeydef, pgGetPublicationTables, pgGetReplicaIdentityIndex, pgGetReplicationSlots, pgGetRuledef, pgGetSerialSequence, pgGetShmemAllocations, pgGetStatisticsobjdef, pgGetStatisticsobjdefColumns, pgGetStatisticsobjdefExpressions, pgGetTriggerdef, pgGetUserbyid, pgGetViewdef, pgGetWaitEvents, pgGetWalReplayPauseState, pgGetWalResourceManagers, pgGetWalSummarizerState, pgHasRole, pgHbaFileRules, pgIdentFileMappings, pgIdentifyObject, pgIdentifyObjectAsAddress, pgImportSystemCollations, pgIndexColumnHasProperty, pgIndexHasProperty, pgIndexamHasProperty, pgIndexamProgressPhasename, pgIndexesSize, pgInputErrorInfo, pgInputIsValid, pgIsInRecovery, pgIsOtherTempSchema, pgIsWalReplayPaused, pgIsolationTestSessionIsBlocked, pgJitAvailable, pgLastCommittedXact, pgLastWalReceiveLsn, pgLastWalReplayLsn, pgLastXactReplayTimestamp, pgListeningChannels, pgLockStatus, pgLogBackendMemoryContexts, pgLogStandbySnapshot, pgLogicalEmitMessage, pgLogicalSlotGetBinaryChanges, pgLogicalSlotGetChanges, pgLogicalSlotPeekBinaryChanges, pgLogicalSlotPeekChanges, pgLsArchiveStatusdir, pgLsDir, pgLsLogdir, pgLsLogicalmapdir, pgLsLogicalsnapdir, pgLsReplslotdir, pgLsTmpdir, pgLsWaldir, pgLsn, pgLsnCmp, pgLsnEq, pgLsnGe, pgLsnGt, pgLsnHash, pgLsnHashExtended, pgLsnLarger, pgLsnLe, pgLsnLt, pgLsnMi, pgLsnMii, pgLsnNe, pgLsnPli, pgLsnSmaller, pgMcvListItems, pgMyTempSchema, pgNextoid, pgNotificationQueueUsage, pgNotify, pgOpclassIsVisible, pgOperatorIsVisible, pgOpfamilyIsVisible, pgOptionsToTable, pgPartitionAncestors, pgPartitionRoot, pgPartitionTree, pgPostmasterStartTime, pgPreparedStatement, pgPreparedXact, pgPromote, pgReadBinaryFile, pgReadFile, pgRelationFilenode, pgRelationFilepath, pgRelationIsPublishable, pgRelationIsUpdatable, pgRelationSize, pgReloadConf, pgReplicationOriginAdvance, pgReplicationOriginCreate, pgReplicationOriginDrop, pgReplicationOriginOid, pgReplicationOriginProgress, pgReplicationOriginSessionIsSetup, pgReplicationOriginSessionProgress, pgReplicationOriginSessionReset, pgReplicationOriginSessionSetup, pgReplicationOriginXactReset, pgReplicationOriginXactSetup, pgReplicationSlotAdvance, pgRotateLogfile, pgSafeSnapshotBlockingPids, pgSequenceLastValue, pgSequenceParameters, pgSettingsGetFlags, pgShowAllFileSettings, pgShowAllSettings, pgShowReplicationOriginStatus, pgSizeBytes, pgSizePretty, pgSleep, pgSleepFor, pgSleepUntil, pgSnapshotXip, pgSnapshotXmax, pgSplitWalfileName, pgStatClearSnapshot, pgStatFile, pgStatForceNextFlush, pgStatGetActivity, pgStatGetAnalyzeCount, pgStatGetArchiver, pgStatGetAutoanalyzeCount, pgStatGetAutovacuumCount, pgStatGetBackendActivity, pgStatGetBackendActivityStart, pgStatGetBackendClientAddr, pgStatGetBackendClientPort, pgStatGetBackendDbid, pgStatGetBackendIdset, pgStatGetBackendPid, pgStatGetBackendStart, pgStatGetBackendSubxact, pgStatGetBackendUserid, pgStatGetBackendWaitEvent, pgStatGetBackendWaitEventType, pgStatGetBackendXactStart, pgStatGetBgwriterBufWrittenClean, pgStatGetBgwriterMaxwrittenClean, pgStatGetBgwriterStatResetTime, pgStatGetBlocksFetched, pgStatGetBlocksHit, pgStatGetBufAlloc, pgStatGetCheckpointerBuffersWritten, pgStatGetCheckpointerNumRequested, pgStatGetCheckpointerNumTimed, pgStatGetCheckpointerRestartpointsPerformed, pgStatGetCheckpointerRestartpointsRequested, pgStatGetCheckpointerRestartpointsTimed, pgStatGetCheckpointerStatResetTime, pgStatGetCheckpointerSyncTime, pgStatGetCheckpointerWriteTime, pgStatGetDbActiveTime, pgStatGetDbBlkReadTime, pgStatGetDbBlkWriteTime, pgStatGetDbBlocksFetched, pgStatGetDbBlocksHit, pgStatGetDbChecksumFailures, pgStatGetDbChecksumLastFailure, pgStatGetDbConflictAll, pgStatGetDbConflictLock, pgStatGetDbConflictLogicalslot, pgStatGetDbConflictSnapshot, pgStatGetDbConflictStartupDeadlock, pgStatGetDbConflictTablespace, pgStatGetDbDeadlocks, pgStatGetDbIdleInTransactionTime, pgStatGetDbNumbackends, pgStatGetDbSessionTime, pgStatGetDbSessions, pgStatGetDbSessionsAbandoned, pgStatGetDbSessionsFatal, pgStatGetDbSessionsKilled, pgStatGetDbStatResetTime, pgStatGetDbTempBytes, pgStatGetDbTempFiles, pgStatGetDbTuplesDeleted, pgStatGetDbTuplesFetched, pgStatGetDbTuplesInserted, pgStatGetDbTuplesReturned, pgStatGetDbTuplesUpdated, pgStatGetDbXactCommit, pgStatGetDbXactRollback, pgStatGetDeadTuples, pgStatGetFunctionCalls, pgStatGetFunctionSelfTime, pgStatGetFunctionTotalTime, pgStatGetInsSinceVacuum, pgStatGetIo, pgStatGetLastAnalyzeTime, pgStatGetLastAutoanalyzeTime, pgStatGetLastAutovacuumTime, pgStatGetLastVacuumTime, pgStatGetLastscan, pgStatGetLiveTuples, pgStatGetModSinceAnalyze, pgStatGetNumscans, pgStatGetProgressInfo, pgStatGetRecoveryPrefetch, pgStatGetReplicationSlot, pgStatGetSlru, pgStatGetSnapshotTimestamp, pgStatGetSubscription, pgStatGetSubscriptionStats, pgStatGetTuplesDeleted, pgStatGetTuplesFetched, pgStatGetTuplesHotUpdated, pgStatGetTuplesInserted, pgStatGetTuplesNewpageUpdated, pgStatGetTuplesReturned, pgStatGetTuplesUpdated, pgStatGetVacuumCount, pgStatGetWal, pgStatGetWalReceiver, pgStatGetWalSenders, pgStatGetXactBlocksFetched, pgStatGetXactBlocksHit, pgStatGetXactFunctionCalls, pgStatGetXactFunctionSelfTime, pgStatGetXactFunctionTotalTime, pgStatGetXactNumscans, pgStatGetXactTuplesDeleted, pgStatGetXactTuplesFetched, pgStatGetXactTuplesHotUpdated, pgStatGetXactTuplesInserted, pgStatGetXactTuplesNewpageUpdated, pgStatGetXactTuplesReturned, pgStatGetXactTuplesUpdated, pgStatHaveStats, pgStatReset, pgStatResetReplicationSlot, pgStatResetShared, pgStatResetSingleFunctionCounters, pgStatResetSingleTableCounters, pgStatResetSlru, pgStatResetSubscriptionStats, pgStatisticsObjIsVisible, pgStopMakingPinnedObjects, pgSwitchWal, pgSyncReplicationSlots, pgTableIsVisible, pgTableSize, pgTablespaceDatabases, pgTablespaceLocation, pgTablespaceSize, pgTerminateBackend, pgTimezoneAbbrevs, pgTimezoneNames, pgTotalRelationSize, pgTriggerDepth, pgTryAdvisoryLock, pgTryAdvisoryLockShared, pgTryAdvisoryXactLock, pgTryAdvisoryXactLockShared, pgTsConfigIsVisible, pgTsDictIsVisible, pgTsParserIsVisible, pgTsTemplateIsVisible, pgTypeIsVisible, pgTypeof, pgVisibleInSnapshot, pgWalLsnDiff, pgWalReplayPause, pgWalReplayResume, pgWalSummaryContents, pgWalfileName, pgWalfileNameOffset, pgXactCommitTimestamp, pgXactStatus, phrasetoTsquery, pi, plaintoTsquery, plpgsqlCallHandler, plpgsqlValidator, point, pointAbove, pointAdd, pointBelow, pointDistance, pointDiv, pointEq, pointHoriz, pointLeft, pointMul, pointNe, pointRight, pointSub, pointVert, polyAbove, polyBelow, polyCenter, polyContainPt, polyContained, polyDistance, polyLeft, polyNpoints, polyOverabove, polyOverbelow, polyOverlap, polyOverleft, polyOverright, polyRight, polySame, polygon, popen, position, postgresqlFdwValidator, pow, power, ptContainedCircle, ptContainedPoly, queryToXml, queryToXmlAndXmlschema, queryToXmlschema, querytree, quoteIdent, quoteLiteral, quoteNullable, radians, radius, random, randomNormal, rangeAdjacent, rangeAdjacentMultirange, rangeAfter, rangeAfterMultirange, rangeAgg, rangeBefore, rangeBeforeMultirange, rangeCmp, rangeContainedBy, rangeContainedByMultirange, rangeContains, rangeContainsElem, rangeContainsMultirange, rangeEq, rangeGe, rangeGt, rangeIntersect, rangeIntersectAgg, rangeIntersectAggTransfn, rangeLe, rangeLt, rangeMerge, rangeMinus, rangeNe, rangeOverlaps, rangeOverlapsMultirange, rangeOverleft, rangeOverleftMultirange, rangeOverright, rangeOverrightMultirange, rangeUnion, rank, recordEq, recordGe, recordGt, recordImageEq, recordImageGe, recordImageGt, recordImageLe, recordImageLt, recordImageNe, recordLe, recordLt, recordNe, regclass, regexpCount, regexpInstr, regexpLike, regexpMatch, regexpMatches, regexpReplace, regexpSplitToArray, regexpSplitToTable, regexpSubstr, regrAvgx, regrAvgy, regrCount, regrIntercept, regrR2, regrSlope, regrSxx, regrSxy, regrSyy, repeat, replace, resultType, reverse, riFKeyCascadeDel, riFKeyCascadeUpd, riFKeyCheckIns, riFKeyCheckUpd, riFKeyNoactionDel, riFKeyNoactionUpd, riFKeyRestrictDel, riFKeyRestrictUpd, riFKeySetdefaultDel, riFKeySetdefaultUpd, riFKeySetnullDel, riFKeySetnullUpd, right, round, rowNumber, rowSecurityActive, rowToJson, rpad, rtrim, satisfiesHashPartition, scale, schemaToXml, schemaToXmlAndXmlschema, schemaToXmlschema, sessionUser, setBit, setByte, setConfig, setMasklen, setseed, setval, setweight, sha224, sha256, sha384, sha512, shobjDescription, sign, similarEscape, similarToEscape, sind, sinh, slope, spgPolyQuadCompress, splitPart, sqlFunction, sqrt, startsWith, statementTimestamp, stddev, stddevPop, stddevSamp, stringAgg, stringToArray, stringToTable, strip, strpos, substr, substring, sum, suppressRedundantUpdatesTrigger, systemUser, tableToXml, tableToXmlAndXmlschema, tableToXmlschema, tan, tand, tanh, text, textGe, textGt, textLarger, textLe, textLt, textPatternGe, textPatternGt, textPatternLe, textPatternLt, textSmaller, textanycat, textcat, texteq, texteqname, textgename, textgtname, texticlike, texticnlike, texticregexeq, texticregexne, textlen, textlename, textlike, textltname, textne, textnename, textnlike, textregexeq, textregexne, tideq, tidge, tidgt, tidlarger, tidle, tidlt, tidne, tidsmaller, time, timeCmp, timeEq, timeGe, timeGt, timeHash, timeHashExtended, timeLarger, timeLe, timeLt, timeMiInterval, timeMiTime, timeNe, timePlInterval, timeSmaller, timedatePl, timeofday, timestamp, timestampCmp, timestampCmpDate, timestampCmpTimestamptz, timestampEq, timestampEqDate, timestampEqTimestamptz, timestampGe, timestampGeDate, timestampGeTimestamptz, timestampGt, timestampGtDate, timestampGtTimestamptz, timestampHash, timestampHashExtended, timestampLarger, timestampLe, timestampLeDate, timestampLeTimestamptz, timestampLt, timestampLtDate, timestampLtTimestamptz, timestampMi, timestampMiInterval, timestampNe, timestampNeDate, timestampNeTimestamptz, timestampPlInterval, timestampSmaller, timestamptz, timestamptzCmp, timestamptzCmpDate, timestamptzCmpTimestamp, timestamptzEq, timestamptzEqDate, timestamptzEqTimestamp, timestamptzGe, timestamptzGeDate, timestamptzGeTimestamp, timestamptzGt, timestamptzGtDate, timestamptzGtTimestamp, timestamptzLarger, timestamptzLe, timestamptzLeDate, timestamptzLeTimestamp, timestamptzLt, timestamptzLtDate, timestamptzLtTimestamp, timestamptzMi, timestamptzMiInterval, timestamptzNe, timestamptzNeDate, timestamptzNeTimestamp, timestamptzPlInterval, timestamptzSmaller, timetz, timetzCmp, timetzEq, timetzGe, timetzGt, timetzHash, timetzHashExtended, timetzLarger, timetzLe, timetzLt, timetzMiInterval, timetzNe, timetzPlInterval, timetzSmaller, timetzdatePl, timezone, toAscii, toChar, toDate, toHex, toJson, toJsonb, toNumber, toOct, toRegclass, toRegcollation, toRegnamespace, toRegoper, toRegoperator, toRegproc, toRegprocedure, toRegrole, toRegtype, toRegtypemod, toTimestamp, toTsquery, toTsvector, transactionTimestamp, translate, trimArray, trimScale, trunc, tsDebug, tsDelete, tsFilter, tsHeadline, tsLexize, tsMatchQv, tsMatchTq, tsMatchTt, tsMatchVq, tsParse, tsRank, tsRankCd, tsRewrite, tsStat, tsTokenType, tsmultirange, tsqMcontained, tsqMcontains, tsqueryAnd, tsqueryCmp, tsqueryEq, tsqueryGe, tsqueryGt, tsqueryLe, tsqueryLt, tsqueryNe, tsqueryNot, tsqueryOr, tsqueryPhrase, tsrange, tsrangeSubdiff, tstzmultirange, tstzrange, tstzrangeSubdiff, tsvectorCmp, tsvectorConcat, tsvectorEq, tsvectorGe, tsvectorGt, tsvectorLe, tsvectorLt, tsvectorNe, tsvectorToArray, tsvectorUpdateTrigger, tsvectorUpdateTriggerColumn, txidCurrent, txidCurrentIfAssigned, txidCurrentSnapshot, txidSnapshotXip, txidSnapshotXmax, txidStatus, txidVisibleInSnapshot, unicodeAssigned, unicodeVersion, uniqueKeyRecheck, unistr, unnest, upper, upperInc, upperInf, uuidCmp, uuidEq, uuidExtractTimestamp, uuidExtractVersion, uuidGe, uuidGt, uuidHash, uuidHashExtended, uuidLe, uuidLt, uuidNe, values, varPop, varSamp, varbit, varbitcmp, varbiteq, varbitge, varbitgt, varbitle, varbitlt, varbitne, varchar, variance, version, websearchToTsquery, width, widthBucket, xid, xid8Cmp, xid8Eq, xid8Ge, xid8Gt, xid8Larger, xid8Le, xid8Lt, xid8Ne, xid8Smaller, xideq, xideqint4, xidneq, xidneqint4, xml, xmlIsWellFormed, xmlIsWellFormedContent, xmlIsWellFormedDocument, xmlagg, xmlcomment, xmlconcat2, xmlexists, xmltext, xmlvalidate, xpath, xpathExists };
//# sourceMappingURL=typegres.js.map
